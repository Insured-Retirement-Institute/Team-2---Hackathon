# generated by datamodel-codegen:
#   filename:  sureify.json
#   timestamp: 2026-02-24T17:27:10+00:00

from __future__ import annotations

from datetime import timedelta
from enum import Enum
from typing import Any

from pydantic import AnyUrl, BaseModel, Extra, Field, confloat, conint, constr


class Persona(Enum):
    policyowner = 'policyowner'
    agent = 'agent'


class ID(BaseModel):
    __root__: constr(min_length=1, max_length=64) = Field(
        ...,
        description='Correlation ID - A unique identifier for each entity (whether that entity is a person, a company, a policy, etc). \nWe expose this ID for the purpose of matching entities in our internal system to their corresponding records in external systems, such as carrier SORs.\n*While this value MAY appear to be a UUID, you MUST accept values that are not UUIDs.*\nAlso used for Workflow and Journey Instance IDs.',
        example='4b33ae9e-827a-479d-b60c-8daa2873c08c',
    )


class QuestionGroup(BaseModel):
    ID: ID | None = Field(
        None, description='A unique identifier for the question group.'
    )
    title: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The title of the question group (e.g. Basic Information).',
        example='Basic Information',
    )


class Question(BaseModel):
    ID: ID = Field(..., description='A unique identifier for this question.')
    title: constr(min_length=1, max_length=32767) = Field(
        ..., description='The text of the question.', example='What is your first name?'
    )
    parentID: ID | None = Field(
        None,
        description="A pointer to the `ID` field for for this question's parent question (i.e. the question which this question is nested below). Top level questions to not have a parent question.",
    )
    groupID: ID | None = Field(
        None,
        description='A unique identifier for the question group that this question belongs to.',
    )
    sequence: conint(ge=1) = Field(
        ...,
        description='A number indicating where this question appears on the application, relative to all other questions.\n\nNote: Questions are NOT guaranteed to be returned in consecutive order.\nYou must use the value of `sequence` to order questions relative to each other.\n',
        example=1,
    )


class DateTime(BaseModel):
    __root__: constr(min_length=4, max_length=36) = Field(
        ...,
        description='A timestamp, as specified in [ISO 8601-2:2019 Extended Date/Time Format (EDTF)](https://en.wikipedia.org/wiki/ISO_8601#EDTF).\nUse this type for properties that represent a moment-in-time when a specific action occurred (i.e. a date or a date as well as a time). \nTime zone designator OPTIONAL.\nMonth and Day MAY be a single digit value, if value is less than 10.\n',
        example='2021-08-29T09:12:33.001Z',
    )


class BaseRole(BaseModel):
    class Config:
        extra = Extra.allow

    role: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The function that a person or entity plays in relation to the policy.',
        example='Insured',
    )
    contactID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the person, company, or trust listed on the policy.',
    )
    policyID: ID | None = Field(
        None,
        description='A pointer to the policy record on which this person, company, or trust is listed.',
    )


class Duration(BaseModel):
    __root__: timedelta = Field(
        ...,
        description='An amount of time specified in [ISO 8601:2004 \n(Duration)](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n\nUse this type for any properties that represent durations.\n',
        example='P1Y2M3DT4H5M6S',
    )


class Designation(Enum):
    Primary = 'Primary'
    Joint = 'Joint'
    Child = 'Child'


class Insured(BaseRole):
    class Config:
        extra = Extra.forbid

    designation: Designation | None = Field(
        None,
        description="A designation indicating how this insured is covered (i.e. primary vs. joint). The insured's designation depends on the way that the policy is structured and has implications for how death benefits are distributed, should this insured die.",
    )
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this is the main insured for the policy (i.e. the person who has completed the majority of the application). Only relevant in for policies that list multiple insureds.',
    )
    issueAge: Duration | None = Field(
        None, description='The age of the insured at the time the policy was issued.'
    )
    riskClass: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The risk class (e.g. Preferred, Super Preferred, Substandard, etc.) at which this insured was approved.',
    )
    tableRating: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The table rating (e.g. Table A/1, Table B/2, Table C/3 etc) at which this insured was approved.',
    )


class Annuitant(BaseRole):
    class Config:
        extra = Extra.forbid

    designation: Designation | None = Field(
        None,
        description="A designation indicating how this insured is covered (i.e. primary vs. joint). The insured's designation depends on the way that the policy is structured and has implications for how the proceeds of the policy are distributed, should this annuitant die.",
    )
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this is the main annuitant for the policy (i.e. the person who has completed the majority of the application). Only relevant for policies that list multiple annuitants.',
    )
    issueAge: Duration | None = Field(
        None, description='The age of the annuitant at the time the policy was issued.'
    )


class NonNegativePercent(BaseModel):
    __root__: confloat(ge=0.0) = Field(
        ...,
        description='Percent value (disallows negative values). For example, 150 represents 150%, and 1 represents 1%.\n',
        example=22,
    )


class BeneficiaryDesignation(Enum):
    Primary = 'Primary'
    Contingent = 'Contingent'


class RelationshipToInsured(BaseModel):
    class Config:
        extra = Extra.forbid

    insuredRelatedTo: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The insured whom the beneficiary is related to (e.g. the primary insured vs. another insured).',
        example='Primary',
    )
    relationship: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The way in which the beneficiary is related to the insured (e.g. Spouse, Child, Cousin, etc.)',
        example='Child',
    )


class Type(Enum):
    Person = 'Person'
    Estate = 'Estate'
    Corporation = 'Corporation'
    Charity = 'Charity'
    Trust = 'Trust'
    Other = 'Other'


class Custodian(BaseModel):
    class Config:
        extra = Extra.forbid

    contactID: ID | None = Field(
        None, description='A pointer to the full contact record for this custodian.'
    )
    relationshipToBeneficiary: constr(min_length=1, max_length=32768) | None = Field(
        None,
        description='The way in which this custodian is related to the beneficiary.',
    )


class BeneficiaryProperties(BaseModel):
    class Config:
        extra = Extra.allow

    allocationPercentage: NonNegativePercent | None = Field(
        None,
        description="The percentage of the policy's proceeds (e.g. death benefit) that this beneficiary receives after the insured/annuitant passes.",
    )
    type: Type | None = Field(
        None,
        description='The kind of entity that this beneficiary is (e.g. a Charity, Trust, Company, Person, etc.).',
    )
    designation: BeneficiaryDesignation | None = None
    isIrrevocable: bool | None = Field(
        None,
        description='True indicates that, regardless of whether the insured/annuitant has died or not, this beneficiary must approve any changes to the policy, including beneficiary changes (i.e. the insured/annuitant is unable to remove this beneficiary from the policy, unless the beneficiary explicitly approves the change).',
    )
    isPerStirpes: bool | None = Field(
        None,
        description="True indicates that if a named beneficiary dies before the insured/annuitant, the descendents of that named beneficiary receive the policy's proceeds (e.g. death benefit) rather than the descendents of the insured/annuitant.",
    )
    isPerCapita: bool | None = Field(
        None,
        description="True indicates that every living beneficiary gets an equal share of the policy's proceeds (e.g. death benefit).",
    )
    isPrimarySplit: bool | None = Field(
        None,
        description="True indicates that the policy's proceeds (e.g. death benefit) is split evenly across all primary beneficiaries.",
    )
    isContingentSplit: bool | None = Field(
        None,
        description="True indicates that the policy's proceeds (e.g. death benefit) is split evenly across all contingent beneficiaries.",
    )
    relationshipToInsured: RelationshipToInsured | None = Field(
        None,
        description="The way in which the beneficiary is related to the insured/annuitant, and which insured/annuitant they're related to.",
    )
    custodians: list[Custodian] | None = Field(
        None,
        description='A collection of custodians for the beneficiary.',
        max_items=32768,
        min_items=0,
    )


class Beneficiary(BaseRole, BeneficiaryProperties):
    class Config:
        extra = Extra.forbid


class Owner(BaseRole):
    class Config:
        extra = Extra.forbid

    isPrimary: bool | None = Field(
        None,
        description='True indicates that this is the main owner for the policy (i.e. the person who has completed the majority of the application). Only relevant in for policies that list multiple owners.',
    )
    relation: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The relationship between the owner and the insured/annuitant (e.g. Spouse, Child, Cousin, etc.).',
        example='Spouse',
    )


class Agent(BaseRole):
    class Config:
        extra = Extra.forbid

    type: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A label indicating how this agent engages with the policy (e.g. Writing Agent, Servicing Agent, etc.)',
        example='Servicing',
    )
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this agent is the main point of contact for the policy. Oversees correspondence and activity on the policy.',
    )
    commissionPercentageSplit: NonNegativePercent | None = Field(
        None,
        description='The proportion of commission assigned to this agent when multiple agents are associated with a policy.',
    )


class Other(BaseRole):
    class Config:
        extra = Extra.allow

    isPrimary: bool | None = Field(
        None,
        description='True indicates that this person/organization is somehow more important than any other person/organization that plays the same role on a particular policy.\nFor example, isPrimary may indicate the main point of contact, or the person who is ultimately responsible for fulfilling a piece of work.\nNote that this marker is only relevant when there are multiple people/organizations who play the same role on a particular policy.\n',
    )


class Answer(BaseModel):
    answer: constr(min_length=1, max_length=32767) = Field(
        ..., description='An answer to a question.', example='John'
    )
    date: DateTime | None = Field(
        None, description='The date and time at which this answer was submitted.'
    )
    attempt: conint(ge=1) = Field(
        ...,
        description='A number indicating the chronological order in which this answer was submitted.\nThe `attempt` value with the highest number is the most recent answer.\n\nNote: Answers are NOT guaranteed to be returned in chronological order.\nUse the value of the `attempt` property to chronologically order answers relative to each other.\n',
        example=1,
    )
    roleSnapshot: Insured | Annuitant | Beneficiary | Owner | Agent | Other | None = (
        Field(
            None,
            description='A snapshot of the role best characterizing the individual who submitted this answer.',
        )
    )


class AnswerHistoryItem(BaseModel):
    questionID: ID = Field(
        ...,
        description='A pointer to the question that this set of historical answers is associated with.',
    )
    answers: list[Answer] | None = Field(
        None,
        description='A collection of historical answers.\nNote: Answers are not guaranteed to be returned in any particular order.\nUse the `attempt` property to determine the chronological order of answers.\n',
    )


class AnswerHistory(BaseModel):
    __root__: list[AnswerHistoryItem] = Field(
        ...,
        description='A collection of historical answers, grouped by the question that they are associated with.',
        title='Answer History',
    )


class Application(BaseModel):
    caseID: ID = Field(
        ..., description='A pointer to the case that the answers are associated with.'
    )
    answerHistory: list[AnswerHistory] | None = Field(
        None,
        description='A collection of historical answers, grouped by the question they are associated with. \n\nNote: Answers are NOT guaranteed to be returned in consecutive order.\nYou must use the value of the `attempt` property to order answers relative to each other.\n',
        max_items=32768,
        min_items=0,
    )
    applicationNumber: str | None = Field(
        None,
        description='A combination of letters and numbers that the e-apply vendor uses to uniquely identify an application in the application entry system.',
    )
    URL: AnyUrl | None = Field(
        None,
        description='The URL (i.e. web address) of the external server, website, or application to which a user may be redirected.',
    )


class MonetaryAmountCurrency(BaseModel):
    class Config:
        extra = Extra.allow

    currency: constr(min_length=3, max_length=3) = Field(
        ...,
        description='The ISO standard currency code for this monetary amount.',
        example='USD',
    )


class NonNegativeMonetaryAmount(MonetaryAmountCurrency):
    class Config:
        extra = Extra.allow

    value: conint(ge=0) = Field(
        ...,
        description='The value for a monetary amount in cents. Negative values are not allowed.',
        example=49987,
    )


class State(Enum):
    AL = 'AL'
    AK = 'AK'
    AZ = 'AZ'
    AR = 'AR'
    CA = 'CA'
    CO = 'CO'
    CT = 'CT'
    DE = 'DE'
    FL = 'FL'
    GA = 'GA'
    HI = 'HI'
    ID = 'ID'
    IL = 'IL'
    IN = 'IN'
    IA = 'IA'
    KS = 'KS'
    KY = 'KY'
    LA = 'LA'
    ME = 'ME'
    MD = 'MD'
    MA = 'MA'
    MI = 'MI'
    MN = 'MN'
    MS = 'MS'
    MO = 'MO'
    MT = 'MT'
    NE = 'NE'
    NV = 'NV'
    NH = 'NH'
    NJ = 'NJ'
    NM = 'NM'
    NY = 'NY'
    NC = 'NC'
    ND = 'ND'
    OH = 'OH'
    OK = 'OK'
    OR = 'OR'
    PA = 'PA'
    RI = 'RI'
    SC = 'SC'
    SD = 'SD'
    TN = 'TN'
    TX = 'TX'
    UT = 'UT'
    VT = 'VT'
    VA = 'VA'
    WA = 'WA'
    WV = 'WV'
    WI = 'WI'
    WY = 'WY'
    DC = 'DC'
    AS = 'AS'
    GU = 'GU'
    MP = 'MP'
    PR = 'PR'
    UM = 'UM'
    VI = 'VI'


class Attribute(BaseModel):
    class Config:
        extra = Extra.forbid

    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The key part of a product attribute key:value pair. \n \n If referencing the key:value pair examples given in the `attributes` description, the key are: Availability, Target Audience, and Liquidity.\n',
        example='Target Audience',
    )
    value: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The value part of a product attribute key-value pair. \n \n If referencing the key:value pair examples given in the `attributes` description, the values are: All of USA, Seniors 65+, and Free Partial Withdrawals.\n',
        example='Senior, 65+',
    )
    category: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the category to which this attribute belongs to.',
        example='Audience',
    )


class Plan(BaseModel):
    class Config:
        extra = Extra.forbid

    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the plan available within the product.\n \n For example, if the product is "Whole Life 5", plan names may be "Whole Life 5 Silver", "Whole Life 5 Gold", or "Whole Life 5 Platinum with LTC".\n',
        example='WholeLife 5 Silver',
    )
    planCode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and/or numbers that the carrier uses to uniquely identify the plan available within the product (ABC01s28).',
        example='A1128',
    )


class URL(BaseModel):
    class Config:
        extra = Extra.forbid

    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the external server, website, or application to which this URL redirects the user (e.g. LifetimeACQUIRE). Note that this name is separable from any button text that may be used to present the URL on a UI.',
        example='LifetimeACQUIRE',
    )
    URL: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The URL (i.e. web address) of the external server, website, or application to which a user may be redirected.',
        example='https://dev-agent.sureify.com/',
    )


class Product(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(None, description='A unique identifier for this product.')
    productCode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and/or numbers that the carrier uses to uniquely identify the given product.',
        example='SPDA',
    )
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the product (e.g. SureCo Whole 30, Term 20, SureCo Annuity Plus).',
        example='Whole Life Insurance',
    )
    carrierCode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and/or numbers that the carrier uses to uniquely identify the company associated to the product.',
        example='LC10',
    )
    documentIDs: list[ID] | None = Field(
        None,
        description='A collection of pointers to the documents related to this product .\n',
        max_items=32768,
        min_items=0,
    )
    attributes: list[Attribute] | None = Field(
        None,
        description='A collection of key:value pairs that give information about various characteristics of the product, such as where the product is available (e.g. Availability:All of USA), the age range that the product is designed for (e.g. Target Audience:Seniors 65+), or the benefits offered in the product (Liquidity:Free Partial Withdrawals).\n',
        max_items=32768,
        min_items=0,
    )
    plans: list[Plan] | None = Field(
        None,
        description='A collection of plans available within the product. Plans are particular configurations of benefits or requirements, providing fine-grained variations within a given product (e.g. specifying how many years money must stay invested before withdrawal).\n',
        max_items=32768,
        min_items=0,
    )
    URLs: list[URL] | None = Field(
        None,
        description='A collection of URLs that redirect the user to an external server, website, or application.',
        max_items=32768,
        min_items=0,
    )
    states: list[State] | None = Field(
        None,
        description='A collection of states in which this product is applicable, valid, registered, etc.',
        example=['AZ', 'OH'],
        max_items=50,
    )


class Type1(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(None, description='A unique identifier for this group/type .')
    name: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The name of this group/type.', example='Life'
    )


class ApplicationType(Enum):
    Electronic = 'Electronic'
    Paper = 'Paper'


class PaymentMethod(Enum):
    creditcard = 'creditcard'
    check = 'check'
    debit = 'debit'


class Type2(Type1):
    parent: Type1 | None = None


class ProductSnapshot(Product):
    type: Type2 | None = None


class CasePolicyBase(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(
        None, description='A unique identifier for this case or policy.'
    )
    annualPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money the insured _would pay_ if paying on an annual mode (i.e. paying once per year).',
    )
    annualizedPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The _actual_ amount of money the insured pays over the course of a year. This amount is calculated by multiplying the mode (the number of payments an insured makes per year) by the modal premium (the amount of money included in each payment).',
    )
    applicationType: ApplicationType | None = Field(
        None,
        description='The process by which the application for this case or policy was submitted.',
        example='Electronic',
    )
    carrier: str | None = Field(
        None,
        description='The insurance company that issues the policy. _Note that this may be a subsidiary of a larger',
    )
    commissionableAnnualizedPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description="The amount of money paid in premium that is used to calculate an agent's commission on the policy over the course of a year.\n",
    )
    coveredUntilDate: DateTime | None = Field(
        None,
        description='The date on which policy coverage ends (i.e. the last day the insured is still  eligible to make a claim or receive a death benefit). Typically found with Term policies. If a `coveredUntilDate` is included on a permanent policy, it is usually set to 100 years after the date when the policy was issued.',
    )
    deathBenefit: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money that is paid out to the beneficiary of a life or annuity insurance policy when the insured or annuitant dies. Typically used in Whole Life, Universal Life, or Annuities (as opposed to Term Life).  \n\n`deathBenefit` may differ from `faceAmount` in that `deathBenefit` may change over time, while `faceAmount` stays the same over the lifetime of a policy. \n\nThe value of `deathBenefit` often changes because adjustments (e.g. the accrual of interest) are made to it over the lifetime of the policy. \n\nIn Annuities, if an annuitant dies before the full annuity has been paid out, the `deathBenefit` is paid out to beneficiaries.\n',
    )
    documentIDs: list[ID] | None = Field(
        None,
        description='A collection of pointers to the documents related to this policy. Examples of policy-related documents include, but are not limited to: anniversary statements and policy pages.\n',
        example=['4b33ae9e-827a-479d-b60c-8daa2873c08c'],
        max_items=32768,
        min_items=0,
    )
    effectiveDate: DateTime | None = Field(
        None, description='The date on which the case becomes an active policy.'
    )
    faceAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The monetary amount of the death benefit at the time when the policy was issued. Typically used in Term Life (as opposed to Whole Life, Universal Life, or Annuities).  \n\nThe value of `faceAmount` at the time of policy issuance is the same as it is at the time of the claim, whereas the value of  `deathBenefit` may change over time.\n',
    )
    excess: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The portion of a commissionable annualized premium that an agent does _not_ receive full first year commission on. Note: `commissionableAnnualizedPremium` = `target` + `excess`.\n',
    )
    carrierLastUpdated: DateTime | None = Field(
        None, description='The date on which the carrier last updated this policy.'
    )
    guaranteedMinimumDeathBenefit: NonNegativeMonetaryAmount | None = Field(
        None,
        description="The lowest dollar amount that the contract guarantees will be paid out in the event of the insured's/annuitant's death.",
    )
    modalPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money a policyowner pays in premium when they receive their bill. The frequency at which the policyowner receives their bill and pays a `modalPremium` is called the `paymentMode`.\n',
    )
    nextPremiumDueDate: DateTime | None = Field(
        None, description='The date on which the next premium payment is due.'
    )
    paymentMethod: PaymentMethod | None = Field(
        None,
        description='The way in which the policyowner pays the premiums on their policy (e.g. via EFT, direct billing, credit card, etc). Sometimes referred to as billing method.',
        example='creditcard',
    )
    paymentMode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The frequency at which a policyowner is expected to pay the premium on their policy (e.g. Monthly, Quarterly, Semi-annually, or Annually). Note: The amount of money payable each time the policyowner receives their bill is the called the `modalPremium`.',
        example='Monthly',
    )
    policyNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify the policy; sometimes referred to as a contract number. A given contract MAY have both a `caseNumber` and a `policyNumber`, especially if the transition from case to policy took place recently.',
        example='ABC458587def',
    )
    productSnapshot: ProductSnapshot | None = Field(
        None,
        description='A snapshot of the base coverage product the policyowner purchases in order to create their policy.\nModifying coverages such as riders, plans, etc. can be added to this base product to build out a full policy.\n',
    )
    premiumType: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The way in which premium money is received into the policy or annuity (e.g. Initial, Unplanned, EFT).',
        example='Initial',
    )
    isOwnerSignatureMissing: bool | None = Field(
        None,
        description="True indicates that the owner's signature is missing from the policy.",
        example=True,
    )
    issueState: State | None = Field(
        None,
        description='The state (geographical region within the United States) in which this case or policy was issued.',
    )
    status: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The status of the case or policy. Examples include, but are not limited to Pending, Approved, Issued, Inforce, Paid, Lapsed, etc.',
    )
    statusCategory: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A group of related statuses. May be used as a metric for reporting or data visualization.\n',
        example='Lapsed',
    )
    statusDate: DateTime | None = Field(
        None,
        description='The most recent date on which the carrier updated the `status` of this case or policy.',
    )
    target: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The premium monetary amount that is applied to the agents first year commission rate. Note: `commissionableAnnualizedPremium` = `target` + `excess`.',
    )
    tenThirtyFiveExchangeAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money that can be transferred from an existing policy into a new policy without any immediate tax consequences.',
    )


class MonetaryAmount(MonetaryAmountCurrency):
    value: int = Field(
        ...,
        description='The value for this monetary amount in cents. Negative values are allowed.',
        example=49987,
    )


class FundingCompany(BaseModel):
    name: constr(min_length=1, max_length=255) | None = Field(
        None, description='The name of the funding company.'
    )
    referenceNumber: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The reference number associated with the policy at the funding company to be exchanged into this new policy.',
    )
    requestedDate: DateTime | None = Field(
        None,
        description='The date on which the carrier sent out a notification requesting the funds.',
        example='2021-08-29T09:12:33.001Z',
    )
    receivedDate: DateTime | None = Field(
        None,
        description='The date on which the carrier received the funds from the funding company.',
        example='2021-08-29T09:12:33.001Z',
    )
    requestedAmount: NonNegativeMonetaryAmount | None = Field(
        None, description='The total money requested by the carrier.'
    )
    receivedAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total money received by the carrier from the funding company.',
    )
    status: constr(min_length=1, max_length=255) | None = Field(
        None, description='The status of the money (e.g. received, outstanding, etc.)'
    )


class NIGO(BaseModel):
    class Config:
        extra = Extra.forbid

    isNIGO: bool | None = Field(
        None,
        description='True indicates that the case is in NIGO (Not In Good Order) state.',
        example=True,
    )
    reason: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The reason why the case is in NIGO (Not In Good Order) state.',
        example='Agent information is missing',
    )
    category: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The category of NIGO (Not In Good Order) applicable to this case. Examples include Agent, Client, Form etc.',
        example='Agent',
    )
    beginDate: DateTime | None = Field(
        None,
        description='The date on which the case transitioned into NIGO (Not In Good Order) state.',
    )
    endDate: DateTime | None = Field(
        None,
        description='The date on which the case transitioned out of NIGO (Not In Good Order) state.',
    )


class Case(CasePolicyBase):
    appliedRiskClass: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The risk class (e.g. Preferred, Super Preferred, Substandard, etc.) that the agent/client submits on the application. Risk class is subject to change as a case moves through the underwriting process. This is why the original `appliedRiskClass`  may be different than the final `approvedRiskClass` that appears on the inforce policy. After a policy becomes inforce, the original `appliedRiskClass` is stored for reporting purposes.',
    )
    approvedRiskClass: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The risk class (e.g. Preferred, Super Preferred, Substandard, etc.) that the carrier approves, and that therefore appears on the policy once it is inforce. Risk class is subject to change as a case moves through the underwriting process. This is why the original `appliedRiskClass`  may be different than the final `approvedRiskClass` that appears on the inforce policy.',
    )
    approvedTableRating: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The table rating (e.g. Table A/1, Table B/2, Table C/3 etc) at which the insured was approved. When the insured is table-rated, they must pay an extra percentage on top of the standard premium.',
    )
    balanceDue: MonetaryAmount | None = Field(
        None,
        description='The amount of money that the insured currently owes on a pending policy. \nFor example, the insured may have a balance due if their policy is accepted at a higher rate than what was originally quoted. In such a situation, the insured must pay the `balanceDue` in order to make the policy inforce.\n',
    )
    cashReceived: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money the carrier receives along with the application (i.e. the money that a policyowner submits as part of the application).\nNote: Any additional money due, that is not received with the application, is considered a `balanceDue`.\n',
    )
    dateCashReceived: DateTime | None = Field(
        None,
        description='The date on which the money that came in with the application (`cashReceived`) was collected by the carrier.',
    )
    applicationReceivedDate: DateTime | None = Field(
        None, description='The date the application was received.'
    )
    applicationSignedDate: DateTime | None = Field(
        None, description='The date the application was signed.'
    )
    caseNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A number assigned by an application system such as Firelight or LifetimeACQUIRE, used to identify the case. If the case becomes a policy, the `caseNumber` is stored temporarily until a policy number or contract number is received.',
        example='C458587',
    )
    NIGO: NIGO | None = Field(
        None, description='A summary of NIGO (Not In Good Order) state.'
    )
    underwritingType: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The type of underwriting performed on this case before it can become an active policy. Examples include but are not limited to: Full, Instant Issue, Automated, etc.',
        example='Full',
    )
    fundingCompanies: list[FundingCompany] | None = Field(
        None,
        description='A collection of companies that will fund the case in flight.',
        max_items=32768,
        min_items=0,
    )


class Name(BaseModel):
    class Config:
        extra = Extra.forbid

    first: constr(min_length=1, max_length=32767) | None = Field(
        None, description='First name.', example='Bob'
    )
    last: constr(min_length=1, max_length=32767) | None = Field(
        None, description='Last name.', example='Smith'
    )
    middle: constr(min_length=1, max_length=32767) | None = Field(
        None, description='Middle name or initial.', example='J.'
    )
    suffix: constr(min_length=1, max_length=32767) | None = Field(
        None, description='Name suffix.', example='Jr.'
    )
    fullName: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description="A person's full name, as represented in a single data field. Use `fullName` whenever name data is not broken down into first & last names. `fullName` may also be used for names of companies, trusts, and organizations.",
        example='Bob J. Smith',
    )


class BaseEmail(BaseModel):
    class Config:
        extra = Extra.allow

    emailAddress: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The text of the email address.', example='info@sureify.com'
    )


class Email(BaseEmail):
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this email address has been designated as the best one to use for a particular contact. Within a collection of email addresses for a given contact, **exactly one** must be marked `isPrimary`.',
        example=True,
    )
    type: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The context in which this email address is used (e.g. work vs. personal email address).',
        example='personal',
    )


class BasePhoneNumber(BaseModel):
    class Config:
        extra = Extra.allow

    phoneNumber: constr(min_length=1, max_length=50) | None = Field(
        None, description='A phone number', example='8558675309'
    )


class PhoneNumber(BasePhoneNumber):
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this phone number has been designated as the best one to use for a particular contact. Within a collection of phone numbers for a given contact, **exactly one** must be marked `isPrimary`.',
        example=True,
    )
    type: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The context in which this phone number is used (e.g. work vs. mobile).',
        example='mobile',
    )


class BaseAddress(BaseModel):
    class Config:
        extra = Extra.allow

    address1: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The first address field, typically containing a number/ street name combination.',
        example='1100 Lincoln Ave',
    )
    address2: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The second address field, typically containing an apartment or suite number.',
        example='Unit 240',
    )
    address3: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description="The third address field, typically only used for indicating 'Care Of' (C/O), or other notes.",
        example='C/O Fred Rogers',
    )
    city: constr(min_length=1, max_length=32767) | None = Field(
        None, description='A city name.', example='San Jose'
    )
    country: constr(min_length=2, max_length=3) | None = Field(
        None,
        description='A two or three letter country code.\nUses the ISO 3166-1 standard.',
        example='US',
    )
    state: State | None = None
    postalCode: constr(min_length=5, max_length=10) | None = Field(
        None,
        description='A zip/postal code in five digit or zip+4 format.',
        example='95125-9698',
    )
    type: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The context in which this address is used (e.g. work vs. home address).',
        example='home',
    )


class Address(BaseAddress):
    isBadAddress: bool | None = Field(
        None,
        description='True indicates that this address is known to be unusable, either because mail was returned, or because address validation failed.',
        example=True,
    )
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this address has been designated as the best one to use for a particular contact. Within a collection of addresses for a given contact, **exactly one** must be marked `isPrimary`.',
        example=True,
    )


class BasePerson(BaseModel):
    class Config:
        extra = Extra.allow

    name: Name | None = None
    governmentIDNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A government-issued identification number used for taxation and/or or legal identification purposes (e.g. social security number).',
        example='365-86-8526',
    )
    DOB: DateTime | None = Field(
        None,
        description="This person's date of birth (DOB). The field may contain only a birth year if data for the person is incomplete.",
    )
    sex: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The legally recognized gender of the person, usually as assigned at birth.',
        example='female',
    )
    emails: list[Email] | None = Field(
        None,
        description='A collection of email addresses for this person.',
        max_items=32768,
        min_items=0,
    )
    phoneNumbers: list[PhoneNumber] | None = Field(
        None,
        description='A collection of telephone numbers by which this person can be reached.',
        max_items=32768,
        min_items=0,
    )
    addresses: list[Address] | None = Field(
        None,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )


class Type3(Enum):
    Person = 'Person'


class Person(BasePerson):
    ID: ID | None = Field(None, description='A unique identifier for this contact.')
    type: Type3 | None = None
    personNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify the person.',
        example='12345678AbC',
    )
    companyID: ID | None = Field(
        None,
        description='A pointer to the full contact record for the company or organization that this person is associated with (e.g. the LLC or sole proprietorship that this person does business under).',
    )
    agencyID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the business that this person works for.',
    )


class BaseCompany(BaseModel):
    name: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The name of the corporate entity.', example='SureCo'
    )
    addresses: list[Address] | None = Field(
        None,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )
    website: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description="The URL for a company's website.",
        example='https://www.acme-co.com',
    )
    companyCode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify this company or agency.',
        example='12345678ABc',
    )
    businessType: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The legal business structure of this company (e.g. LLC, S corporation, sole proprietorship, etc.).',
        example='LLC',
    )
    phoneNumbers: list[PhoneNumber] | None = Field(
        None,
        description='A collection of telephone numbers by which this company can be reached.',
        max_items=32768,
        min_items=0,
    )


class Type4(Enum):
    Company = 'Company'


class Company(BaseCompany):
    ID: ID | None = Field(None, description='A unique identifier for this contact.')
    type: Type4 | None = None
    parentCompanyID: ID | None = Field(
        None,
        description='A pointer to the parent company that this company is a subsidiary of (if one exists).',
    )


class MostRecentPayment(BaseModel):
    class Config:
        extra = Extra.forbid

    date: DateTime | None = Field(
        None,
        description='The date on which the carrier received the most recent payment.',
    )
    amount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money the carrier collected at the time of the most recent payment.',
    )
    reason: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='An explanation for why the most recent payment differs from the normal (i.e. expected) amount. This field is only used in situations that significantly stray from the norm. \n\n Example: if the most recent payment is twice as large as normal, the `reason` might be "This payment is double because the previous payment was skipped".\n',
    )


class Percent(BaseModel):
    __root__: float = Field(
        ...,
        description='Percent value (allows negative values). For example: 150 represents 150%, 1 represents 1%, and -1 represents -1%.\n',
        example=-22,
    )


class CashValueHistoryItem(BaseModel):
    class Config:
        extra = Extra.forbid

    value: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The cash value of the policy at a particular moment in time (`date`).\n',
    )
    percentageChange: Percent | None = Field(
        None,
        description='The percentage rise or fall of cash-value during the time period',
    )
    date: DateTime | None = Field(
        None, description='The date on which this cash value line-item was generated.\n'
    )


class Loan(BaseModel):
    class Config:
        extra = Extra.forbid

    repayBalance: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money required to pay off the loan, should the policyowner repay the loan today. This amount _excludes_ any expected/future interest.',
    )
    mostRecentPayment: MostRecentPayment | None = Field(
        None, description='The most recent loan payment received by the carrier.'
    )
    accruedInterest: NonNegativeMonetaryAmount | None = Field(
        None,
        description="The interest that has accrued on the loan. _Note- the carrier must choose the time period applicable to this interest rate (i.e. whether this field represent the interest accrued over the loan's lifetime, since the last payment date,  or over another period of time)_.",
    )
    currentBalance: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The current balance of the loan (i.e. the balance that remains at this moment in time, taking into account any payments that have already been made).',
    )
    interestRate: NonNegativePercent | None = Field(
        None, description='The rate at which interest on the loan accrues.'
    )


class Policy(CasePolicyBase):
    class Config:
        extra = Extra.allow

    accountNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The "master" or "parent" contract number under which this policy is grouped. Only use this field when this policy belongs to a collection of policies that are all billed to a single "master" account (e.g. if someone holds a collection of policies, one for each of their grandchildren, each individual policy will be linked to the same master `accountNumber`).',
        example='AA77777',
    )
    accruedInterest: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money that has accumulated in interest over the lifetime of the policy',
    )
    cashValue: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money that a policyowner can take out of their policy/annuity (i.e. the current monetary value of the policy/annuity, after any fees associated with withdrawal have been taken out).\n',
    )
    isCollateralOwnershipAssigned: bool | None = Field(
        None,
        description='True indicates that there is a loan against the policy (i.e. the policyowner has used the policy as collateral in order to secure a loan). If the insured dies before the loan is repaid, the lender can collect the outstanding balance from the death benefit of the life insurance policy.',
        example=True,
    )
    currentInterestRate: NonNegativePercent | None = Field(
        None,
        description='The interest rate that the policy currently pays at, as a percentage. This value may change over time.',
    )
    paidThroughDate: DateTime | None = Field(
        None,
        description='The date through which the policy is paid for (i.e. the date on which a new premium will be due).',
    )
    mortalityPaidThroughDate: DateTime | None = Field(
        None,
        description='A date recalculated by the carrier on a month-by-month basis that indicates whether the policy has enough cash value and/or premium applied to pay the cost-of-insurance into the next month. Some carriers may use this field to indicate when a policy is valid into the next month.\n',
    )
    currentPlanLapseDate: DateTime | None = Field(
        None,
        description="The date on which a policy is expected to lapse if a policyowner continues to make monthly premium payments that _fall short_ of the monthly cost of insurance. In such situations the remaining monthly cost is deducted from the policy's `cashValue`, leading the policy to lapse once that cash value is depleted. This `currentPlanLapseDate` is only provided when the client is making partial premium payments.",
    )
    noPremiumLapseDate: DateTime | None = Field(
        None,
        description="The date on which a policy is expected to lapse if the policyowner has _completely stopped paying premiums on the policy_, and is instead using the policy's `cashValue` to pay the policy's premiums. This `noPremiumLapseDate` is only provided when the client has stopped making premium payments.",
    )
    deathBenefitOption: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of a particular set of stipulations for the death benefit, or the way in which the death benefit on the policy is configured.',
    )
    isDeathClaim: bool | None = Field(
        None,
        description='True indicates that there is currently a death claim against the policy.',
        example=True,
    )
    isDeficientOrDelinquent: bool | None = Field(
        None,
        description='True indicates that the policyowner has made a payment which falls short of the full amount due (deficient), has failed to make a payment (delinquent), or both.',
        example=True,
    )
    isDisabilityClaim: bool | None = Field(
        None,
        description='True indicates that there is currently an active disability claim against the policy.',
        example=True,
    )
    loan: Loan | None = None
    lastDateToPayPremium: DateTime | None = Field(
        None,
        description='The hard deadline (often after a grace period has passed) by which the policyowner must pay the premium. If the policyowner fails to pay the premium on or before this date, the policy will lapse out.',
    )
    mostRecentPayment: MostRecentPayment | None = Field(
        None, description='The most recent premium payment received by the carrier.'
    )
    nonCommissionablePolicyFee: NonNegativeMonetaryAmount | None = Field(
        None,
        description='A non commissionable policy fee is the amount of money that is included in the premium that goes to cover the application processing costs. This fee is not commissioned to the Agent.',
    )
    isModifiedEndowmentContract: bool | None = Field(
        None,
        description='True indicates that this is a Modified Endowment Contract (i.e. a life insurance policy that has permanently lost its tax benefits because it contains too much cash). When the `cashValue` of a policy exceeds federal tax limits, the IRS relabels the policy as a Modified Endowment Contract (MEC), removing tax benefits for withdrawals and loans.',
    )
    nextDraftDate: DateTime | None = Field(
        None,
        description="The date the policyowner has chosen for funds to be electronically withdrawn from their bank account in order to pay the policy's premium. Only applicable when the `paymentMethod` for the policy is electronic funds transfer (EFT). _Note that this is different from they day on which the premium is due, or the `paidThroughDate`._",
    )
    oldPolicyNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The former policy number for this policy. If this policy was transferred over, or otherwise originated from a previous policy with a different policy number, the original policy number can be stored here.',
        example='123-555-5555',
    )
    policyAge: Duration | None = Field(
        None, description='The length of time the policy has been inforce.'
    )
    policyFee: NonNegativeMonetaryAmount | None = Field(
        None,
        description='A policy fee is the amount of money that is included in the premium that goes to cover the application processing costs.',
    )
    premiumToKeepPolicyActive: MonetaryAmount | None = Field(
        None,
        description='The amount of money necessary, as a premium, to keep the policy inforce. Typically seen on Cash Value policies.',
    )
    baseCoveragePremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The premium needed to keep the base policy inforce minus any of the rider coverages that have been added to the policy.',
    )
    surrenderCharge: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money that is charged in penalties, should the policyowner cancel the policy in order to withdraw money early/before an agreed upon date. `surrenderCharge` is typically calculated as a percentage, and varies from state to state.',
    )
    surrenderValue: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money that a policyowner would be able to withdraw, should they cancel the policy early/before an agreed upon date. _Note that `surrenderValue` = `cashValue` - `surrenderCharge`._',
    )
    termConversionDate: DateTime | None = Field(
        None,
        description='The last day to convert a term policy into a permanent policy. Often referred to as the term conversion expiration date.',
    )
    totalPremiumPaid: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money paid in premium over the lifetime of the policy.',
    )
    totalWithdrawals: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money ever withdrawn from the policy. Differs from `yearToDateWithdrawals` in that this value is cumulative over the lifetime of the policy.',
    )
    cashValueDate: DateTime | None = Field(
        None,
        description='The "as of" date for when the current `cashValue` was calculated by the carrier.',
    )
    cashValueHistory: list[CashValueHistoryItem] | None = Field(
        None,
        description="A collection of line-items of the account's total cash value at different points in time.",
        max_items=32768,
        min_items=0,
    )
    isSuspendIndicator: bool | None = Field(
        None, description='True indicates that the policy is Suspended.', example=True
    )


class PayoutSchedule(BaseModel):
    class Config:
        extra = Extra.forbid

    numberOfPaymentsExpected: conint(ge=0) | None = Field(
        None,
        description='The total number of times the annuitant/insured is expected to receive a payout.',
        example=5,
    )
    method: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The method by which payouts are transferred to the annuitant/insured (e.g. via EFT, check, etc.).',
        example='EFT',
    )
    installmentAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The dollar amount paid out to the annuitant/insured in a given installment. The frequency at which this `installmentAmount` is disbursed is noted in the `frequency` property.',
    )
    startDate: DateTime | None = Field(
        None, description='The date on which payouts from the policy/annuity began.'
    )
    nextDate: DateTime | None = Field(
        None, description='The next date on which a payout will be made.'
    )
    mostRecentDate: DateTime | None = Field(
        None, description='The most recent date on which a payout was made.'
    )
    frequency: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The frequency at which money is paid out to the annuitant/insured (e.g. Monthly, Quarterly, Semi-annually, or Annually).',
        example='Monthly',
    )
    type: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The way in which installments are scheduled to be paid out to the annuitant/insured (e.g. systematic withdrawals, required minimum distribution payments, a one-time withdrawal, etc).',
        example='systematic withdrawals',
    )


class Annuity(Policy):
    class Config:
        extra = Extra.allow

    annuityValue: MonetaryAmount | None = Field(
        None, description='The amount of money of the annuity is currently worth.'
    )
    costBasisAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The original amount of money put into the annuity. \n\nNote: this value can be recalculated for various reasons (e.g. adding more money to the `annuityValue` on an anniversary may cause the value of `costBasisAmount` to be recalculated).\n',
    )
    cumulativePremiumAmount: NonNegativeMonetaryAmount | None = Field(
        None, description='The total premium paid into this annuity over time.'
    )
    currentValue: MonetaryAmount | None = Field(
        None,
        description='The total amount of money in the annuity, including any interest received over time.',
    )
    excludableAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of annuity payment that can be excluded from taxes using the annuitants exclusion allowance.',
    )
    guaranteedMinimumInterestRate: NonNegativePercent | None = Field(
        None,
        description='The lowest interest rate that can be applied to the annuity. Also referred to as the "floor" interest rate.',
    )
    grossDistributionAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The full amount of money to be distributed from the annuity, before any fees and/or taxes have been taken out.',
    )
    guaranteedWithdrawalBenefit: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money that the contract guarantees can be withdrawn over a particular period of time.',
    )
    marketValueAdjustment: NonNegativeMonetaryAmount | None = Field(
        None,
        description='A fee that can be applied in the event of an early withdrawal that violates contract terms.',
    )
    minimumDistribution: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The minimum dollar amount that the annuitant/insured is required to withdraw during the payout period.',
    )
    payoutSchedule: PayoutSchedule | None = Field(
        None,
        description='An assortment of data representing how annuity payments and withdrawals occur over time.\n',
    )
    purchaseDate: DateTime | None = Field(
        None,
        description='The date on which the annuity was bought or purchased by the policyowner. Sometimes referred to as "signed date", because it is when the policyowner signs the paperwork agreeing to make the purchase.',
    )
    qualificationType: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A category indicating how taxes may or may not be applied to the contract once it is inforce (e.g. Qualified, Not Qualified, IRA, Roth IRA, etc).',
        example='Qualified',
    )
    yearToDateWithdrawals: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money that has been withdrawn from the policy or annuity since the beginning of the current year. This value is sometimes important for policyowner tax purposes.',
    )
    currentYearContributions: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money paid into the policy/annuity since the beginning of the current year.',
    )
    previousYearContributions: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money paid into the policy/annuity during the calendar year prior to this one.',
    )
    yearEndInterestRate: confloat(ge=0.0, le=100.0) | None = Field(
        None,
        description='The interest rate at which the policy is contractually obligated to pay for the duration of a calendar year. Note that this calendar year ends on the `yearEndInterestRateDate`.',
        example=50.5,
    )
    yearEndInterestRateDate: DateTime | None = Field(
        None,
        description='The date on which the calendar year duration for a particular `yearEndInterestRate` ends.',
    )


class Life(Policy):
    class Config:
        extra = Extra.allow

    costOfInsurance: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money required to keep the policy active/inforce, per billing cycle (i.e. the portion of the `modalPremium` that pays for the policy to stay inforce, as opposed to fees, etc).',
    )
    modalFactor: NonNegativePercent | None = Field(
        None,
        description='A percentage that the insurance carrier uses to determine the premium to be paid when the mode is something other than Annual.  It is an increase of the overall premium by a modalFactor percent to cover the costs associated with the increased premium frequency.',
    )
    specifiedAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The value of the death benefit, as written on the application when the policy was purchased. `specifiedAmount` remains constant regardless of how the actual value of `deathBenefit` may change over time.',
    )
    target: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The premium amount that is applied to the agents first year commission rate. Any premium that is not considered `target` but is paid by the insured is considered `excess`.',
    )
    termDuration: Duration | None = Field(
        None,
        description='The length of time for which a Term policy remains valid. Only applies to Term business. Typically this duration is reported in years (e.g. the Term policy may be valid for 10 years, 15 years, 20 years).',
        example='P20Y',
    )


class ReasonForCommission(Enum):
    Base = 'Base'
    Rider = 'Rider'
    Trail = 'Trail'
    Excess = 'Excess'


class TransactionType(Enum):
    Credit = 'Credit'
    Debits = 'Debits'
    Clawbacks = 'Clawbacks'
    ChargeBack = 'ChargeBack'
    Manual_Activity = 'Manual Activity'
    Trails = 'Trails'
    Premium_Payment = 'Premium Payment'


class Commission(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID = Field(
        ..., description='A unique identifier for an individual commission transaction.'
    )
    statementDate: DateTime | None = Field(
        None,
        description='The date on which the commissions statement containing this transaction was issued. \n\nMany transactions can be rolled into a single statement, which is why `statementDate` may be different than `transactionDate`.\n',
    )
    totalCheckAmount: MonetaryAmount | None = Field(
        None,
        description='The sum total of all transactions included on the commissions statement that this commission transaction is part of.',
    )
    comment: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A field to store additional information needed to explain something about the individual commissions transaction. The carrier can choose how they would like to delineate between this field and `description`.',
        example='Bonus for 2023 Quarters 1 & 2.',
    )
    description: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A second field to store additional information needed to explain something about the individual commissions transaction. The carrier can choose how they would like to delineate between this field and `comment`.',
        example='Override on policies between 1/1/2022 - 3/31/2022.',
    )
    reasonForCommission: ReasonForCommission | None = Field(
        None,
        description='The basis or reason why this commission came to exist (i.e. the way in which the commission was calculated). Sometimes referred to as "commission type". \n \n For example, if the commission is calculated from a rider\'s premium, the value of this field is "Rider".\n',
        example='Base',
    )
    transactionType: TransactionType | None = Field(
        None,
        description='The method of exchange taking place between the agent and the insurance company involved in this commission transaction.\n\n```Credit```, ```Manual Activity```, ```Premium Payment``` and ```Trails``` are transaction types where the insurance company transfers money to the agent. These transactions have a positive `amount` value.\n\n```ChargeBack``` , ```Clawback```, and ```Debits``` are ways in which the insurance company reclaims money from the agent. These transactions have a negative `amount` value.\n',
        example='Credit',
    )
    transactionDate: DateTime | None = Field(
        None,
        description='The date on which the carrier recorded this commission transaction in their system of record. \n \n This date may be different from the `processedDate`, which is when the payee receives (or, for a negative `amount`, is requested to pay) the money exchanged in this commission transaction.\n',
    )
    processedDate: DateTime | None = Field(
        None,
        description="The date on which the carrier gathers together, processes, and generates statement(s) for the group of transactions that this transaction is part of. \n \nThis date may be different than the `transactionDate` because the carrier may not pay the agent on the same day that the commission is recorded in the carrier's system of record.\n",
    )
    amount: MonetaryAmount | None = Field(
        None,
        description='The total amount of money the `payee` receives for this commission transaction (as opposed to the `totalCheckAmount` on the statement). \nThis dollar amount is usually positive, but can be negative (e.g. for clawbacks or charge backs).',
    )
    percentageSplit: NonNegativePercent | None = Field(
        None,
        description='The portion of the overall commission `amount` that the `payee` receives, as a percentage. \nFor example, if the `payee` on this commission transaction receives 40% of the commission, this value will be 40.\nIf there is only one writing agent on the case, this value is 100.',
    )
    payee: Person | Company | None = Field(
        None, description='The agent or company who is getting paid on this commission.'
    )
    writingAgent: Person | None = Field(
        None,
        description='The original writing agent on the case associated with this commission.',
    )
    client: Person | None = Field(
        None, description='The client of the policy associated with this commission.'
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the insurance company that is involved in this commission transaction.',
        example='Carrier Name',
    )
    isFirstYear: bool | None = Field(
        None,
        description='True indicates that this is a first-year commission (i.e. this commission transaction is taking place during the first year of policy). \nFalse indicates that this commission transaction is for a renewal year.',
        example=False,
    )
    premiumAmount: MonetaryAmount | None = Field(
        None,
        description='The amount of money paid in the premium that was used to calculate this commission (i.e. the same premium that was used to determine the `commissionType`).',
    )
    premiumDueDate: DateTime | None = Field(
        None,
        description='The due date for the premium which this commission transaction is based on.',
    )
    monthsPaidFor: float | None = Field(
        None,
        description='The number of months that the `premiumAmount` pays for. \n\n  This value may not align with the `mode`. For example, the policy may be a monthly mode but the insured\nmay have made 2 monthly payments combined into a single transaction. In this case, the `mode` would be monthly but the `monthsPaidAmount` would represent two months worth of premium money.',
        example=2,
    )
    mode: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The frequency at which the policyowner is be expected to pay the premium on the policy associated with this commission statement (e.g. Monthly, Quarterly, Semi-annually, or Annually).',
        example='Monthly',
    )
    rateToBePaid: NonNegativePercent | None = Field(
        None, description='The percentage used to calculate the commission `amount`.'
    )
    paidThroughDate: DateTime | None = Field(
        None,
        description='The date through which the policy is paid for (i.e. the date on which a new premium will be due).',
    )
    firstYearCommissionAmount: MonetaryAmount | None = Field(
        None,
        description='The portion of this commission transaction `amount` that can be attributed to first year commission.',
    )
    renewalCommissionAmount: MonetaryAmount | None = Field(
        None,
        description='The portion of this commission transaction `amount` that can be attributed to a renewal year commission. This value is often much less than the `firstYearCommissionAmount`.',
    )
    trailCommissionAmount: MonetaryAmount | None = Field(
        None,
        description='The portion of this commission transaction `amount` that can be attributed to trail commissions.',
    )
    feesApplied: MonetaryAmount | None = Field(
        None,
        description='The non-commissionable fees that are removed from the overall commission before paying the `payee`.',
    )
    uplineRate: NonNegativePercent | None = Field(
        None,
        description='The percentage used to calculate the money paid to an agent or agency that is "upline" from the `payee` (i.e. the person above the `payee` in an agent hierarchy). May also known as an "override" percentage. \nThis rate may be a percentage of a premium, of the `payee`\'s commission, or of something else.',
    )
    uplineCommission: MonetaryAmount | None = Field(
        None,
        description='The amount of money paid to an agent or agency that is "upline" from the `payee` (i.e. the person above the `payee` in an agent hierarchy). May also known as an "override" amount.',
    )
    totalPaidCommission: MonetaryAmount | None = Field(
        None,
        description='A running total for the amount of money paid in commissions to the `payee` associated with this transaction, over the lifetime of a the policy this transaction is associated with.',
    )
    totalYTDCommissionPaid: MonetaryAmount | None = Field(
        None,
        description='The total year-to-date commission paid to the agent receiving this statement.',
    )
    totalYTDFirstYearCommissionPaid: MonetaryAmount | None = Field(
        None,
        description='A running total for the amount of money made in commissions for this `payee` since the beginning of the year, during the first year of the policy this transaction is associated with.',
    )
    totalYTDRenewalCommissionPaid: MonetaryAmount | None = Field(
        None,
        description='A running total for the amount of money made in commissions for this `payee` since the beginning of the year, during a renewal year (i.e. any year besides the first year of the policy).',
    )
    policySnapshot: Annuity | Life | None = Field(
        None,
        description='A snapshot of the policy associated with the commission transaction.',
    )
    status: str | None = Field(
        None, description='The status of the commission transaction', example='Pending'
    )


class CommissionStatement(BaseModel):
    class Config:
        extra = Extra.forbid

    documentID: ID | None = Field(
        None, description='A unique identifier for the PDF version of this statement.'
    )
    date: DateTime | None = Field(
        None, description='The date that the statement was issued.'
    )
    payee: Person | Company | None = Field(
        None,
        description='The person or company receiving (for a positive `amount`) or requested to pay (for a negative `amount`) the money accounted for in this commission statement.\n',
    )
    amount: MonetaryAmount | None = Field(
        None,
        description="The total amount of money that is either deposited into the `payee`'s bank account (in the case of a positive value) or requested from the `payee` (in the case of a negative value) as a result of this commission statement.",
    )


class BaseTrust(BaseModel):
    class Config:
        extra = Extra.allow

    name: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The legal name of the trust.', example='SureCo'
    )
    establishedDate: DateTime | None = Field(
        None,
        description='The date that the trust came into existence as a legally recognized entity.',
    )
    addresses: list[Address] | None = Field(
        None,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )
    governmentIDNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A government-issued identification number used for taxation and/or or legal identification purposes (e.g. social security number).',
        example='365-86-8526',
    )
    isIrrevocable: bool | None = Field(
        None,
        description='True indicates that this trust cannot be modified after it is created without the explicit consent of its beneficiaries.',
    )
    state: State | None = None


class Type5(Enum):
    Trust = 'Trust'


class Trust(BaseTrust):
    ID: ID | None = Field(None, description='A unique identifier for this contact.')
    type: Type5 | None = None
    trusteeIDs: list[ID] | None = Field(
        None,
        description='A collection of the full contact records for the people and/or organizations legally responsible for managing the trust and its assets.',
        max_items=32768,
        min_items=0,
    )
    grantorContactID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the individual or legal entity (such as a company or organization) that establishes the trust and transfers assets into it. The grantor defines the terms under which the trust operates.',
    )
    finalBeneficiaryContactID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the individual or legal entity (such as a company, nonprofit, or organization) that ultimately receives the remaining assets of the trust once all trust obligations are fulfilled.',
    )


class BaseEstate(BaseModel):
    name: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The legal name of the estate.', example='Estate of John Doe'
    )
    executorContactID: ID | None = Field(
        None,
        description="A pointer to the full contact record of the executor who is designated to manage the estate after the policyowner's passing",
    )
    governmentIDNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A government-issued identification number used for taxation and/or or legal identification purposes (e.g. tax identification number).',
        example='12-3456789',
    )
    addresses: list[Address] | None = Field(
        None,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )


class Type6(Enum):
    Estate = 'Estate'


class Estate(BaseEstate):
    ID: ID | None = Field(None, description='A unique identifier for this contact.')
    type: Type6 | None = None


class BaseCharity(BaseModel):
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The legal name of the charity.',
        example='Helping Hands Foundation',
    )
    addresses: list[Address] | None = Field(
        None,
        description='A collection of addresses for this charity.',
        max_items=32768,
        min_items=0,
    )
    isGovernedByBoardOfDirectors: bool | None = Field(
        None,
        description="True indicates that this charity is being governed by a board of directors (a group of individuals) who are responsible for overseeing the charity's operations, ensuring compliance with legal requirements, and making strategic decisions.",
    )


class Type7(Enum):
    Charity = 'Charity'


class Charity(BaseCharity):
    ID: ID | None = Field(None, description='A unique identifier for this contact.')
    type: Type7 | None = None


class Document(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID = Field(..., description='A unique identifier for the document.')
    title: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A short phrase explaining the purpose of the document, or what the document is used for.',
    )
    documentNumber: str | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify the given document.',
        example='20LAS',
    )
    categoryIDs: list[Any] | None = Field(
        None,
        description='A collection of unique identifiers for the categories to which this document belongs to.',
        example=['4b33ae9e-827a-479d-b60c-8daa2873c08c'],
        max_items=32768,
        min_items=0,
    )
    filename: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the file as seen by the user, should they download the file. Includes a file extension.',
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the insurance carrier that supplies this document (may be a subsidiary within a larger carrier).',
    )
    carrierLastUpdated: DateTime | None = Field(
        None,
        description='The timestamp indicating when the document was last updated by the carrier.',
    )
    states: list[State] | None = Field(
        None,
        description='The states in which this document is applicable, valid, registered, etc.',
        example=['CA', 'AK'],
        max_items=255,
        min_items=0,
    )
    versionID: ID | None = Field(
        None, description='A unique identifier for a given form version .'
    )
    isOrderable: bool | None = Field(
        None,
        description='True indicates that the user can order the hard copy of the document.',
    )
    isArchived: bool | None = Field(
        None,
        description='True indicates that the document is archived. False indicates active.',
    )
    editionDate: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The month and year this edition of the document was published.',
        example='05/24',
    )


class DocumentCategory(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID = Field(
        ...,
        description='A unique identifier for the category to which this document belongs to.',
    )
    parentID: ID | None = Field(
        None,
        description='A unique identifier for the parent category of this category (i.e. the category that this category is nested beneath).',
    )
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the category a document belongs to. This can be a high level category or a sub-category.',
        example='Policy Service Forms',
    )
    description: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A short phrase explaining the purpose of the document category, or what the category is used for.',
    )


class FinancialActivity(BaseModel):
    class Config:
        extra = Extra.forbid

    date: DateTime | None = Field(
        None, description='The date on which this financial activity occurred.'
    )
    rate: Percent | None = Field(
        None,
        description='The rate that changed on the `date` of this  activity. \n\nThis field is only applicable if this financial activity is for a rate change. Examples include, but are not limited to: interest rates.\n',
        example=0.0345,
    )
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the activity (i.e. shorthand to explain why a value on the policy changed). \n\n Examples include, but are not limited to: Initial premium, EFT premium, Feature change, Guaranteed minimum interest rate, etc.).\n',
    )
    amount: MonetaryAmount | None = Field(
        None,
        description='The monetary value change that occurred on the `date` of this  activity. \n\nThis field stores the actual monetary value change for any activity that is NOT a rate change. Examples of financial activities resulting in `amount` changes include, but are not limited to: loan repayments, annual fees, premium payments, etc. \n\nNote: When the financial activity is a premium payment, the value of `amount` is the equal to the value of `premiumAmount`.\n',
    )
    grossAmount: MonetaryAmount | None = Field(
        None,
        description='The total `amount` for the activity _before_ the removal of any deductions, fees etc.\n',
    )
    netAmount: MonetaryAmount | None = Field(
        None,
        description='The total `amount` _after_ the removal of any deductions, fees, etc.\n',
    )
    premium: MonetaryAmount | None = Field(
        None,
        description='The amount of money being paid as premium on the policy, on the `date` of this financial activity. \n\n Note: this field does NOT represent the monetary value change for this financial activity -- that value is stored in the `amount` field. However, when the financial activity is a premium payment, the value of this field is equal to the value of `amount`.\n',
    )
    mode: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The frequency at which the policyowner pays the `premium` on the policy (e.g. monthly, quarterly, semi-annually, etc.).\n',
        example='Monthly',
    )
    policyID: ID | None = Field(
        None,
        description='A pointer to the case and/or policy that this financial activity is associated with.',
    )
    paymentMethodID: ID | None = Field(
        None,
        description='A pointer to the payment method that this financial activity is associated with.',
    )
    status: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The payment status of the transaction. Examples include, but are not limited to paid, success, failed, processing.',
        example='processing',
    )


class FundAllocation(BaseModel):
    class Config:
        extra = Extra.forbid

    policyID: ID | None = Field(
        None,
        description='A pointer to the case and/or policy that the funds are associated with.',
    )
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the fund (i.e. the name used when marketing the fund).',
        example='S&P 500',
    )
    disclaimer: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The legalese that accompanies a given fund, meant to protect the business entity administering the\nfund against any unwanted claims or liability.\n',
        example='These are products of S&P Dow Jones Indices, LLC, a division of S&P Global, or its affiliates ("SPDJI") and has been licensed for use by SureCo. Standard & Poor\'s and S&P are registered trademarks of Standard & Poor\'s Financial Services LLC, a division of S&P Global ("S&P"); Dow Jones is a registered trademark of Dow Jones Trademark Holdings LLC ("Dow Jones")',
    )
    amount: NonNegativeMonetaryAmount | None = Field(
        None, description='The total amount of money tied to an individual fund.'
    )
    allocationPercent: NonNegativePercent | None = Field(
        None,
        description='The percentage of new money being paid into the policy that should be invested in this fund, NOT a historical purchasing percentage.\n',
    )
    allocationDate: DateTime | None = Field(
        None,
        description="The date on which the amount of money allocated to this fund was last updated in the carrier's system of record.",
    )
    rate: Percent | None = Field(
        None,
        description='The interest rate of the fund during the time period covered by the crediting strategy.',
    )
    rateDate: DateTime | None = Field(
        None,
        description="The date on which the rate of this fund was last updated in the carrier's system of record.",
    )


class Capability(BaseModel):
    __root__: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A capability that this user is authorized to.',
        example='Policy',
    )


class OwnerType(Enum):
    person = 'person'
    agent = 'agent'
    company = 'company'
    carrier = 'carrier'


class Keycard(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID | None = Field(None, description='A unique identifier for this keycard.')
    contactID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the person or organization to which this keycard is assigned.',
    )
    keycardNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify this keycard.',
    )
    name: Name | None = Field(
        None,
        description='The name of the person or organization to which this keycard is assigned. For organizations, use the `fullName` option.',
    )
    ownerType: OwnerType | None = Field(
        None, description='The type of the keycard owner.', example='company'
    )
    capabilities: list[Capability] | None = Field(
        None,
        description='A collection of permissions that this keycard is authorized to.',
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The carrier that the keycard is affiliated with.',
        example='SureCo',
    )


class Author(BaseModel):
    class Config:
        extra = Extra.forbid

    name: Name | None = Field(None, description='The name of the author.')
    contactID: ID | None = Field(
        None, description='A pointer to the full contact record for the author.'
    )


class Note(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID | None = Field(None, description='A unique identifier for the note.')
    policyID: ID | None = Field(
        None,
        description='A pointer to the case and/or policy that this note is associated with.',
    )
    author: Author | None = Field(
        None,
        description='The person who wrote the note `content` and attached the `Note` to the case or policy.',
    )
    noteAddedDate: DateTime | None = Field(
        None,
        description='The date or timestamp when the `Note` was written or modified.\n',
    )
    title: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A brief description of the `Note`.',
        example='Client signature required',
    )
    content: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The text that makes up the body of the `Note`.',
        example='This application was received via paper and was missing signatures.  It has been returned for completion.',
    )
    isPrivate: bool | None = Field(
        None, description='True indicates that this note is only visible to the author.'
    )
    isEditable: bool | None = Field(
        None,
        description='True indicates that this note was created in a client built against the CoreCONNECT platform, such as a web application (e.g. LifetimeSERVICE or LifetimeAGENT), mobile application, etc.',
    )


class CreditCard(BaseModel):
    processingNetwork: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The name of the company responsible for processing any transactions that are made with this credit or debit card (e.g. Visa, Mastercard, American Express, etc.)',
        example='Visa',
    )
    cardNumber: constr(min_length=1, max_length=19) | None = Field(
        None,
        description='A masked version of the credit or debit card number. Used to identify the card.',
        example='****-****-****-1234',
    )
    expirationDate: DateTime | None = Field(
        None,
        description='The day on which this credit/debit card can no longer be used.',
    )
    accountHolderName: Name | None = Field(
        None,
        description='The name of the person or organization who owns this credit/debit card. If this credit/debit card belongs to an organization, use the `fullName` option.',
    )
    address: Address | None = Field(
        None,
        description='The address that is used for billing with this credit/debit card.',
    )


class BankAccountNumber(BaseModel):
    __root__: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The account number for a bank account.',
        example='6541-5421-1564-8157',
    )


class Type8(Enum):
    checking = 'checking'
    savings = 'savings'


class BankAccount(BaseModel):
    class Config:
        extra = Extra.forbid

    accountHolderName: Name | None = Field(
        None,
        description='The name of the person or organization to whom this bank account or check belongs. If this bank account belongs to an organization, use the `fullName` option.',
    )
    bankName: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The name of the bank where the bank account is held.'
    )
    type: Type8 | None = Field(
        None, description='The kind of bank account this is (i.e. checking or savings).'
    )
    accountNumber: BankAccountNumber | None = Field(
        None, description='A masked bank account number.', example='***9054'
    )
    routingNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The routing number for this bank account.',
        example='082000073',
    )


class AmountOption(Enum):
    Custom = 'Custom'
    Minimum = 'Minimum'
    Balance = 'Balance'


class AutopaySetup(BaseModel):
    class Config:
        extra = Extra.forbid

    dayOfMonth: conint(ge=1, le=31) | None = Field(
        None,
        description='The day of the month on which each automatically recurring payment is processed.',
    )
    amountOption: AmountOption | None = Field(
        None,
        description='The automatic payment option chosen by the payer. Dictates how much money is sent in each automatically recurring payment.\n | Enum | Amount of money sent in each payment |\n |--------------------------|----------------------------|\n | `custom` | An arbitrary amount (set by the payer) |\n | `minimum` | The lowest possible amount required to keep the account in good standing |\n | `balance`  | The amount owed at the time of payment |\n',
    )
    amount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money sent in each automatically recurring payment. This field is only used when the payer has `amountOption` set to  `custom`.',
    )


class PaymentMethod1(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID = Field(..., description='A unique identifier for this payment method.')
    paymentForm: str | None = Field(
        None,
        description="different types of payment forms.\n'creditcard' - a credit card payment form.\n",
    )
    isDefault: bool | None = Field(
        None,
        description='True indicates that this payment method is automatically used for a given policy, unless issues arise, or unless the payor specifies an alternative payment method to be used for a particular transaction.\n',
    )
    policyID: ID | None = Field(
        None,
        description='A pointer to the case and/or policy that this payment method is associated with.',
    )
    effectiveDate: DateTime | None = Field(
        None,
        description='The first day that this payment method is (allowed to be) used.\n',
    )
    endDate: DateTime | None = Field(
        None,
        description='The last day that this payment method is (allowed to be) used. \nDo not provide a value for this field if this payment method is expected to be used indefinitely.',
    )
    formOfPayment: CreditCard | BankAccount | None = Field(
        None,
        description='The credit/debit or bank account information needed to process a payment with this payment method.\n',
    )
    autopaySetup: AutopaySetup | None = Field(
        None,
        description='The information needed to set up automatically recurring payments. \nMissing values indicate that automatically recurring payments are not enabled for this payment method.',
    )


class License(BaseModel):
    class Config:
        extra = Extra.forbid

    agentID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the agent to whom this license belongs.',
    )
    status: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The current status this license, in relation to its legal validity (e.g. current, pending, or expired).',
        example='pending',
    )
    isResidentialLicense: bool | None = Field(
        None,
        description="True indicates that this is an agent's residential license (i.e. the one that allows the agent to sell insurance in the state where they live).",
    )
    licenseNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The state-assigned license number (i.e. a combination of letters and numbers that the state government uses to uniquely identify the license).',
    )
    effectiveDate: DateTime | None = Field(
        None, description='The date on which the license was issued.'
    )
    expirationDate: DateTime | None = Field(
        None, description='The date on which the license expires.'
    )
    state: State | None = Field(
        None, description='The state for which the license was issued.'
    )


class Status(Enum):
    Open = 'Open'
    Application_Received = 'Application Received'
    Closed = 'Closed'


class ProposedClient(Person):
    class Config:
        extra = Extra.allow

    age: Duration | None = Field(
        None,
        description='The age of the `proposedClient` at the time that the quote/illustration was run. \n\nThis value is less precise than `DOB` (date of birth). Generally, a quote has either the `currentClientAge` or `DOB` but not both.\n',
    )
    heightInInches: confloat(ge=0.0) | None = Field(
        None, description="The `proposedClient`'s height in inches.", example=70.5
    )
    weightInPounds: confloat(ge=0.0) | None = Field(
        None, description="The `proposedClient`'s weight in pounds.", example=195.5
    )


class QuoteIllustrationBase(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID | None = Field(
        None, description='A unique identifier for this quote or illustration.'
    )
    runDate: DateTime | None = Field(
        None,
        description='The date on which this quote or illustration was run (i.e. calculated by the quote/illustration preparation system).',
    )
    documentID: ID | None = Field(
        None,
        description='A pointer to the document version of this quote or illustration.',
    )
    status: Status | None = Field(
        None,
        description='The current status of this quote or illustration. \n    \nIndicates how far along this quote/illustration is in the process of becoming a case.\n',
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The insurance company that ran this quote or illustration.\n',
        example='SureLife',
    )
    agentID: ID | None = Field(
        None,
        description='A pointer to the unique identifier for the agent who is selling the product featured in this quote or illustration.',
    )
    productID: ID | None = Field(
        None,
        description='A pointer to the unique identifier for the product requested in this quote or illustration.',
    )
    caseID: ID | None = Field(
        None,
        description='A pointer to the case that this quote or illustration is a precursor to, should the quote/illustration be successfully converted into a case.',
    )
    proposedClient: ProposedClient | None = Field(
        None,
        description='The person for whom this quote/illustration was prepared (i.e. the person requesting insurance coverage).',
    )
    rateClass: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A category indicating the overall health of the `proposedClient` (e.g. Preferred Non Smoker, Preferred Plus, Standard, etc).  Rate class has a direct impact on the price of the life insurance policy.',
        example='Preferred Non Smoker',
    )
    modalPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money the `proposedClient` will pay in premium when they receive their bill, should they select this quote. \n\nThe frequency at which the `proposedClient` will pay the `modalPremium` is called the `paymentMode`.\n',
    )
    paymentMode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The frequency at which the `proposedClient` will be expected to pay the premium on their policy (e.g. Monthly, Quarterly, Semi-annually, or Annually), should they select this quote. \n\nNote: The amount of money payable each time the `proposedClient` receives their bill is the called the `modalPremium`.\n',
        example='Monthly',
    )
    faceAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The quoted amount of money paid out to the beneficiary when the insured dies. Typically used on Term policies (as opposed to Universal Life, Whole Life, or Annuity policies). Sometimes referred to as death benefit.',
    )
    deathBenefit: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The quoted amount of money paid out to the beneficiary when the insured or annuitant dies. Typically used in Whole Life, Universal Life, or Annuities (as opposed to Term Life).\n\n`deathBenefit` may differ from `faceAmount` in that `deathBenefit` may change over time, while `faceAmount` stays the same over the lifetime of a policy. The value of `deathBenefit` often changes because adjustments (e.g. the accrual of interest) are made to it over the lifetime of the policy.\n',
    )


class Requirement(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID | None = Field(None, description='A unique identifier for this requirement.')
    caseID: ID | None = Field(
        None,
        description='A pointer to the case that this requirement is associated with.',
    )
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the requirement (i.e. the task that must be completed).\n',
    )
    comment: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The additional information needed to understand or appropriately complete the requirement.\n\nFor example, if the requirement is a Blood Test, the `comment` may say,  Must fast for 12 hours before this blood test.\n',
    )
    responsibleParty: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The individual or entity responsible for the completion of the task specified in this requirement. \nFor example, if the requirement is related to and issue with missing or inaccurate licensing information, the `responsibleParty` is the agent that has must provide accurate license information to the carrier.',
        example='agent',
    )
    requestedDate: DateTime | None = Field(
        None,
        description='The date on which the carrier sent out a notification requesting that this requirement be completed.',
    )
    scheduledDate: DateTime | None = Field(
        None,
        description='The date on which the task requested by the carrier is scheduled to be completed. \nFor example, if the requirement is a medical examination request,\nthe `scheduledDate` is the date of the insureds doctors appointment.\n',
    )
    receivedDate: DateTime | None = Field(
        None,
        description='The date on which the carrier receives evidence that the requirement has been completed.',
    )
    status: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The current status of the requirement (i.e. where the task is  on its journey towards completion). \n\nExamples include, but are not limited to: pending, scheduled, received, outstanding\n',
        example='pending',
    )
    statusDate: DateTime | None = Field(
        None,
        description='The date on which the `status` of this requirement was last updated by the carrier.',
    )
    blankFormID: ID | None = Field(
        None,
        description='A pointer to the blank copy of the form or questionnaire that must be filled out in order to fulfill this requirement.',
    )
    documentIDs: list[ID] | None = Field(
        None,
        description='A collection pointers to completed documents that are related to this requirement (e.g. filled-out questionnaires, medical records, etc.).',
        max_items=32768,
        min_items=0,
    )
    category: constr(min_length=1, max_length=32768) | None = Field(
        None,
        description='A category that is used to group requirements by how or when they are needed during the application process (e.g. Obtain At Delivery, Needed for Underwriting).',
    )


class Rider(BaseModel):
    name: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The name of the rider (e.g. Child Term Rider, Waiver of Premium, etc.).',
        example='Term Conversion Rider',
    )
    riderValue: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money that the rider is worth (as additional benefit). \n \n The `riderValue` can be different than the `faceAmount` of the base policy the rider is tied to.',
    )
    modalPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money the policyowner pays for the rider each time premium is due (at a frequency set by the `premiumMode`). `modalPremium` is only applicable for premium that is paid separately from the base policy premium. \n \n Note: this value is NOT applicable to inherent riders (i.e. riders that are include as part of the base policy).\n',
    )
    premiumMode: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The frequency at which the rider `modalPremium` is paid (e.g. Monthly, Quarterly, Annually, etc.). \n\nNote: this value is NOT applicable to inherent riders (i.e. riders that are included as part of the base policy).\n',
        example='Monthly',
    )
    annualPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money that the policyowner pays in premium for the rider over the course of a year.',
    )
    status: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The current status of the rider. Examples include, but are not limited to: Cancelled, Active, Exercised, Inactive.\n\nThe status of a rider can be different from the status of the policy that it is attached to.\n',
        example='Active',
    )
    statusDate: DateTime | None = Field(
        None,
        description="The date on which the carrier most recently updated the rider's `status`.",
    )
    termConversionDate: DateTime | None = Field(
        None,
        description='The last day to convert a term rider into a permanent rider. Often referred to as the term conversion expiration date.',
    )
    eligibilityDate: DateTime | None = Field(
        None,
        description='The date on which when the rider is eligible to be exercised by the insured (i.e. when the insured can begin taking advantage of the additional coverage or benefits that the rider provides).',
    )
    policyID: ID = Field(
        ...,
        description='A pointer to the case and/or policy that this rider is tied to.\n',
    )
    contactIDs: list[ID] | None = Field(
        None,
        description='A collection of IDs for the full contact records for the people related to the rider.',
        max_items=32768,
        min_items=0,
    )


class PartyType(Enum):
    Agency = 'Agency'
    Carrier = 'Carrier'
    Producer = 'Producer'
    ConsumerPerson = 'ConsumerPerson'


class BoundParty(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(
        None, description='A pointer to the full contact record of this bound party.'
    )
    partyNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify this bound party.',
    )
    name: Name | None = Field(
        None,
        description='The name of the individual or organization this bound party belongs to. For organizations, use the `fullName` option.',
    )
    partyType: PartyType | None = Field(
        None,
        description='The type of individual or organization this bound party represents.',
        example='Agency',
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The carrier that this bound party is affiliated with.',
        example='SureCo',
    )


class User(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(None, description='A unique identifier for this user.')
    profilePartyID: ID | None = Field(
        None,
        description="A pointer to the full contact record containing information for this user's profile.",
    )
    name: Name | None = Field(
        None,
        description='The name of this user. For organizations, use the `fullName` option.',
    )


class LinkedParty(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(
        None, description='A pointer to the full contact record of this linked party.'
    )
    partyNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify this linked party.',
    )
    name: Name | None = Field(
        None,
        description='The name of the individual or organization this linked party represents.',
    )
    partyType: PartyType | None = Field(
        None,
        description='The type of individual or organization this linked party represents.',
        example='Agency',
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The carrier that this linked party is affiliated with.',
        example='SureCo',
    )


class CaseSearchFields(Enum):
    ID = 'ID'
    caseNumber = 'caseNumber'
    accountNumber = 'accountNumber'
    status = 'status'
    productType = 'productType'
    productSubtype = 'productSubtype'
    product = 'product'
    paymentMode = 'paymentMode'
    carrierLastUpdated = 'carrierLastUpdated'
    effectiveDate = 'effectiveDate'
    faceAmount = 'faceAmount'
    modalPremium = 'modalPremium'
    annualizedPremium = 'annualizedPremium'
    costOfInsurance = 'costOfInsurance'
    commissionableAnnualizedPremium = 'commissionableAnnualizedPremium'
    deathBenefit = 'deathBenefit'
    client = 'client'
    agent = 'agent'
    agency = 'agency'
    riskClass = 'riskClass'
    carrier = 'carrier'
    statusCategory = 'statusCategory'
    dateCashReceived = 'dateCashReceived'
    cashReceived = 'cashReceived'
    isNIGO = 'isNIGO'


class PolicySearchFields(Enum):
    ID = 'ID'
    policyNumber = 'policyNumber'
    accountNumber = 'accountNumber'
    status = 'status'
    productType = 'productType'
    productSubtype = 'productSubtype'
    product = 'product'
    paymentMode = 'paymentMode'
    carrierLastUpdated = 'carrierLastUpdated'
    effectiveDate = 'effectiveDate'
    faceAmount = 'faceAmount'
    modalPremium = 'modalPremium'
    annualizedPremium = 'annualizedPremium'
    costOfInsurance = 'costOfInsurance'
    commissionableAnnualizedPremium = 'commissionableAnnualizedPremium'
    deathBenefit = 'deathBenefit'
    client = 'client'
    agent = 'agent'
    agency = 'agency'
    riskClass = 'riskClass'
    carrier = 'carrier'
    annuityValue = 'annuityValue'
    qualificationType = 'qualificationType'


class GlobalSearchFields(BaseModel):
    __root__: CaseSearchFields | PolicySearchFields


class Operator(Enum):
    empty = 'empty'
    notEmpty = 'notEmpty'


class ValueExistenceFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ...,
        description='The name of the field that the user chooses to filter against.\n',
    )
    operator: Operator = Field(
        ...,
        description='A logical operator to return records based on whether _any value exists_ in a user-specified field.\n\nFor example, the `empty` operator can be used to search for all records that do not have _any value_ in the `policyNumber` field .\n',
    )


class Operator1(Enum):
    startsWith = 'startsWith'
    endsWith = 'endsWith'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class StringComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ...,
        description='The name of the string field the user chooses to filter against.',
    )
    operator: Operator1 = Field(
        ...,
        description='A logical operator used to perform string comparison.\n\nFor example, the `contains` operator can be used to search for all records where the string "Abc123" appears somewhere within the `policyNumber` field.\n',
    )
    value: constr(min_length=1, max_length=32767) = Field(
        ..., description='The user-specified string to used to create the filter.'
    )


class Operator2(Enum):
    gt = 'gt'
    gte = 'gte'
    lt = 'lt'
    lte = 'lte'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class NumericComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ...,
        description='The name of the numeric field the user chooses to filter against.\n',
    )
    operator: Operator2 = Field(
        ...,
        description='A logical operator used to perform numeric comparison.\n\n  For example, the `lte` operator can be used to search for all records that have a value less than or equal to 10,000 the `policyNumber` field.\n',
    )
    value: float = Field(
        ..., description='The user-specified number used to create the filter.'
    )


class Operator3(Enum):
    after = 'after'
    before = 'before'
    onOrAfter = 'onOrAfter'
    onOrBefore = 'onOrBefore'


class DateComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ...,
        description='The name of the date field the user chooses to filter against.',
    )
    operator: Operator3 = Field(
        ...,
        description='A logical operator used for date comparison.\n\nFor example, the `before` operator can be used to search for all records that have date prior to Dec 31, 2000 in the `effectiveDate` field.\n',
    )
    value: constr(min_length=4, max_length=30) = Field(
        ...,
        description='The user-specified Date or DateTime value to create the filter in ISO 8601 format __without timezone__.\n\n**For Date-only filtering** (Properties that represent only a date, without a time component):\n- Format: \'YYYY-MM-DD\' (e.g., `2024-01-15`)\n- Compares only the date portion (year, month, day)\n- Ignores time component.\n\n**For DateTime filtering** (Properties that represent both a date and time):\n- Format: ISO 8601 string (e.g., `"2024-01-15T10:30:00.000"`)\n- Provides millisecond-precision filtering\n- Enables precise timestamp without timezone comparison.\n\nThe system automatically detects the format and applies the appropriate comparison logic.\n',
        example='2024-01-15',
    )


class Operator4(Enum):
    in_ = 'in'
    notIn = 'notIn'


class ListMembershipFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ..., description='The name of the field the user chooses to filter against.'
    )
    operator: Operator4 = Field(
        ...,
        description='A logical operator to check for membership within a collection of values.\n\nFor example, the `in` operator can be used to search for all records that have data in the `policyNumber` field that matches at least one of the `values` specified by the user.\n',
    )
    values: list[str | float] = Field(
        ...,
        description='The collection of user-specified values used to create the filter.\n\nFor example, if the user specifies 30 different policy numbers as different `values`, the filter will return only records with data in the`policyNumber` field that matches at least one of those 30 policy numbers.\n',
        max_items=32767,
        min_items=1,
    )


class Operator5(Enum):
    between = 'between'
    notBetween = 'notBetween'


class RangeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ..., description='The name of the field to compare the filter range against.'
    )
    operator: Operator5 = Field(
        ...,
        description='A logical operator user to check for whether records include a value within the user-specified range.\n\nFor example, the `between` operator can be used to search for all records that have a value in the `effectiveDate` field between `2024-01-31` and `2025-01-31`.\n',
    )
    range: list[str | float] = Field(
        ...,
        description='A collection of exactly two user-specified values: one for the upper bound of the range, the other for the lower bound.\n',
        max_items=2,
        min_items=2,
    )


class Operator6(Enum):
    search = 'search'


class SearchType(Enum):
    keyword = 'keyword'
    phrase = 'phrase'


class SearchFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ...,
        description='The name of the field the user chooses to filter against. Users may assign each field an optional `boost` value to rank the importance of that field in the search results.',
    )
    operator: Operator6 = Field(..., description='TODO...')
    term: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The text that is matched against field values during the search. The search term may consist of a single word or multiple words',
        example='John Doe',
    )
    searchType: SearchType | None = Field(
        'keyword',
        deprecated=True,
        description='The method for matching the search term against field values:\n - `keyword` searches for individual search term words independently from each other.\n - `phrase`  searches for the entire text of the search term together as a contiguous string.\nDeprecated: We automatically detect whether to search by keyword or phrase based on the presence of spaces in the search term.\n',
    )
    boost: float | None = Field(
        1,
        description='A value from 1 to 10 used to rank the importance of a given field relative to other fields during a given search.',
    )


class ResourceTypeEnum(Enum):
    policy = 'policy'
    case = 'case'


class ResourceTypeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    resourceType: list[ResourceTypeEnum] = Field(
        ...,
        description='The kind of record or business object that the user chooses to search for (e.g. the user only wants the search to return records that are Policies).\n',
        max_items=32767,
        min_items=1,
    )


class Operator7(Enum):
    AND = 'AND'
    OR = 'OR'


class CompositeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    operator: Operator7 = Field(
        ..., description='A logical operator used to combine filters.'
    )
    filters: list[
        ValueExistenceFilter
        | StringComparisonFilter
        | NumericComparisonFilter
        | DateComparisonFilter
        | ListMembershipFilter
        | RangeFilter
        | SearchFilter
        | ResourceTypeFilter
    ] = Field(..., max_items=32767, min_items=1)


class BaseAggregation(BaseModel):
    name: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A user-specified name for the aggregation, used to reference it in the response.',
    )
    field: GlobalSearchFields = Field(
        ...,
        description='The name of the field this aggregation is being performed against.',
    )


class NestedAggregation(BaseModel):
    aggregations: list[dict[str, Any]] | None = Field(
        None,
        description='An optional array of nested aggregations to perform within each group of the parent aggregation.\n\nEach nested aggregation follows the same structure as top-level aggregations and must include:\n- `name`: A unique identifier for the aggregation\n- `type`: The aggregation type (terms, dateHistogram, or stats)\n- `field`: The field to aggregate on\n- `aggregations`: (optional) Further nested aggregations for Terms and Date Histogram types\n\nNested aggregations enable multi-dimensional data analysis, allowing you to drill down into your data hierarchically.\n',
    )


class Type9(Enum):
    terms = 'terms'


class TermAggregation(BaseAggregation, NestedAggregation):
    type: Type9 | None = Field(
        None,
        description='The **Terms** aggregation returns the number of records that have a particular value in a given string-field.\n\nFor example, a terms aggregation against the `product` field may show that there are 20 records for Product A and 50 records of Product B.\n\nOnly available for string-based fields.\n',
    )


class Type10(Enum):
    dateHistogram = 'dateHistogram'


class DateInterval(Enum):
    year = 'year'
    month = 'month'
    week = 'week'
    day = 'day'


class DateHistogramAggregation(BaseAggregation, NestedAggregation):
    type: Type10 | None = Field(
        None,
        description='The **Date Histogram** aggregation returns the number of records with a date value falling within a given time period (`dateInterval`). Users can choose whether to group records by year, month, week, or day. \n\nFor example. a Date Histogram against the `effectiveDate` field (with a `dateInterval` of `year`) may show that there are 1000 records with an `effectiveDate` between Jan 28, 1999 and Jan 28, 2000, and 2000 records between Jan 28, 2000 and Jan 28, 2001.\n\nOnly available for date-based fields.\n',
    )
    dateInterval: DateInterval | None = Field(
        None,
        description='A user-chosen duration used to create groups of equal duration in date histogram aggregations.',
    )


class Type11(Enum):
    stats = 'stats'


class StatsAggregation(BaseAggregation):
    type: Type11 | None = Field(
        None,
        description='The **Stats** aggregation returns the maximum value, minimum value, sum of values, and arithmetic mean of values present in a given numeric field, as well as the number of records with values in that field.\n\nFor example. a Stats aggregation against the `modalPremium` field may show that there are 20,000 records with any value in the `modalPremium` field, that the average value is $300, the maximum value is $12,000, the minimum value is $75, and the sum of all values is $6,000,000.\n\nOnly available for number-based fields.\n',
    )


class ResourceType(Enum):
    policy = 'policy'


class PolicySearchResult(BaseModel):
    class Config:
        extra = Extra.allow

    resourceType: ResourceType | None = Field(
        None,
        description='The kind of record or business object the user chose to search for.',
    )
    policy: Annuity | Life | None = Field(
        None, description='A policy that matches the search criteria.'
    )
    roles: list[Insured | Annuitant | Beneficiary | Owner | Agent | Other] | None = (
        Field(None, description='A collection of roles associated with this policy.')
    )
    contacts: list[Person | Company | Trust | Estate | Charity] | None = Field(
        None,
        description='A collection of contact records for people, companies, estates, charities and/or trusts associated with this policy.',
    )


class ResourceType1(Enum):
    case = 'case'


class CaseSearchResult(BaseModel):
    class Config:
        extra = Extra.allow

    resourceType: ResourceType1 | None = Field(
        None,
        description='The kind of record or business object the user chose to search for.',
    )
    case: Case | None = Field(
        None, description='A case that matches the search criteria.'
    )
    roles: list[Insured | Annuitant | Beneficiary | Owner | Agent | Other] | None = (
        Field(None, description='A collection of roles associated with this case.')
    )
    contacts: list[Person | Company | Trust | Estate | Charity] | None = Field(
        None,
        description='A collection of contact records for people, companies, estates, charities and/or trusts associated with this case.',
    )


class SearchResult(BaseModel):
    class Config:
        extra = Extra.allow

    __root__: PolicySearchResult | CaseSearchResult = Field(
        ..., description='A record that matches the search criteria.'
    )


class Operator8(Enum):
    empty = 'empty'
    notEmpty = 'notEmpty'


class SchemasValueExistenceFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ...,
        description='The name of the field that the user chooses to filter against.\n',
    )
    operator: Operator8 = Field(
        ...,
        description='A logical operator to return records based on whether _any value exists_ in a user-specified field.\n\nFor example, the `empty` operator can be used to search for all records that do not have _any value_ in the `policyNumber` field .\n',
    )


class Operator9(Enum):
    startsWith = 'startsWith'
    endsWith = 'endsWith'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class SchemasStringComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ...,
        description='The name of the string field the user chooses to filter against.',
    )
    operator: Operator9 = Field(
        ...,
        description='A logical operator used to perform string comparison.\n\nFor example, the `contains` operator can be used to search for all records where the string "Abc123" appears somewhere within the `policyNumber` field.\n',
    )
    value: constr(min_length=1, max_length=32767) = Field(
        ..., description='The user-specified string to used to create the filter.'
    )


class Operator10(Enum):
    gt = 'gt'
    gte = 'gte'
    lt = 'lt'
    lte = 'lte'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class SchemasNumericComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ...,
        description='The name of the numeric field the user chooses to filter against.\n',
    )
    operator: Operator10 = Field(
        ...,
        description='A logical operator used to perform numeric comparison.\n\n  For example, the `lte` operator can be used to search for all records that have a value less than or equal to 10,000 the `policyNumber` field.\n',
    )
    value: float = Field(
        ..., description='The user-specified number used to create the filter.'
    )


class Operator11(Enum):
    after = 'after'
    before = 'before'
    onOrAfter = 'onOrAfter'
    onOrBefore = 'onOrBefore'


class SchemasDateComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ...,
        description='The name of the date field the user chooses to filter against.',
    )
    operator: Operator11 = Field(
        ...,
        description='A logical operator used for date comparison.\n\nFor example, the `before` operator can be used to search for all records that have date prior to Dec 31, 2000 in the `effectiveDate` field.\n',
    )
    value: constr(min_length=4, max_length=30) = Field(
        ...,
        description='The user-specified Date or DateTime value to create the filter in ISO 8601 format __without timezone__.\n\n**For Date-only filtering** (Properties that represent only a date, without a time component):\n- Format: \'YYYY-MM-DD\' (e.g., `2024-01-15`)\n- Compares only the date portion (year, month, day)\n- Ignores time component.\n\n**For DateTime filtering** (Properties that represent both a date and time):\n- Format: ISO 8601 string (e.g., `"2024-01-15T10:30:00.000"`)\n- Provides millisecond-precision filtering\n- Enables precise timestamp without timezone comparison.\n\nThe system automatically detects the format and applies the appropriate comparison logic.\n',
        example='2024-01-15',
    )


class Operator12(Enum):
    in_ = 'in'
    notIn = 'notIn'


class SchemasListMembershipFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ..., description='The name of the field the user chooses to filter against.'
    )
    operator: Operator12 = Field(
        ...,
        description='A logical operator to check for membership within a collection of values.\n\nFor example, the `in` operator can be used to search for all records that have data in the `policyNumber` field that matches at least one of the `values` specified by the user.\n',
    )
    values: list[str | float] = Field(
        ...,
        description='The collection of user-specified values used to create the filter.\n\nFor example, if the user specifies 30 different policy numbers as different `values`, the filter will return only records with data in the`policyNumber` field that matches at least one of those 30 policy numbers.\n',
        max_items=32767,
        min_items=1,
    )


class Operator13(Enum):
    between = 'between'
    notBetween = 'notBetween'


class SchemasRangeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ..., description='The name of the field to compare the filter range against.'
    )
    operator: Operator13 = Field(
        ...,
        description='A logical operator user to check for whether records include a value within the user-specified range.\n\nFor example, the `between` operator can be used to search for all records that have a value in the `effectiveDate` field between `2024-01-31` and `2025-01-31`.\n',
    )
    range: list[str | float] = Field(
        ...,
        description='A collection of exactly two user-specified values: one for the upper bound of the range, the other for the lower bound.\n',
        max_items=2,
        min_items=2,
    )


class Operator14(Enum):
    search = 'search'


class SchemasSearchFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ...,
        description='The name of the field the user chooses to filter against. Users may assign each field an optional `boost` value to rank the importance of that field in the search results.',
    )
    operator: Operator14 = Field(..., description='TODO...')
    term: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The text that is matched against field values during the search. The search term may consist of a single word or multiple words',
        example='John Doe',
    )
    searchType: SearchType | None = Field(
        'keyword',
        deprecated=True,
        description='The method for matching the search term against field values:\n - `keyword` searches for individual search term words independently from each other.\n - `phrase`  searches for the entire text of the search term together as a contiguous string.\nDeprecated: We automatically detect whether to search by keyword or phrase based on the presence of spaces in the search term.\n',
    )
    boost: float | None = Field(
        1,
        description='A value from 1 to 10 used to rank the importance of a given field relative to other fields during a given search.',
    )


class Operator15(Enum):
    AND = 'AND'
    OR = 'OR'


class SchemasCompositeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    operator: Operator15 = Field(
        ..., description='A logical operator used to combine filters.'
    )
    filters: list[
        SchemasValueExistenceFilter
        | SchemasStringComparisonFilter
        | SchemasNumericComparisonFilter
        | SchemasDateComparisonFilter
        | SchemasListMembershipFilter
        | SchemasRangeFilter
        | SchemasSearchFilter
    ] = Field(..., max_items=32767, min_items=1)


class SchemasBaseAggregation(BaseModel):
    name: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A user-specified name for the aggregation, used to reference it in the response.',
    )
    field: PolicySearchFields = Field(
        ...,
        description='The name of the field this aggregation is being performed against.',
    )


class Type12(Enum):
    terms = 'terms'


class SchemasTermAggregation(SchemasBaseAggregation, NestedAggregation):
    type: Type12 | None = Field(
        None,
        description='The **Terms** aggregation returns the number of records that have a particular value in a given string-field. \n\nFor example, a terms aggregation against the `product` field may show that there are 20 records for Product A and 50 records of Product B.\n\nOnly available for string-based fields.\n',
    )


class Type13(Enum):
    dateHistogram = 'dateHistogram'


class SchemasDateHistogramAggregation(SchemasBaseAggregation, NestedAggregation):
    type: Type13 | None = Field(
        None,
        description='The **Date Histogram** aggregation returns the number of records with a date value falling within a given time period (`dateInterval`). Users can choose whether to group records by year, month, week, or day. \n\nFor example. a Date Histogram against the `effectiveDate` field (with a `dateInterval` of `year`) may show that there are 1000 records with an `effectiveDate` between Jan 28, 1999 and Jan 28, 2000, and 2000 records between Jan 28, 2000 and Jan 28, 2001.\n\nOnly available for date-based fields.\n',
    )
    dateInterval: DateInterval | None = Field(
        None,
        description='A user-chosen duration used to create groups of equal duration in date histogram aggregations.',
    )


class Type14(Enum):
    stats = 'stats'


class SchemasStatsAggregation(SchemasBaseAggregation):
    type: Type14 | None = Field(
        None,
        description='The **Stats** aggregation returns the maximum value, minimum value, sum of values, and arithmetic mean of values present in a given numeric field, as well as the number of records with values in that field.\n\nFor example. a Stats aggregation against the `modalPremium` field may show that there are 20,000 records with any value in the `modalPremium` field, that the average value is $300, the maximum value is $12,000, the minimum value is $75, and the sum of all values is $6,000,000.\n\nOnly available for number-based fields.\n',
    )


class Operator16(Enum):
    empty = 'empty'
    notEmpty = 'notEmpty'


class ComponentsSchemasValueExistenceFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ...,
        description='The name of the field that the user chooses to filter against.\n',
    )
    operator: Operator16 = Field(
        ...,
        description='A logical operator to return records based on whether _any value exists_ in a user-specified field.\n\nFor example, the `empty` operator can be used to search for all records that do not have _any value_ in the `policyNumber` field .\n',
    )


class Operator17(Enum):
    startsWith = 'startsWith'
    endsWith = 'endsWith'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class ComponentsSchemasStringComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ...,
        description='The name of the string field the user chooses to filter against.',
    )
    operator: Operator17 = Field(
        ...,
        description='A logical operator used to perform string comparison.\n\nFor example, the `contains` operator can be used to search for all records where the string "Abc123" appears somewhere within the `policyNumber` field.\n',
    )
    value: constr(min_length=1, max_length=32767) = Field(
        ..., description='The user-specified string to used to create the filter.'
    )


class Operator18(Enum):
    gt = 'gt'
    gte = 'gte'
    lt = 'lt'
    lte = 'lte'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class ComponentsSchemasNumericComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ...,
        description='The name of the numeric field the user chooses to filter against.\n',
    )
    operator: Operator18 = Field(
        ...,
        description='A logical operator used to perform numeric comparison.\n\n  For example, the `lte` operator can be used to search for all records that have a value less than or equal to 10,000 the `policyNumber` field.\n',
    )
    value: float = Field(
        ..., description='The user-specified number used to create the filter.'
    )


class Operator19(Enum):
    after = 'after'
    before = 'before'
    onOrAfter = 'onOrAfter'
    onOrBefore = 'onOrBefore'


class ComponentsSchemasDateComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ...,
        description='The name of the date field the user chooses to filter against.',
    )
    operator: Operator19 = Field(
        ...,
        description='A logical operator used for date comparison.\n\nFor example, the `before` operator can be used to search for all records that have date prior to Dec 31, 2000 in the `effectiveDate` field.\n',
    )
    value: constr(min_length=4, max_length=30) = Field(
        ...,
        description='The user-specified Date or DateTime value to create the filter in ISO 8601 format __without timezone__.\n\n**For Date-only filtering** (Properties that represent only a date, without a time component):\n- Format: \'YYYY-MM-DD\' (e.g., `2024-01-15`)\n- Compares only the date portion (year, month, day)\n- Ignores time component.\n\n**For DateTime filtering** (Properties that represent both a date and time):\n- Format: ISO 8601 string (e.g., `"2024-01-15T10:30:00.000"`)\n- Provides millisecond-precision filtering\n- Enables precise timestamp without timezone comparison.\n\nThe system automatically detects the format and applies the appropriate comparison logic.\n',
        example='2024-01-15',
    )


class Operator20(Enum):
    in_ = 'in'
    notIn = 'notIn'


class ComponentsSchemasListMembershipFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ..., description='The name of the field the user chooses to filter against.'
    )
    operator: Operator20 = Field(
        ...,
        description='A logical operator to check for membership within a collection of values.\n\nFor example, the `in` operator can be used to search for all records that have data in the `policyNumber` field that matches at least one of the `values` specified by the user.\n',
    )
    values: list[str | float] = Field(
        ...,
        description='The collection of user-specified values used to create the filter.\n\nFor example, if the user specifies 30 different policy numbers as different `values`, the filter will return only records with data in the`policyNumber` field that matches at least one of those 30 policy numbers.\n',
        max_items=32767,
        min_items=1,
    )


class Operator21(Enum):
    between = 'between'
    notBetween = 'notBetween'


class ComponentsSchemasRangeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ..., description='The name of the field to compare the filter range against.'
    )
    operator: Operator21 = Field(
        ...,
        description='A logical operator user to check for whether records include a value within the user-specified range.\n\nFor example, the `between` operator can be used to search for all records that have a value in the `effectiveDate` field between `2024-01-31` and `2025-01-31`.\n',
    )
    range: list[str | float] = Field(
        ...,
        description='A collection of exactly two user-specified values: one for the upper bound of the range, the other for the lower bound.\n',
        max_items=2,
        min_items=2,
    )


class Operator22(Enum):
    search = 'search'


class ComponentsSchemasSearchFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ...,
        description='The name of the field the user chooses to filter against. Users may assign each field an optional `boost` value to rank the importance of that field in the search results.',
    )
    operator: Operator22 = Field(..., description='TODO...')
    term: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The text that is matched against field values during the search. The search term may consist of a single word or multiple words',
        example='John Doe',
    )
    searchType: SearchType | None = Field(
        'keyword',
        deprecated=True,
        description='The method for matching the search term against field values:\n - `keyword` searches for individual search term words independently from each other.\n - `phrase`  searches for the entire text of the search term together as a contiguous string.\nDeprecated: We automatically detect whether to search by keyword or phrase based on the presence of spaces in the search term.\n',
    )
    boost: float | None = Field(
        1,
        description='A value from 1 to 10 used to rank the importance of a given field relative to other fields during a given search.',
    )


class Operator23(Enum):
    AND = 'AND'
    OR = 'OR'


class ComponentsSchemasCompositeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    operator: Operator23 = Field(
        ..., description='A logical operator used to combine filters.'
    )
    filters: list[
        ComponentsSchemasValueExistenceFilter
        | ComponentsSchemasStringComparisonFilter
        | ComponentsSchemasNumericComparisonFilter
        | ComponentsSchemasDateComparisonFilter
        | ComponentsSchemasListMembershipFilter
        | ComponentsSchemasRangeFilter
        | ComponentsSchemasSearchFilter
    ] = Field(..., max_items=32767, min_items=1)


class ComponentsSchemasBaseAggregation(BaseModel):
    name: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A user-specified name for the aggregation, used to reference it in the response.',
    )
    field: CaseSearchFields = Field(
        ...,
        description='The name of the field this aggregation is being performed against.',
    )


class Type15(Enum):
    terms = 'terms'


class ComponentsSchemasTermAggregation(
    ComponentsSchemasBaseAggregation, NestedAggregation
):
    type: Type15 | None = Field(
        None,
        description='The **Terms** aggregation returns the number of records that have a particular value in a given string-field. \n\nFor example, a terms aggregation against the `product` field may show that there are 20 records for Product A and 50 records of Product B.\n\nOnly available for string-based fields.\n',
    )


class Type16(Enum):
    dateHistogram = 'dateHistogram'


class ComponentsSchemasDateHistogramAggregation(
    ComponentsSchemasBaseAggregation, NestedAggregation
):
    type: Type16 | None = Field(
        None,
        description='The **Date Histogram** aggregation returns the number of records with a date value falling within a given time period (`dateInterval`). Users can choose whether to group records by year, month, week, or day. \n\nFor example. a Date Histogram against the `effectiveDate` field (with a `dateInterval` of `year`) may show that there are 1000 records with an `effectiveDate` between Jan 28, 1999 and Jan 28, 2000, and 2000 records between Jan 28, 2000 and Jan 28, 2001.\n\nOnly available for date-based fields.\n',
    )
    dateInterval: DateInterval | None = Field(
        None,
        description='A user-chosen duration used to create groups of equal duration in date histogram aggregations.',
    )


class Type17(Enum):
    stats = 'stats'


class ComponentsSchemasStatsAggregation(ComponentsSchemasBaseAggregation):
    type: Type17 | None = Field(
        None,
        description='The **Stats** aggregation returns the maximum value, minimum value, sum of values, and arithmetic mean of values present in a given numeric field, as well as the number of records with values in that field.\n\nFor example. a Stats aggregation against the `modalPremium` field may show that there are 20,000 records with any value in the `modalPremium` field, that the average value is $300, the maximum value is $12,000, the minimum value is $75, and the sum of all values is $6,000,000.\n\nOnly available for number-based fields.\n',
    )


class LinkedPartySearchFields(Enum):
    ID = 'ID'
    name = 'name'
    partyNumber = 'partyNumber'
    partyType = 'partyType'
    boundUsersNames = 'boundUsersNames'
    boundUsersNumbers = 'boundUsersNumbers'
    boundUsersIDs = 'boundUsersIDs'


class UserSearchFields(Enum):
    ID = 'ID'
    name = 'name'
    userNumber = 'userNumber'
    linkedPartiesTypes = 'linkedPartiesTypes'


class UserLinkedPartySearchFields(BaseModel):
    __root__: LinkedPartySearchFields | UserSearchFields


class Operator24(Enum):
    empty = 'empty'
    notEmpty = 'notEmpty'


class SearchRequestUserPartyComponentsSchemasValueExistenceFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the field that the user chooses to filter against.\n',
    )
    operator: Operator24 = Field(
        ...,
        description='A logical operator to return records based on whether _any value exists_ in a user-specified field.\n\nFor example, the `empty` operator can be used to search for all records that do not have _any value_ in the `policyNumber` field .\n',
    )


class Operator25(Enum):
    startsWith = 'startsWith'
    endsWith = 'endsWith'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class SearchRequestUserPartyComponentsSchemasStringComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the string field the user chooses to filter against.',
    )
    operator: Operator25 = Field(
        ...,
        description='A logical operator used to perform string comparison.\n\nFor example, the `contains` operator can be used to search for all records where the string "Abc123" appears somewhere within the `policyNumber` field.\n',
    )
    value: constr(min_length=1, max_length=32767) = Field(
        ..., description='The user-specified string to used to create the filter.'
    )


class Operator26(Enum):
    gt = 'gt'
    gte = 'gte'
    lt = 'lt'
    lte = 'lte'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class SearchRequestUserPartyComponentsSchemasNumericComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the numeric field the user chooses to filter against.\n',
    )
    operator: Operator26 = Field(
        ...,
        description='A logical operator used to perform numeric comparison.\n\n  For example, the `lte` operator can be used to search for all records that have a value less than or equal to 10,000 the `policyNumber` field.\n',
    )
    value: float = Field(
        ..., description='The user-specified number used to create the filter.'
    )


class Operator27(Enum):
    after = 'after'
    before = 'before'
    onOrAfter = 'onOrAfter'
    onOrBefore = 'onOrBefore'


class SearchRequestUserPartyComponentsSchemasDateComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the date field the user chooses to filter against.',
    )
    operator: Operator27 = Field(
        ...,
        description='A logical operator used for date comparison.\n\nFor example, the `before` operator can be used to search for all records that have date prior to Dec 31, 2000 in the `effectiveDate` field.\n',
    )
    value: constr(min_length=4, max_length=30) = Field(
        ...,
        description='The user-specified Date or DateTime value to create the filter in ISO 8601 format __without timezone__.\n\n**For Date-only filtering** (Properties that represent only a date, without a time component):\n- Format: \'YYYY-MM-DD\' (e.g., `2024-01-15`)\n- Compares only the date portion (year, month, day)\n- Ignores time component.\n\n**For DateTime filtering** (Properties that represent both a date and time):\n- Format: ISO 8601 string (e.g., `"2024-01-15T10:30:00.000"`)\n- Provides millisecond-precision filtering\n- Enables precise timestamp without timezone comparison.\n\nThe system automatically detects the format and applies the appropriate comparison logic.\n',
        example='2024-01-15',
    )


class Operator28(Enum):
    in_ = 'in'
    notIn = 'notIn'


class SearchRequestUserPartyComponentsSchemasListMembershipFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ..., description='The name of the field the user chooses to filter against.'
    )
    operator: Operator28 = Field(
        ...,
        description='A logical operator to check for membership within a collection of values.\n\nFor example, the `in` operator can be used to search for all records that have data in the `policyNumber` field that matches at least one of the `values` specified by the user.\n',
    )
    values: list[str | float] = Field(
        ...,
        description='The collection of user-specified values used to create the filter.\n\nFor example, if the user specifies 30 different policy numbers as different `values`, the filter will return only records with data in the`policyNumber` field that matches at least one of those 30 policy numbers.\n',
        max_items=32767,
        min_items=1,
    )


class Operator29(Enum):
    between = 'between'
    notBetween = 'notBetween'


class SearchRequestUserPartyComponentsSchemasRangeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ..., description='The name of the field to compare the filter range against.'
    )
    operator: Operator29 = Field(
        ...,
        description='A logical operator user to check for whether records include a value within the user-specified range.\n\nFor example, the `between` operator can be used to search for all records that have a value in the `effectiveDate` field between `2024-01-31` and `2025-01-31`.\n',
    )
    range: list[str | float] = Field(
        ...,
        description='A collection of exactly two user-specified values: one for the upper bound of the range, the other for the lower bound.\n',
        max_items=2,
        min_items=2,
    )


class Operator30(Enum):
    search = 'search'


class SearchRequestUserPartyComponentsSchemasSearchFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the field the user chooses to filter against. Users may assign each field an optional `boost` value to rank the importance of that field in the search results.',
    )
    operator: Operator30 = Field(..., description='TODO...')
    term: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The text that is matched against field values during the search. The search term may consist of a single word or multiple words',
        example='John Doe',
    )
    searchType: SearchType | None = Field(
        'keyword',
        deprecated=True,
        description='The method for matching the search term against field values:\n - `keyword` searches for individual search term words independently from each other.\n - `phrase`  searches for the entire text of the search term together as a contiguous string.\nDeprecated: We automatically detect whether to search by keyword or phrase based on the presence of spaces in the search term.\n',
    )
    boost: float | None = Field(
        1,
        description='A value from 1 to 10 used to rank the importance of a given field relative to other fields during a given search.',
    )


class ResourceTypeEnum1(Enum):
    user = 'user'
    linkedParty = 'linkedParty'


class SchemasResourceTypeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    resourceType: list[ResourceTypeEnum1] = Field(
        ...,
        description='The kind of record or business object that the user chooses to search for (e.g. the user only wants the search to return records that are Policies).\n',
        max_items=32767,
        min_items=1,
    )


class Operator31(Enum):
    AND = 'AND'
    OR = 'OR'


class SearchRequestUserPartyComponentsSchemasCompositeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    operator: Operator31 = Field(
        ..., description='A logical operator used to combine filters.'
    )
    filters: list[
        SearchRequestUserPartyComponentsSchemasValueExistenceFilter
        | SearchRequestUserPartyComponentsSchemasStringComparisonFilter
        | SearchRequestUserPartyComponentsSchemasNumericComparisonFilter
        | SearchRequestUserPartyComponentsSchemasDateComparisonFilter
        | SearchRequestUserPartyComponentsSchemasListMembershipFilter
        | SearchRequestUserPartyComponentsSchemasRangeFilter
        | SearchRequestUserPartyComponentsSchemasSearchFilter
        | SchemasResourceTypeFilter
    ] = Field(..., max_items=32767, min_items=1)


class SearchRequestUserPartyComponentsSchemasBaseAggregation(BaseModel):
    name: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A user-specified name for the aggregation, used to reference it in the response.',
    )
    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the field this aggregation is being performed against.',
    )


class Type18(Enum):
    terms = 'terms'


class SearchRequestUserPartyComponentsSchemasTermAggregation(
    SearchRequestUserPartyComponentsSchemasBaseAggregation, NestedAggregation
):
    type: Type18 | None = Field(
        None,
        description='The **Terms** aggregation returns the number of records that have a particular value in a given string-field. \n\nFor example, a terms aggregation against the `product` field may show that there are 20 records for Product A and 50 records of Product B.\n\nOnly available for string-based fields.\n',
    )


class Type19(Enum):
    dateHistogram = 'dateHistogram'


class SearchRequestUserPartyComponentsSchemasDateHistogramAggregation(
    SearchRequestUserPartyComponentsSchemasBaseAggregation, NestedAggregation
):
    type: Type19 | None = Field(
        None,
        description='The **Date Histogram** aggregation returns the number of records with a date value falling within a given time period (`dateInterval`). Users can choose whether to group records by year, month, week, or day. \n\nFor example. a Date Histogram against the `effectiveDate` field (with a `dateInterval` of `year`) may show that there are 1000 records with an `effectiveDate` between Jan 28, 1999 and Jan 28, 2000, and 2000 records between Jan 28, 2000 and Jan 28, 2001.\n\nOnly available for date-based fields.\n',
    )
    dateInterval: DateInterval | None = Field(
        None,
        description='A user-chosen duration used to create groups of equal duration in date histogram aggregations.',
    )


class Type20(Enum):
    stats = 'stats'


class SearchRequestUserPartyComponentsSchemasStatsAggregation(
    SearchRequestUserPartyComponentsSchemasBaseAggregation
):
    type: Type20 | None = Field(
        None,
        description='The **Stats** aggregation returns the maximum value, minimum value, sum of values, and arithmetic mean of values present in a given numeric field, as well as the number of records with values in that field.\n\nFor example. a Stats aggregation against the `modalPremium` field may show that there are 20,000 records with any value in the `modalPremium` field, that the average value is $300, the maximum value is $12,000, the minimum value is $75, and the sum of all values is $6,000,000.\n\nOnly available for number-based fields.\n',
    )
