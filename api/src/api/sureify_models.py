# generated by datamodel-codegen:
#   filename:  sureify.json
<<<<<<< HEAD
#   timestamp: 2026-02-24T17:27:10+00:00
=======
#   timestamp: 2026-02-24T16:51:04+00:00
>>>>>>> 0cdd862 (agentbuild)

from __future__ import annotations

from datetime import timedelta
from enum import Enum
from typing import Any

from pydantic import AnyUrl, BaseModel, Extra, Field, confloat, conint, constr


class Persona(Enum):
    policyowner = 'policyowner'
    agent = 'agent'


class ID(BaseModel):
    __root__: constr(min_length=1, max_length=64) = Field(
        ...,
        description='Correlation ID - A unique identifier for each entity (whether that entity is a person, a company, a policy, etc). \nWe expose this ID for the purpose of matching entities in our internal system to their corresponding records in external systems, such as carrier SORs.\n*While this value MAY appear to be a UUID, you MUST accept values that are not UUIDs.*\nAlso used for Workflow and Journey Instance IDs.',
        example='4b33ae9e-827a-479d-b60c-8daa2873c08c',
    )


class QuestionGroup(BaseModel):
    ID: ID | None = Field(
        None, description='A unique identifier for the question group.'
    )
    title: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The title of the question group (e.g. Basic Information).',
        example='Basic Information',
    )


class Question(BaseModel):
    ID: ID = Field(..., description='A unique identifier for this question.')
    title: constr(min_length=1, max_length=32767) = Field(
        ..., description='The text of the question.', example='What is your first name?'
    )
    parentID: ID | None = Field(
        None,
        description="A pointer to the `ID` field for for this question's parent question (i.e. the question which this question is nested below). Top level questions to not have a parent question.",
    )
    groupID: ID | None = Field(
        None,
        description='A unique identifier for the question group that this question belongs to.',
    )
    sequence: conint(ge=1) = Field(
        ...,
        description='A number indicating where this question appears on the application, relative to all other questions.\n\nNote: Questions are NOT guaranteed to be returned in consecutive order.\nYou must use the value of `sequence` to order questions relative to each other.\n',
        example=1,
    )


class DateTime(BaseModel):
    __root__: constr(min_length=4, max_length=36) = Field(
        ...,
        description='A timestamp, as specified in [ISO 8601-2:2019 Extended Date/Time Format (EDTF)](https://en.wikipedia.org/wiki/ISO_8601#EDTF).\nUse this type for properties that represent a moment-in-time when a specific action occurred (i.e. a date or a date as well as a time). \nTime zone designator OPTIONAL.\nMonth and Day MAY be a single digit value, if value is less than 10.\n',
        example='2021-08-29T09:12:33.001Z',
    )


class BaseRole(BaseModel):
    class Config:
        extra = Extra.allow

    role: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The function that a person or entity plays in relation to the policy.',
        example='Insured',
    )
    contactID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the person, company, or trust listed on the policy.',
    )
    policyID: ID | None = Field(
        None,
        description='A pointer to the policy record on which this person, company, or trust is listed.',
    )


class Duration(BaseModel):
    __root__: timedelta = Field(
        ...,
        description='An amount of time specified in [ISO 8601:2004 \n(Duration)](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n\nUse this type for any properties that represent durations.\n',
        example='P1Y2M3DT4H5M6S',
    )


class Designation(Enum):
    Primary = 'Primary'
    Joint = 'Joint'
    Child = 'Child'


class Insured(BaseRole):
    class Config:
        extra = Extra.forbid

    designation: Designation | None = Field(
        None,
        description="A designation indicating how this insured is covered (i.e. primary vs. joint). The insured's designation depends on the way that the policy is structured and has implications for how death benefits are distributed, should this insured die.",
    )
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this is the main insured for the policy (i.e. the person who has completed the majority of the application). Only relevant in for policies that list multiple insureds.',
    )
    issueAge: Duration | None = Field(
        None, description='The age of the insured at the time the policy was issued.'
    )
    riskClass: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The risk class (e.g. Preferred, Super Preferred, Substandard, etc.) at which this insured was approved.',
    )
    tableRating: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The table rating (e.g. Table A/1, Table B/2, Table C/3 etc) at which this insured was approved.',
    )


class Annuitant(BaseRole):
    class Config:
        extra = Extra.forbid

    designation: Designation | None = Field(
        None,
        description="A designation indicating how this insured is covered (i.e. primary vs. joint). The insured's designation depends on the way that the policy is structured and has implications for how the proceeds of the policy are distributed, should this annuitant die.",
    )
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this is the main annuitant for the policy (i.e. the person who has completed the majority of the application). Only relevant for policies that list multiple annuitants.',
    )
    issueAge: Duration | None = Field(
        None, description='The age of the annuitant at the time the policy was issued.'
    )


class NonNegativePercent(BaseModel):
    __root__: confloat(ge=0.0) = Field(
        ...,
        description='Percent value (disallows negative values). For example, 150 represents 150%, and 1 represents 1%.\n',
        example=22,
    )


class BeneficiaryDesignation(Enum):
    Primary = 'Primary'
    Contingent = 'Contingent'


class RelationshipToInsured(BaseModel):
    class Config:
        extra = Extra.forbid

    insuredRelatedTo: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The insured whom the beneficiary is related to (e.g. the primary insured vs. another insured).',
        example='Primary',
    )
    relationship: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The way in which the beneficiary is related to the insured (e.g. Spouse, Child, Cousin, etc.)',
        example='Child',
    )


class Type(Enum):
    Person = 'Person'
    Estate = 'Estate'
    Corporation = 'Corporation'
    Charity = 'Charity'
    Trust = 'Trust'
    Other = 'Other'


class Custodian(BaseModel):
    class Config:
        extra = Extra.forbid

    contactID: ID | None = Field(
        None, description='A pointer to the full contact record for this custodian.'
    )
    relationshipToBeneficiary: constr(min_length=1, max_length=32768) | None = Field(
        None,
        description='The way in which this custodian is related to the beneficiary.',
    )


class BeneficiaryProperties(BaseModel):
    class Config:
        extra = Extra.allow

    allocationPercentage: NonNegativePercent | None = Field(
        None,
        description="The percentage of the policy's proceeds (e.g. death benefit) that this beneficiary receives after the insured/annuitant passes.",
    )
    type: Type | None = Field(
        None,
        description='The kind of entity that this beneficiary is (e.g. a Charity, Trust, Company, Person, etc.).',
    )
    designation: BeneficiaryDesignation | None = None
    isIrrevocable: bool | None = Field(
        None,
        description='True indicates that, regardless of whether the insured/annuitant has died or not, this beneficiary must approve any changes to the policy, including beneficiary changes (i.e. the insured/annuitant is unable to remove this beneficiary from the policy, unless the beneficiary explicitly approves the change).',
    )
    isPerStirpes: bool | None = Field(
        None,
        description="True indicates that if a named beneficiary dies before the insured/annuitant, the descendents of that named beneficiary receive the policy's proceeds (e.g. death benefit) rather than the descendents of the insured/annuitant.",
    )
    isPerCapita: bool | None = Field(
        None,
        description="True indicates that every living beneficiary gets an equal share of the policy's proceeds (e.g. death benefit).",
    )
    isPrimarySplit: bool | None = Field(
        None,
        description="True indicates that the policy's proceeds (e.g. death benefit) is split evenly across all primary beneficiaries.",
    )
    isContingentSplit: bool | None = Field(
        None,
        description="True indicates that the policy's proceeds (e.g. death benefit) is split evenly across all contingent beneficiaries.",
    )
    relationshipToInsured: RelationshipToInsured | None = Field(
        None,
        description="The way in which the beneficiary is related to the insured/annuitant, and which insured/annuitant they're related to.",
    )
    custodians: list[Custodian] | None = Field(
        None,
        description='A collection of custodians for the beneficiary.',
        max_items=32768,
        min_items=0,
    )


class Beneficiary(BaseRole, BeneficiaryProperties):
    class Config:
        extra = Extra.forbid


class Owner(BaseRole):
    class Config:
        extra = Extra.forbid

    isPrimary: bool | None = Field(
        None,
        description='True indicates that this is the main owner for the policy (i.e. the person who has completed the majority of the application). Only relevant in for policies that list multiple owners.',
    )
    relation: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The relationship between the owner and the insured/annuitant (e.g. Spouse, Child, Cousin, etc.).',
        example='Spouse',
    )


class Agent(BaseRole):
    class Config:
        extra = Extra.forbid

    type: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A label indicating how this agent engages with the policy (e.g. Writing Agent, Servicing Agent, etc.)',
        example='Servicing',
    )
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this agent is the main point of contact for the policy. Oversees correspondence and activity on the policy.',
    )
    commissionPercentageSplit: NonNegativePercent | None = Field(
        None,
        description='The proportion of commission assigned to this agent when multiple agents are associated with a policy.',
    )


class Other(BaseRole):
    class Config:
        extra = Extra.allow

    isPrimary: bool | None = Field(
        None,
        description='True indicates that this person/organization is somehow more important than any other person/organization that plays the same role on a particular policy.\nFor example, isPrimary may indicate the main point of contact, or the person who is ultimately responsible for fulfilling a piece of work.\nNote that this marker is only relevant when there are multiple people/organizations who play the same role on a particular policy.\n',
    )


class Answer(BaseModel):
    answer: constr(min_length=1, max_length=32767) = Field(
        ..., description='An answer to a question.', example='John'
    )
    date: DateTime | None = Field(
        None, description='The date and time at which this answer was submitted.'
    )
    attempt: conint(ge=1) = Field(
        ...,
        description='A number indicating the chronological order in which this answer was submitted.\nThe `attempt` value with the highest number is the most recent answer.\n\nNote: Answers are NOT guaranteed to be returned in chronological order.\nUse the value of the `attempt` property to chronologically order answers relative to each other.\n',
        example=1,
    )
    roleSnapshot: Insured | Annuitant | Beneficiary | Owner | Agent | Other | None = (
        Field(
            None,
            description='A snapshot of the role best characterizing the individual who submitted this answer.',
        )
    )


class AnswerHistoryItem(BaseModel):
    questionID: ID = Field(
        ...,
        description='A pointer to the question that this set of historical answers is associated with.',
    )
    answers: list[Answer] | None = Field(
        None,
        description='A collection of historical answers.\nNote: Answers are not guaranteed to be returned in any particular order.\nUse the `attempt` property to determine the chronological order of answers.\n',
    )


class AnswerHistory(BaseModel):
    __root__: list[AnswerHistoryItem] = Field(
        ...,
        description='A collection of historical answers, grouped by the question that they are associated with.',
        title='Answer History',
    )


class Application(BaseModel):
    caseID: ID = Field(
        ..., description='A pointer to the case that the answers are associated with.'
    )
    answerHistory: list[AnswerHistory] | None = Field(
        None,
        description='A collection of historical answers, grouped by the question they are associated with. \n\nNote: Answers are NOT guaranteed to be returned in consecutive order.\nYou must use the value of the `attempt` property to order answers relative to each other.\n',
        max_items=32768,
        min_items=0,
    )
    applicationNumber: str | None = Field(
        None,
        description='A combination of letters and numbers that the e-apply vendor uses to uniquely identify an application in the application entry system.',
    )
    URL: AnyUrl | None = Field(
        None,
        description='The URL (i.e. web address) of the external server, website, or application to which a user may be redirected.',
    )


class MonetaryAmountCurrency(BaseModel):
    class Config:
        extra = Extra.allow

    currency: constr(min_length=3, max_length=3) = Field(
        ...,
        description='The ISO standard currency code for this monetary amount.',
        example='USD',
    )


class NonNegativeMonetaryAmount(MonetaryAmountCurrency):
    class Config:
        extra = Extra.allow

    value: conint(ge=0) = Field(
        ...,
        description='The value for a monetary amount in cents. Negative values are not allowed.',
        example=49987,
    )


class State(Enum):
    AL = 'AL'
    AK = 'AK'
    AZ = 'AZ'
    AR = 'AR'
    CA = 'CA'
    CO = 'CO'
    CT = 'CT'
    DE = 'DE'
    FL = 'FL'
    GA = 'GA'
    HI = 'HI'
    ID = 'ID'
    IL = 'IL'
    IN = 'IN'
    IA = 'IA'
    KS = 'KS'
    KY = 'KY'
    LA = 'LA'
    ME = 'ME'
    MD = 'MD'
    MA = 'MA'
    MI = 'MI'
    MN = 'MN'
    MS = 'MS'
    MO = 'MO'
    MT = 'MT'
    NE = 'NE'
    NV = 'NV'
    NH = 'NH'
    NJ = 'NJ'
    NM = 'NM'
    NY = 'NY'
    NC = 'NC'
    ND = 'ND'
    OH = 'OH'
    OK = 'OK'
    OR = 'OR'
    PA = 'PA'
    RI = 'RI'
    SC = 'SC'
    SD = 'SD'
    TN = 'TN'
    TX = 'TX'
    UT = 'UT'
    VT = 'VT'
    VA = 'VA'
    WA = 'WA'
    WV = 'WV'
    WI = 'WI'
    WY = 'WY'
    DC = 'DC'
    AS = 'AS'
    GU = 'GU'
    MP = 'MP'
    PR = 'PR'
    UM = 'UM'
    VI = 'VI'


class Attribute(BaseModel):
    class Config:
        extra = Extra.forbid

    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The key part of a product attribute key:value pair. \n \n If referencing the key:value pair examples given in the `attributes` description, the key are: Availability, Target Audience, and Liquidity.\n',
        example='Target Audience',
    )
    value: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The value part of a product attribute key-value pair. \n \n If referencing the key:value pair examples given in the `attributes` description, the values are: All of USA, Seniors 65+, and Free Partial Withdrawals.\n',
        example='Senior, 65+',
    )
    category: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the category to which this attribute belongs to.',
        example='Audience',
    )


class Plan(BaseModel):
    class Config:
        extra = Extra.forbid

    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the plan available within the product.\n \n For example, if the product is "Whole Life 5", plan names may be "Whole Life 5 Silver", "Whole Life 5 Gold", or "Whole Life 5 Platinum with LTC".\n',
        example='WholeLife 5 Silver',
    )
    planCode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and/or numbers that the carrier uses to uniquely identify the plan available within the product (ABC01s28).',
        example='A1128',
    )


class URL(BaseModel):
    class Config:
        extra = Extra.forbid

    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the external server, website, or application to which this URL redirects the user (e.g. LifetimeACQUIRE). Note that this name is separable from any button text that may be used to present the URL on a UI.',
        example='LifetimeACQUIRE',
    )
    URL: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The URL (i.e. web address) of the external server, website, or application to which a user may be redirected.',
        example='https://dev-agent.sureify.com/',
    )


class Product(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(None, description='A unique identifier for this product.')
    productCode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and/or numbers that the carrier uses to uniquely identify the given product.',
        example='SPDA',
    )
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the product (e.g. SureCo Whole 30, Term 20, SureCo Annuity Plus).',
        example='Whole Life Insurance',
    )
    carrierCode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and/or numbers that the carrier uses to uniquely identify the company associated to the product.',
        example='LC10',
    )
    documentIDs: list[ID] | None = Field(
        None,
        description='A collection of pointers to the documents related to this product .\n',
        max_items=32768,
        min_items=0,
    )
    attributes: list[Attribute] | None = Field(
        None,
        description='A collection of key:value pairs that give information about various characteristics of the product, such as where the product is available (e.g. Availability:All of USA), the age range that the product is designed for (e.g. Target Audience:Seniors 65+), or the benefits offered in the product (Liquidity:Free Partial Withdrawals).\n',
        max_items=32768,
        min_items=0,
    )
    plans: list[Plan] | None = Field(
        None,
        description='A collection of plans available within the product. Plans are particular configurations of benefits or requirements, providing fine-grained variations within a given product (e.g. specifying how many years money must stay invested before withdrawal).\n',
        max_items=32768,
        min_items=0,
    )
    URLs: list[URL] | None = Field(
        None,
        description='A collection of URLs that redirect the user to an external server, website, or application.',
        max_items=32768,
        min_items=0,
    )
    states: list[State] | None = Field(
        None,
        description='A collection of states in which this product is applicable, valid, registered, etc.',
        example=['AZ', 'OH'],
        max_items=50,
    )


class Type1(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(None, description='A unique identifier for this group/type .')
    name: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The name of this group/type.', example='Life'
    )


class ApplicationType(Enum):
    Electronic = 'Electronic'
    Paper = 'Paper'


class PaymentMethod(Enum):
    creditcard = 'creditcard'
    check = 'check'
    debit = 'debit'


class Type2(Type1):
    parent: Type1 | None = None


class ProductSnapshot(Product):
    type: Type2 | None = None


class CasePolicyBase(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(
        None, description='A unique identifier for this case or policy.'
    )
    annualPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money the insured _would pay_ if paying on an annual mode (i.e. paying once per year).',
    )
    annualizedPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The _actual_ amount of money the insured pays over the course of a year. This amount is calculated by multiplying the mode (the number of payments an insured makes per year) by the modal premium (the amount of money included in each payment).',
    )
    applicationType: ApplicationType | None = Field(
        None,
        description='The process by which the application for this case or policy was submitted.',
        example='Electronic',
    )
    carrier: str | None = Field(
        None,
        description='The insurance company that issues the policy. _Note that this may be a subsidiary of a larger',
    )
    commissionableAnnualizedPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description="The amount of money paid in premium that is used to calculate an agent's commission on the policy over the course of a year.\n",
    )
    coveredUntilDate: DateTime | None = Field(
        None,
        description='The date on which policy coverage ends (i.e. the last day the insured is still  eligible to make a claim or receive a death benefit). Typically found with Term policies. If a `coveredUntilDate` is included on a permanent policy, it is usually set to 100 years after the date when the policy was issued.',
    )
    deathBenefit: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money that is paid out to the beneficiary of a life or annuity insurance policy when the insured or annuitant dies. Typically used in Whole Life, Universal Life, or Annuities (as opposed to Term Life).  \n\n`deathBenefit` may differ from `faceAmount` in that `deathBenefit` may change over time, while `faceAmount` stays the same over the lifetime of a policy. \n\nThe value of `deathBenefit` often changes because adjustments (e.g. the accrual of interest) are made to it over the lifetime of the policy. \n\nIn Annuities, if an annuitant dies before the full annuity has been paid out, the `deathBenefit` is paid out to beneficiaries.\n',
    )
    documentIDs: list[ID] | None = Field(
        None,
        description='A collection of pointers to the documents related to this policy. Examples of policy-related documents include, but are not limited to: anniversary statements and policy pages.\n',
        example=['4b33ae9e-827a-479d-b60c-8daa2873c08c'],
        max_items=32768,
        min_items=0,
    )
    effectiveDate: DateTime | None = Field(
        None, description='The date on which the case becomes an active policy.'
    )
    faceAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The monetary amount of the death benefit at the time when the policy was issued. Typically used in Term Life (as opposed to Whole Life, Universal Life, or Annuities).  \n\nThe value of `faceAmount` at the time of policy issuance is the same as it is at the time of the claim, whereas the value of  `deathBenefit` may change over time.\n',
    )
    excess: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The portion of a commissionable annualized premium that an agent does _not_ receive full first year commission on. Note: `commissionableAnnualizedPremium` = `target` + `excess`.\n',
    )
    carrierLastUpdated: DateTime | None = Field(
        None, description='The date on which the carrier last updated this policy.'
    )
    guaranteedMinimumDeathBenefit: NonNegativeMonetaryAmount | None = Field(
        None,
        description="The lowest dollar amount that the contract guarantees will be paid out in the event of the insured's/annuitant's death.",
    )
    modalPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money a policyowner pays in premium when they receive their bill. The frequency at which the policyowner receives their bill and pays a `modalPremium` is called the `paymentMode`.\n',
    )
    nextPremiumDueDate: DateTime | None = Field(
        None, description='The date on which the next premium payment is due.'
    )
    paymentMethod: PaymentMethod | None = Field(
        None,
        description='The way in which the policyowner pays the premiums on their policy (e.g. via EFT, direct billing, credit card, etc). Sometimes referred to as billing method.',
        example='creditcard',
    )
    paymentMode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The frequency at which a policyowner is expected to pay the premium on their policy (e.g. Monthly, Quarterly, Semi-annually, or Annually). Note: The amount of money payable each time the policyowner receives their bill is the called the `modalPremium`.',
        example='Monthly',
    )
    policyNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify the policy; sometimes referred to as a contract number. A given contract MAY have both a `caseNumber` and a `policyNumber`, especially if the transition from case to policy took place recently.',
        example='ABC458587def',
    )
    productSnapshot: ProductSnapshot | None = Field(
        None,
        description='A snapshot of the base coverage product the policyowner purchases in order to create their policy.\nModifying coverages such as riders, plans, etc. can be added to this base product to build out a full policy.\n',
    )
    premiumType: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The way in which premium money is received into the policy or annuity (e.g. Initial, Unplanned, EFT).',
        example='Initial',
    )
    isOwnerSignatureMissing: bool | None = Field(
        None,
        description="True indicates that the owner's signature is missing from the policy.",
        example=True,
    )
    issueState: State | None = Field(
        None,
        description='The state (geographical region within the United States) in which this case or policy was issued.',
    )
    status: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The status of the case or policy. Examples include, but are not limited to Pending, Approved, Issued, Inforce, Paid, Lapsed, etc.',
    )
    statusCategory: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A group of related statuses. May be used as a metric for reporting or data visualization.\n',
        example='Lapsed',
    )
    statusDate: DateTime | None = Field(
        None,
        description='The most recent date on which the carrier updated the `status` of this case or policy.',
    )
    target: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The premium monetary amount that is applied to the agents first year commission rate. Note: `commissionableAnnualizedPremium` = `target` + `excess`.',
    )
    tenThirtyFiveExchangeAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money that can be transferred from an existing policy into a new policy without any immediate tax consequences.',
    )


class MonetaryAmount(MonetaryAmountCurrency):
    value: int = Field(
        ...,
        description='The value for this monetary amount in cents. Negative values are allowed.',
        example=49987,
    )


class FundingCompany(BaseModel):
    name: constr(min_length=1, max_length=255) | None = Field(
        None, description='The name of the funding company.'
    )
    referenceNumber: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The reference number associated with the policy at the funding company to be exchanged into this new policy.',
    )
    requestedDate: DateTime | None = Field(
        None,
        description='The date on which the carrier sent out a notification requesting the funds.',
        example='2021-08-29T09:12:33.001Z',
    )
    receivedDate: DateTime | None = Field(
        None,
        description='The date on which the carrier received the funds from the funding company.',
        example='2021-08-29T09:12:33.001Z',
    )
    requestedAmount: NonNegativeMonetaryAmount | None = Field(
        None, description='The total money requested by the carrier.'
    )
    receivedAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total money received by the carrier from the funding company.',
    )
    status: constr(min_length=1, max_length=255) | None = Field(
        None, description='The status of the money (e.g. received, outstanding, etc.)'
    )


class NIGO(BaseModel):
    class Config:
        extra = Extra.forbid

    isNIGO: bool | None = Field(
        None,
        description='True indicates that the case is in NIGO (Not In Good Order) state.',
        example=True,
    )
    reason: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The reason why the case is in NIGO (Not In Good Order) state.',
        example='Agent information is missing',
    )
    category: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The category of NIGO (Not In Good Order) applicable to this case. Examples include Agent, Client, Form etc.',
        example='Agent',
    )
    beginDate: DateTime | None = Field(
        None,
        description='The date on which the case transitioned into NIGO (Not In Good Order) state.',
    )
    endDate: DateTime | None = Field(
        None,
        description='The date on which the case transitioned out of NIGO (Not In Good Order) state.',
    )


class Case(CasePolicyBase):
    appliedRiskClass: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The risk class (e.g. Preferred, Super Preferred, Substandard, etc.) that the agent/client submits on the application. Risk class is subject to change as a case moves through the underwriting process. This is why the original `appliedRiskClass`  may be different than the final `approvedRiskClass` that appears on the inforce policy. After a policy becomes inforce, the original `appliedRiskClass` is stored for reporting purposes.',
    )
    approvedRiskClass: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The risk class (e.g. Preferred, Super Preferred, Substandard, etc.) that the carrier approves, and that therefore appears on the policy once it is inforce. Risk class is subject to change as a case moves through the underwriting process. This is why the original `appliedRiskClass`  may be different than the final `approvedRiskClass` that appears on the inforce policy.',
    )
    approvedTableRating: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The table rating (e.g. Table A/1, Table B/2, Table C/3 etc) at which the insured was approved. When the insured is table-rated, they must pay an extra percentage on top of the standard premium.',
    )
    balanceDue: MonetaryAmount | None = Field(
        None,
        description='The amount of money that the insured currently owes on a pending policy. \nFor example, the insured may have a balance due if their policy is accepted at a higher rate than what was originally quoted. In such a situation, the insured must pay the `balanceDue` in order to make the policy inforce.\n',
    )
    cashReceived: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money the carrier receives along with the application (i.e. the money that a policyowner submits as part of the application).\nNote: Any additional money due, that is not received with the application, is considered a `balanceDue`.\n',
    )
    dateCashReceived: DateTime | None = Field(
        None,
        description='The date on which the money that came in with the application (`cashReceived`) was collected by the carrier.',
    )
    applicationReceivedDate: DateTime | None = Field(
        None, description='The date the application was received.'
    )
    applicationSignedDate: DateTime | None = Field(
        None, description='The date the application was signed.'
    )
    caseNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A number assigned by an application system such as Firelight or LifetimeACQUIRE, used to identify the case. If the case becomes a policy, the `caseNumber` is stored temporarily until a policy number or contract number is received.',
        example='C458587',
    )
    NIGO: NIGO | None = Field(
        None, description='A summary of NIGO (Not In Good Order) state.'
    )
    underwritingType: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The type of underwriting performed on this case before it can become an active policy. Examples include but are not limited to: Full, Instant Issue, Automated, etc.',
        example='Full',
    )
    fundingCompanies: list[FundingCompany] | None = Field(
        None,
        description='A collection of companies that will fund the case in flight.',
        max_items=32768,
        min_items=0,
    )


class Name(BaseModel):
    class Config:
        extra = Extra.forbid

    first: constr(min_length=1, max_length=32767) | None = Field(
        None, description='First name.', example='Bob'
    )
    last: constr(min_length=1, max_length=32767) | None = Field(
        None, description='Last name.', example='Smith'
    )
    middle: constr(min_length=1, max_length=32767) | None = Field(
        None, description='Middle name or initial.', example='J.'
    )
    suffix: constr(min_length=1, max_length=32767) | None = Field(
        None, description='Name suffix.', example='Jr.'
    )
    fullName: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description="A person's full name, as represented in a single data field. Use `fullName` whenever name data is not broken down into first & last names. `fullName` may also be used for names of companies, trusts, and organizations.",
        example='Bob J. Smith',
    )


class BaseEmail(BaseModel):
    class Config:
        extra = Extra.allow

    emailAddress: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The text of the email address.', example='info@sureify.com'
    )


class Email(BaseEmail):
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this email address has been designated as the best one to use for a particular contact. Within a collection of email addresses for a given contact, **exactly one** must be marked `isPrimary`.',
        example=True,
    )
    type: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The context in which this email address is used (e.g. work vs. personal email address).',
        example='personal',
    )


class BasePhoneNumber(BaseModel):
    class Config:
        extra = Extra.allow

    phoneNumber: constr(min_length=1, max_length=50) | None = Field(
        None, description='A phone number', example='8558675309'
    )


class PhoneNumber(BasePhoneNumber):
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this phone number has been designated as the best one to use for a particular contact. Within a collection of phone numbers for a given contact, **exactly one** must be marked `isPrimary`.',
        example=True,
    )
    type: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The context in which this phone number is used (e.g. work vs. mobile).',
        example='mobile',
    )


class BaseAddress(BaseModel):
    class Config:
        extra = Extra.allow

    address1: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The first address field, typically containing a number/ street name combination.',
        example='1100 Lincoln Ave',
    )
    address2: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The second address field, typically containing an apartment or suite number.',
        example='Unit 240',
    )
    address3: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description="The third address field, typically only used for indicating 'Care Of' (C/O), or other notes.",
        example='C/O Fred Rogers',
    )
    city: constr(min_length=1, max_length=32767) | None = Field(
        None, description='A city name.', example='San Jose'
    )
    country: constr(min_length=2, max_length=3) | None = Field(
        None,
        description='A two or three letter country code.\nUses the ISO 3166-1 standard.',
        example='US',
    )
    state: State | None = None
    postalCode: constr(min_length=5, max_length=10) | None = Field(
        None,
        description='A zip/postal code in five digit or zip+4 format.',
        example='95125-9698',
    )
    type: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The context in which this address is used (e.g. work vs. home address).',
        example='home',
    )


class Address(BaseAddress):
    isBadAddress: bool | None = Field(
        None,
        description='True indicates that this address is known to be unusable, either because mail was returned, or because address validation failed.',
        example=True,
    )
    isPrimary: bool | None = Field(
        None,
        description='True indicates that this address has been designated as the best one to use for a particular contact. Within a collection of addresses for a given contact, **exactly one** must be marked `isPrimary`.',
        example=True,
    )


class BasePerson(BaseModel):
    class Config:
        extra = Extra.allow

    name: Name | None = None
    governmentIDNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A government-issued identification number used for taxation and/or or legal identification purposes (e.g. social security number).',
        example='365-86-8526',
    )
    DOB: DateTime | None = Field(
        None,
        description="This person's date of birth (DOB). The field may contain only a birth year if data for the person is incomplete.",
    )
    sex: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The legally recognized gender of the person, usually as assigned at birth.',
        example='female',
    )
    emails: list[Email] | None = Field(
        None,
        description='A collection of email addresses for this person.',
        max_items=32768,
        min_items=0,
    )
    phoneNumbers: list[PhoneNumber] | None = Field(
        None,
        description='A collection of telephone numbers by which this person can be reached.',
        max_items=32768,
        min_items=0,
    )
    addresses: list[Address] | None = Field(
        None,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )


class Type3(Enum):
    Person = 'Person'


class Person(BasePerson):
    ID: ID | None = Field(None, description='A unique identifier for this contact.')
    type: Type3 | None = None
    personNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify the person.',
        example='12345678AbC',
    )
    companyID: ID | None = Field(
        None,
        description='A pointer to the full contact record for the company or organization that this person is associated with (e.g. the LLC or sole proprietorship that this person does business under).',
    )
    agencyID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the business that this person works for.',
    )


class BaseCompany(BaseModel):
    name: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The name of the corporate entity.', example='SureCo'
    )
    addresses: list[Address] | None = Field(
        None,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )
    website: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description="The URL for a company's website.",
        example='https://www.acme-co.com',
    )
    companyCode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify this company or agency.',
        example='12345678ABc',
    )
    businessType: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The legal business structure of this company (e.g. LLC, S corporation, sole proprietorship, etc.).',
        example='LLC',
    )
    phoneNumbers: list[PhoneNumber] | None = Field(
        None,
        description='A collection of telephone numbers by which this company can be reached.',
        max_items=32768,
        min_items=0,
    )


class Type4(Enum):
    Company = 'Company'


class Company(BaseCompany):
    ID: ID | None = Field(None, description='A unique identifier for this contact.')
    type: Type4 | None = None
    parentCompanyID: ID | None = Field(
        None,
        description='A pointer to the parent company that this company is a subsidiary of (if one exists).',
    )


class MostRecentPayment(BaseModel):
    class Config:
        extra = Extra.forbid

    date: DateTime | None = Field(
        None,
        description='The date on which the carrier received the most recent payment.',
    )
    amount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money the carrier collected at the time of the most recent payment.',
    )
    reason: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='An explanation for why the most recent payment differs from the normal (i.e. expected) amount. This field is only used in situations that significantly stray from the norm. \n\n Example: if the most recent payment is twice as large as normal, the `reason` might be "This payment is double because the previous payment was skipped".\n',
    )


class Percent(BaseModel):
    __root__: float = Field(
        ...,
        description='Percent value (allows negative values). For example: 150 represents 150%, 1 represents 1%, and -1 represents -1%.\n',
        example=-22,
    )


class CashValueHistoryItem(BaseModel):
    class Config:
        extra = Extra.forbid

    value: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The cash value of the policy at a particular moment in time (`date`).\n',
    )
    percentageChange: Percent | None = Field(
        None,
        description='The percentage rise or fall of cash-value during the time period',
    )
    date: DateTime | None = Field(
        None, description='The date on which this cash value line-item was generated.\n'
    )


class Loan(BaseModel):
    class Config:
        extra = Extra.forbid

    repayBalance: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money required to pay off the loan, should the policyowner repay the loan today. This amount _excludes_ any expected/future interest.',
    )
    mostRecentPayment: MostRecentPayment | None = Field(
        None, description='The most recent loan payment received by the carrier.'
    )
    accruedInterest: NonNegativeMonetaryAmount | None = Field(
        None,
        description="The interest that has accrued on the loan. _Note- the carrier must choose the time period applicable to this interest rate (i.e. whether this field represent the interest accrued over the loan's lifetime, since the last payment date,  or over another period of time)_.",
    )
    currentBalance: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The current balance of the loan (i.e. the balance that remains at this moment in time, taking into account any payments that have already been made).',
    )
    interestRate: NonNegativePercent | None = Field(
        None, description='The rate at which interest on the loan accrues.'
    )


class Policy(CasePolicyBase):
    class Config:
        extra = Extra.allow

    accountNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The "master" or "parent" contract number under which this policy is grouped. Only use this field when this policy belongs to a collection of policies that are all billed to a single "master" account (e.g. if someone holds a collection of policies, one for each of their grandchildren, each individual policy will be linked to the same master `accountNumber`).',
        example='AA77777',
    )
    accruedInterest: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money that has accumulated in interest over the lifetime of the policy',
    )
    cashValue: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money that a policyowner can take out of their policy/annuity (i.e. the current monetary value of the policy/annuity, after any fees associated with withdrawal have been taken out).\n',
    )
    isCollateralOwnershipAssigned: bool | None = Field(
        None,
        description='True indicates that there is a loan against the policy (i.e. the policyowner has used the policy as collateral in order to secure a loan). If the insured dies before the loan is repaid, the lender can collect the outstanding balance from the death benefit of the life insurance policy.',
        example=True,
    )
    currentInterestRate: NonNegativePercent | None = Field(
        None,
        description='The interest rate that the policy currently pays at, as a percentage. This value may change over time.',
    )
    paidThroughDate: DateTime | None = Field(
        None,
        description='The date through which the policy is paid for (i.e. the date on which a new premium will be due).',
    )
    mortalityPaidThroughDate: DateTime | None = Field(
        None,
        description='A date recalculated by the carrier on a month-by-month basis that indicates whether the policy has enough cash value and/or premium applied to pay the cost-of-insurance into the next month. Some carriers may use this field to indicate when a policy is valid into the next month.\n',
    )
    currentPlanLapseDate: DateTime | None = Field(
        None,
        description="The date on which a policy is expected to lapse if a policyowner continues to make monthly premium payments that _fall short_ of the monthly cost of insurance. In such situations the remaining monthly cost is deducted from the policy's `cashValue`, leading the policy to lapse once that cash value is depleted. This `currentPlanLapseDate` is only provided when the client is making partial premium payments.",
    )
    noPremiumLapseDate: DateTime | None = Field(
        None,
        description="The date on which a policy is expected to lapse if the policyowner has _completely stopped paying premiums on the policy_, and is instead using the policy's `cashValue` to pay the policy's premiums. This `noPremiumLapseDate` is only provided when the client has stopped making premium payments.",
    )
    deathBenefitOption: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of a particular set of stipulations for the death benefit, or the way in which the death benefit on the policy is configured.',
    )
    isDeathClaim: bool | None = Field(
        None,
        description='True indicates that there is currently a death claim against the policy.',
        example=True,
    )
    isDeficientOrDelinquent: bool | None = Field(
        None,
        description='True indicates that the policyowner has made a payment which falls short of the full amount due (deficient), has failed to make a payment (delinquent), or both.',
        example=True,
    )
    isDisabilityClaim: bool | None = Field(
        None,
        description='True indicates that there is currently an active disability claim against the policy.',
        example=True,
    )
    loan: Loan | None = None
    lastDateToPayPremium: DateTime | None = Field(
        None,
        description='The hard deadline (often after a grace period has passed) by which the policyowner must pay the premium. If the policyowner fails to pay the premium on or before this date, the policy will lapse out.',
    )
    mostRecentPayment: MostRecentPayment | None = Field(
        None, description='The most recent premium payment received by the carrier.'
    )
    nonCommissionablePolicyFee: NonNegativeMonetaryAmount | None = Field(
        None,
        description='A non commissionable policy fee is the amount of money that is included in the premium that goes to cover the application processing costs. This fee is not commissioned to the Agent.',
    )
    isModifiedEndowmentContract: bool | None = Field(
        None,
        description='True indicates that this is a Modified Endowment Contract (i.e. a life insurance policy that has permanently lost its tax benefits because it contains too much cash). When the `cashValue` of a policy exceeds federal tax limits, the IRS relabels the policy as a Modified Endowment Contract (MEC), removing tax benefits for withdrawals and loans.',
    )
    nextDraftDate: DateTime | None = Field(
        None,
        description="The date the policyowner has chosen for funds to be electronically withdrawn from their bank account in order to pay the policy's premium. Only applicable when the `paymentMethod` for the policy is electronic funds transfer (EFT). _Note that this is different from they day on which the premium is due, or the `paidThroughDate`._",
    )
    oldPolicyNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The former policy number for this policy. If this policy was transferred over, or otherwise originated from a previous policy with a different policy number, the original policy number can be stored here.',
        example='123-555-5555',
    )
    policyAge: Duration | None = Field(
        None, description='The length of time the policy has been inforce.'
    )
    policyFee: NonNegativeMonetaryAmount | None = Field(
        None,
        description='A policy fee is the amount of money that is included in the premium that goes to cover the application processing costs.',
    )
    premiumToKeepPolicyActive: MonetaryAmount | None = Field(
        None,
        description='The amount of money necessary, as a premium, to keep the policy inforce. Typically seen on Cash Value policies.',
    )
    baseCoveragePremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The premium needed to keep the base policy inforce minus any of the rider coverages that have been added to the policy.',
    )
    surrenderCharge: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money that is charged in penalties, should the policyowner cancel the policy in order to withdraw money early/before an agreed upon date. `surrenderCharge` is typically calculated as a percentage, and varies from state to state.',
    )
    surrenderValue: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money that a policyowner would be able to withdraw, should they cancel the policy early/before an agreed upon date. _Note that `surrenderValue` = `cashValue` - `surrenderCharge`._',
    )
    termConversionDate: DateTime | None = Field(
        None,
        description='The last day to convert a term policy into a permanent policy. Often referred to as the term conversion expiration date.',
    )
    totalPremiumPaid: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money paid in premium over the lifetime of the policy.',
    )
    totalWithdrawals: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money ever withdrawn from the policy. Differs from `yearToDateWithdrawals` in that this value is cumulative over the lifetime of the policy.',
    )
    cashValueDate: DateTime | None = Field(
        None,
        description='The "as of" date for when the current `cashValue` was calculated by the carrier.',
    )
    cashValueHistory: list[CashValueHistoryItem] | None = Field(
        None,
        description="A collection of line-items of the account's total cash value at different points in time.",
        max_items=32768,
        min_items=0,
    )
    isSuspendIndicator: bool | None = Field(
        None, description='True indicates that the policy is Suspended.', example=True
    )


class PayoutSchedule(BaseModel):
    class Config:
        extra = Extra.forbid

    numberOfPaymentsExpected: conint(ge=0) | None = Field(
        None,
        description='The total number of times the annuitant/insured is expected to receive a payout.',
        example=5,
    )
    method: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The method by which payouts are transferred to the annuitant/insured (e.g. via EFT, check, etc.).',
        example='EFT',
    )
    installmentAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The dollar amount paid out to the annuitant/insured in a given installment. The frequency at which this `installmentAmount` is disbursed is noted in the `frequency` property.',
    )
    startDate: DateTime | None = Field(
        None, description='The date on which payouts from the policy/annuity began.'
    )
    nextDate: DateTime | None = Field(
        None, description='The next date on which a payout will be made.'
    )
    mostRecentDate: DateTime | None = Field(
        None, description='The most recent date on which a payout was made.'
    )
    frequency: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The frequency at which money is paid out to the annuitant/insured (e.g. Monthly, Quarterly, Semi-annually, or Annually).',
        example='Monthly',
    )
    type: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The way in which installments are scheduled to be paid out to the annuitant/insured (e.g. systematic withdrawals, required minimum distribution payments, a one-time withdrawal, etc).',
        example='systematic withdrawals',
    )


class Annuity(Policy):
    class Config:
        extra = Extra.allow

    annuityValue: MonetaryAmount | None = Field(
        None, description='The amount of money of the annuity is currently worth.'
    )
    costBasisAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The original amount of money put into the annuity. \n\nNote: this value can be recalculated for various reasons (e.g. adding more money to the `annuityValue` on an anniversary may cause the value of `costBasisAmount` to be recalculated).\n',
    )
    cumulativePremiumAmount: NonNegativeMonetaryAmount | None = Field(
        None, description='The total premium paid into this annuity over time.'
    )
    currentValue: MonetaryAmount | None = Field(
        None,
        description='The total amount of money in the annuity, including any interest received over time.',
    )
    excludableAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of annuity payment that can be excluded from taxes using the annuitants exclusion allowance.',
    )
    guaranteedMinimumInterestRate: NonNegativePercent | None = Field(
        None,
        description='The lowest interest rate that can be applied to the annuity. Also referred to as the "floor" interest rate.',
    )
    grossDistributionAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The full amount of money to be distributed from the annuity, before any fees and/or taxes have been taken out.',
    )
    guaranteedWithdrawalBenefit: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money that the contract guarantees can be withdrawn over a particular period of time.',
    )
    marketValueAdjustment: NonNegativeMonetaryAmount | None = Field(
        None,
        description='A fee that can be applied in the event of an early withdrawal that violates contract terms.',
    )
    minimumDistribution: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The minimum dollar amount that the annuitant/insured is required to withdraw during the payout period.',
    )
    payoutSchedule: PayoutSchedule | None = Field(
        None,
        description='An assortment of data representing how annuity payments and withdrawals occur over time.\n',
    )
    purchaseDate: DateTime | None = Field(
        None,
        description='The date on which the annuity was bought or purchased by the policyowner. Sometimes referred to as "signed date", because it is when the policyowner signs the paperwork agreeing to make the purchase.',
    )
    qualificationType: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A category indicating how taxes may or may not be applied to the contract once it is inforce (e.g. Qualified, Not Qualified, IRA, Roth IRA, etc).',
        example='Qualified',
    )
    yearToDateWithdrawals: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money that has been withdrawn from the policy or annuity since the beginning of the current year. This value is sometimes important for policyowner tax purposes.',
    )
    currentYearContributions: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money paid into the policy/annuity since the beginning of the current year.',
    )
    previousYearContributions: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money paid into the policy/annuity during the calendar year prior to this one.',
    )
    yearEndInterestRate: confloat(ge=0.0, le=100.0) | None = Field(
        None,
        description='The interest rate at which the policy is contractually obligated to pay for the duration of a calendar year. Note that this calendar year ends on the `yearEndInterestRateDate`.',
        example=50.5,
    )
    yearEndInterestRateDate: DateTime | None = Field(
        None,
        description='The date on which the calendar year duration for a particular `yearEndInterestRate` ends.',
    )


class Life(Policy):
    class Config:
        extra = Extra.allow

    costOfInsurance: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money required to keep the policy active/inforce, per billing cycle (i.e. the portion of the `modalPremium` that pays for the policy to stay inforce, as opposed to fees, etc).',
    )
    modalFactor: NonNegativePercent | None = Field(
        None,
        description='A percentage that the insurance carrier uses to determine the premium to be paid when the mode is something other than Annual.  It is an increase of the overall premium by a modalFactor percent to cover the costs associated with the increased premium frequency.',
    )
    specifiedAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The value of the death benefit, as written on the application when the policy was purchased. `specifiedAmount` remains constant regardless of how the actual value of `deathBenefit` may change over time.',
    )
    target: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The premium amount that is applied to the agents first year commission rate. Any premium that is not considered `target` but is paid by the insured is considered `excess`.',
    )
    termDuration: Duration | None = Field(
        None,
        description='The length of time for which a Term policy remains valid. Only applies to Term business. Typically this duration is reported in years (e.g. the Term policy may be valid for 10 years, 15 years, 20 years).',
        example='P20Y',
    )


class ReasonForCommission(Enum):
    Base = 'Base'
    Rider = 'Rider'
    Trail = 'Trail'
    Excess = 'Excess'


class TransactionType(Enum):
    Credit = 'Credit'
    Debits = 'Debits'
    Clawbacks = 'Clawbacks'
    ChargeBack = 'ChargeBack'
    Manual_Activity = 'Manual Activity'
    Trails = 'Trails'
    Premium_Payment = 'Premium Payment'


class Commission(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID = Field(
        ..., description='A unique identifier for an individual commission transaction.'
    )
    statementDate: DateTime | None = Field(
        None,
        description='The date on which the commissions statement containing this transaction was issued. \n\nMany transactions can be rolled into a single statement, which is why `statementDate` may be different than `transactionDate`.\n',
    )
    totalCheckAmount: MonetaryAmount | None = Field(
        None,
        description='The sum total of all transactions included on the commissions statement that this commission transaction is part of.',
    )
    comment: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A field to store additional information needed to explain something about the individual commissions transaction. The carrier can choose how they would like to delineate between this field and `description`.',
        example='Bonus for 2023 Quarters 1 & 2.',
    )
    description: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A second field to store additional information needed to explain something about the individual commissions transaction. The carrier can choose how they would like to delineate between this field and `comment`.',
        example='Override on policies between 1/1/2022 - 3/31/2022.',
    )
    reasonForCommission: ReasonForCommission | None = Field(
        None,
        description='The basis or reason why this commission came to exist (i.e. the way in which the commission was calculated). Sometimes referred to as "commission type". \n \n For example, if the commission is calculated from a rider\'s premium, the value of this field is "Rider".\n',
        example='Base',
    )
    transactionType: TransactionType | None = Field(
        None,
        description='The method of exchange taking place between the agent and the insurance company involved in this commission transaction.\n\n```Credit```, ```Manual Activity```, ```Premium Payment``` and ```Trails``` are transaction types where the insurance company transfers money to the agent. These transactions have a positive `amount` value.\n\n```ChargeBack``` , ```Clawback```, and ```Debits``` are ways in which the insurance company reclaims money from the agent. These transactions have a negative `amount` value.\n',
        example='Credit',
    )
    transactionDate: DateTime | None = Field(
        None,
        description='The date on which the carrier recorded this commission transaction in their system of record. \n \n This date may be different from the `processedDate`, which is when the payee receives (or, for a negative `amount`, is requested to pay) the money exchanged in this commission transaction.\n',
    )
    processedDate: DateTime | None = Field(
        None,
        description="The date on which the carrier gathers together, processes, and generates statement(s) for the group of transactions that this transaction is part of. \n \nThis date may be different than the `transactionDate` because the carrier may not pay the agent on the same day that the commission is recorded in the carrier's system of record.\n",
    )
    amount: MonetaryAmount | None = Field(
        None,
        description='The total amount of money the `payee` receives for this commission transaction (as opposed to the `totalCheckAmount` on the statement). \nThis dollar amount is usually positive, but can be negative (e.g. for clawbacks or charge backs).',
    )
    percentageSplit: NonNegativePercent | None = Field(
        None,
        description='The portion of the overall commission `amount` that the `payee` receives, as a percentage. \nFor example, if the `payee` on this commission transaction receives 40% of the commission, this value will be 40.\nIf there is only one writing agent on the case, this value is 100.',
    )
    payee: Person | Company | None = Field(
        None, description='The agent or company who is getting paid on this commission.'
    )
    writingAgent: Person | None = Field(
        None,
        description='The original writing agent on the case associated with this commission.',
    )
    client: Person | None = Field(
        None, description='The client of the policy associated with this commission.'
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the insurance company that is involved in this commission transaction.',
        example='Carrier Name',
    )
    isFirstYear: bool | None = Field(
        None,
        description='True indicates that this is a first-year commission (i.e. this commission transaction is taking place during the first year of policy). \nFalse indicates that this commission transaction is for a renewal year.',
        example=False,
    )
    premiumAmount: MonetaryAmount | None = Field(
        None,
        description='The amount of money paid in the premium that was used to calculate this commission (i.e. the same premium that was used to determine the `commissionType`).',
    )
    premiumDueDate: DateTime | None = Field(
        None,
        description='The due date for the premium which this commission transaction is based on.',
    )
    monthsPaidFor: float | None = Field(
        None,
        description='The number of months that the `premiumAmount` pays for. \n\n  This value may not align with the `mode`. For example, the policy may be a monthly mode but the insured\nmay have made 2 monthly payments combined into a single transaction. In this case, the `mode` would be monthly but the `monthsPaidAmount` would represent two months worth of premium money.',
        example=2,
    )
    mode: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The frequency at which the policyowner is be expected to pay the premium on the policy associated with this commission statement (e.g. Monthly, Quarterly, Semi-annually, or Annually).',
        example='Monthly',
    )
    rateToBePaid: NonNegativePercent | None = Field(
        None, description='The percentage used to calculate the commission `amount`.'
    )
    paidThroughDate: DateTime | None = Field(
        None,
        description='The date through which the policy is paid for (i.e. the date on which a new premium will be due).',
    )
    firstYearCommissionAmount: MonetaryAmount | None = Field(
        None,
        description='The portion of this commission transaction `amount` that can be attributed to first year commission.',
    )
    renewalCommissionAmount: MonetaryAmount | None = Field(
        None,
        description='The portion of this commission transaction `amount` that can be attributed to a renewal year commission. This value is often much less than the `firstYearCommissionAmount`.',
    )
    trailCommissionAmount: MonetaryAmount | None = Field(
        None,
        description='The portion of this commission transaction `amount` that can be attributed to trail commissions.',
    )
    feesApplied: MonetaryAmount | None = Field(
        None,
        description='The non-commissionable fees that are removed from the overall commission before paying the `payee`.',
    )
    uplineRate: NonNegativePercent | None = Field(
        None,
        description='The percentage used to calculate the money paid to an agent or agency that is "upline" from the `payee` (i.e. the person above the `payee` in an agent hierarchy). May also known as an "override" percentage. \nThis rate may be a percentage of a premium, of the `payee`\'s commission, or of something else.',
    )
    uplineCommission: MonetaryAmount | None = Field(
        None,
        description='The amount of money paid to an agent or agency that is "upline" from the `payee` (i.e. the person above the `payee` in an agent hierarchy). May also known as an "override" amount.',
    )
    totalPaidCommission: MonetaryAmount | None = Field(
        None,
        description='A running total for the amount of money paid in commissions to the `payee` associated with this transaction, over the lifetime of a the policy this transaction is associated with.',
    )
    totalYTDCommissionPaid: MonetaryAmount | None = Field(
        None,
        description='The total year-to-date commission paid to the agent receiving this statement.',
    )
    totalYTDFirstYearCommissionPaid: MonetaryAmount | None = Field(
        None,
        description='A running total for the amount of money made in commissions for this `payee` since the beginning of the year, during the first year of the policy this transaction is associated with.',
    )
    totalYTDRenewalCommissionPaid: MonetaryAmount | None = Field(
        None,
        description='A running total for the amount of money made in commissions for this `payee` since the beginning of the year, during a renewal year (i.e. any year besides the first year of the policy).',
    )
    policySnapshot: Annuity | Life | None = Field(
        None,
        description='A snapshot of the policy associated with the commission transaction.',
    )
    status: str | None = Field(
        None, description='The status of the commission transaction', example='Pending'
    )


class CommissionStatement(BaseModel):
    class Config:
        extra = Extra.forbid

    documentID: ID | None = Field(
        None, description='A unique identifier for the PDF version of this statement.'
    )
    date: DateTime | None = Field(
        None, description='The date that the statement was issued.'
    )
    payee: Person | Company | None = Field(
        None,
        description='The person or company receiving (for a positive `amount`) or requested to pay (for a negative `amount`) the money accounted for in this commission statement.\n',
    )
    amount: MonetaryAmount | None = Field(
        None,
        description="The total amount of money that is either deposited into the `payee`'s bank account (in the case of a positive value) or requested from the `payee` (in the case of a negative value) as a result of this commission statement.",
    )


class BaseTrust(BaseModel):
    class Config:
        extra = Extra.allow

    name: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The legal name of the trust.', example='SureCo'
    )
    establishedDate: DateTime | None = Field(
        None,
        description='The date that the trust came into existence as a legally recognized entity.',
    )
    addresses: list[Address] | None = Field(
        None,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )
    governmentIDNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A government-issued identification number used for taxation and/or or legal identification purposes (e.g. social security number).',
        example='365-86-8526',
    )
    isIrrevocable: bool | None = Field(
        None,
        description='True indicates that this trust cannot be modified after it is created without the explicit consent of its beneficiaries.',
    )
    state: State | None = None


class Type5(Enum):
    Trust = 'Trust'


class Trust(BaseTrust):
    ID: ID | None = Field(None, description='A unique identifier for this contact.')
    type: Type5 | None = None
    trusteeIDs: list[ID] | None = Field(
        None,
        description='A collection of the full contact records for the people and/or organizations legally responsible for managing the trust and its assets.',
        max_items=32768,
        min_items=0,
    )
    grantorContactID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the individual or legal entity (such as a company or organization) that establishes the trust and transfers assets into it. The grantor defines the terms under which the trust operates.',
    )
    finalBeneficiaryContactID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the individual or legal entity (such as a company, nonprofit, or organization) that ultimately receives the remaining assets of the trust once all trust obligations are fulfilled.',
    )


class BaseEstate(BaseModel):
    name: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The legal name of the estate.', example='Estate of John Doe'
    )
    executorContactID: ID | None = Field(
        None,
        description="A pointer to the full contact record of the executor who is designated to manage the estate after the policyowner's passing",
    )
    governmentIDNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A government-issued identification number used for taxation and/or or legal identification purposes (e.g. tax identification number).',
        example='12-3456789',
    )
    addresses: list[Address] | None = Field(
        None,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )


class Type6(Enum):
    Estate = 'Estate'


class Estate(BaseEstate):
    ID: ID | None = Field(None, description='A unique identifier for this contact.')
    type: Type6 | None = None


class BaseCharity(BaseModel):
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The legal name of the charity.',
        example='Helping Hands Foundation',
    )
    addresses: list[Address] | None = Field(
        None,
        description='A collection of addresses for this charity.',
        max_items=32768,
        min_items=0,
    )
    isGovernedByBoardOfDirectors: bool | None = Field(
        None,
        description="True indicates that this charity is being governed by a board of directors (a group of individuals) who are responsible for overseeing the charity's operations, ensuring compliance with legal requirements, and making strategic decisions.",
    )


class Type7(Enum):
    Charity = 'Charity'


class Charity(BaseCharity):
    ID: ID | None = Field(None, description='A unique identifier for this contact.')
    type: Type7 | None = None


class Document(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID = Field(..., description='A unique identifier for the document.')
    title: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A short phrase explaining the purpose of the document, or what the document is used for.',
    )
    documentNumber: str | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify the given document.',
        example='20LAS',
    )
    categoryIDs: list[Any] | None = Field(
        None,
        description='A collection of unique identifiers for the categories to which this document belongs to.',
        example=['4b33ae9e-827a-479d-b60c-8daa2873c08c'],
        max_items=32768,
        min_items=0,
    )
    filename: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the file as seen by the user, should they download the file. Includes a file extension.',
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the insurance carrier that supplies this document (may be a subsidiary within a larger carrier).',
    )
    carrierLastUpdated: DateTime | None = Field(
        None,
        description='The timestamp indicating when the document was last updated by the carrier.',
    )
    states: list[State] | None = Field(
        None,
        description='The states in which this document is applicable, valid, registered, etc.',
        example=['CA', 'AK'],
        max_items=255,
        min_items=0,
    )
    versionID: ID | None = Field(
        None, description='A unique identifier for a given form version .'
    )
    isOrderable: bool | None = Field(
        None,
        description='True indicates that the user can order the hard copy of the document.',
    )
    isArchived: bool | None = Field(
        None,
        description='True indicates that the document is archived. False indicates active.',
    )
    editionDate: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The month and year this edition of the document was published.',
        example='05/24',
    )


class DocumentCategory(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID = Field(
        ...,
        description='A unique identifier for the category to which this document belongs to.',
    )
    parentID: ID | None = Field(
        None,
        description='A unique identifier for the parent category of this category (i.e. the category that this category is nested beneath).',
    )
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the category a document belongs to. This can be a high level category or a sub-category.',
        example='Policy Service Forms',
    )
    description: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A short phrase explaining the purpose of the document category, or what the category is used for.',
    )


class FinancialActivity(BaseModel):
    class Config:
        extra = Extra.forbid

    date: DateTime | None = Field(
        None, description='The date on which this financial activity occurred.'
    )
    rate: Percent | None = Field(
        None,
        description='The rate that changed on the `date` of this  activity. \n\nThis field is only applicable if this financial activity is for a rate change. Examples include, but are not limited to: interest rates.\n',
        example=0.0345,
    )
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the activity (i.e. shorthand to explain why a value on the policy changed). \n\n Examples include, but are not limited to: Initial premium, EFT premium, Feature change, Guaranteed minimum interest rate, etc.).\n',
    )
    amount: MonetaryAmount | None = Field(
        None,
        description='The monetary value change that occurred on the `date` of this  activity. \n\nThis field stores the actual monetary value change for any activity that is NOT a rate change. Examples of financial activities resulting in `amount` changes include, but are not limited to: loan repayments, annual fees, premium payments, etc. \n\nNote: When the financial activity is a premium payment, the value of `amount` is the equal to the value of `premiumAmount`.\n',
    )
    grossAmount: MonetaryAmount | None = Field(
        None,
        description='The total `amount` for the activity _before_ the removal of any deductions, fees etc.\n',
    )
    netAmount: MonetaryAmount | None = Field(
        None,
        description='The total `amount` _after_ the removal of any deductions, fees, etc.\n',
    )
    premium: MonetaryAmount | None = Field(
        None,
        description='The amount of money being paid as premium on the policy, on the `date` of this financial activity. \n\n Note: this field does NOT represent the monetary value change for this financial activity -- that value is stored in the `amount` field. However, when the financial activity is a premium payment, the value of this field is equal to the value of `amount`.\n',
    )
    mode: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The frequency at which the policyowner pays the `premium` on the policy (e.g. monthly, quarterly, semi-annually, etc.).\n',
        example='Monthly',
    )
    policyID: ID | None = Field(
        None,
        description='A pointer to the case and/or policy that this financial activity is associated with.',
    )
    paymentMethodID: ID | None = Field(
        None,
        description='A pointer to the payment method that this financial activity is associated with.',
    )
    status: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The payment status of the transaction. Examples include, but are not limited to paid, success, failed, processing.',
        example='processing',
    )


class FundAllocation(BaseModel):
    class Config:
        extra = Extra.forbid

    policyID: ID | None = Field(
        None,
        description='A pointer to the case and/or policy that the funds are associated with.',
    )
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the fund (i.e. the name used when marketing the fund).',
        example='S&P 500',
    )
    disclaimer: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The legalese that accompanies a given fund, meant to protect the business entity administering the\nfund against any unwanted claims or liability.\n',
        example='These are products of S&P Dow Jones Indices, LLC, a division of S&P Global, or its affiliates ("SPDJI") and has been licensed for use by SureCo. Standard & Poor\'s and S&P are registered trademarks of Standard & Poor\'s Financial Services LLC, a division of S&P Global ("S&P"); Dow Jones is a registered trademark of Dow Jones Trademark Holdings LLC ("Dow Jones")',
    )
    amount: NonNegativeMonetaryAmount | None = Field(
        None, description='The total amount of money tied to an individual fund.'
    )
    allocationPercent: NonNegativePercent | None = Field(
        None,
        description='The percentage of new money being paid into the policy that should be invested in this fund, NOT a historical purchasing percentage.\n',
    )
    allocationDate: DateTime | None = Field(
        None,
        description="The date on which the amount of money allocated to this fund was last updated in the carrier's system of record.",
    )
    rate: Percent | None = Field(
        None,
        description='The interest rate of the fund during the time period covered by the crediting strategy.',
    )
    rateDate: DateTime | None = Field(
        None,
        description="The date on which the rate of this fund was last updated in the carrier's system of record.",
    )


class Capability(BaseModel):
    __root__: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A capability that this user is authorized to.',
        example='Policy',
    )


class OwnerType(Enum):
    person = 'person'
    agent = 'agent'
    company = 'company'
    carrier = 'carrier'


class Keycard(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID | None = Field(None, description='A unique identifier for this keycard.')
    contactID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the person or organization to which this keycard is assigned.',
    )
    keycardNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify this keycard.',
    )
    name: Name | None = Field(
        None,
        description='The name of the person or organization to which this keycard is assigned. For organizations, use the `fullName` option.',
    )
    ownerType: OwnerType | None = Field(
        None, description='The type of the keycard owner.', example='company'
    )
    capabilities: list[Capability] | None = Field(
        None,
        description='A collection of permissions that this keycard is authorized to.',
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The carrier that the keycard is affiliated with.',
        example='SureCo',
    )


class Author(BaseModel):
    class Config:
        extra = Extra.forbid

    name: Name | None = Field(None, description='The name of the author.')
    contactID: ID | None = Field(
        None, description='A pointer to the full contact record for the author.'
    )


class Note(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID | None = Field(None, description='A unique identifier for the note.')
    policyID: ID | None = Field(
        None,
        description='A pointer to the case and/or policy that this note is associated with.',
    )
    author: Author | None = Field(
        None,
        description='The person who wrote the note `content` and attached the `Note` to the case or policy.',
    )
    noteAddedDate: DateTime | None = Field(
        None,
        description='The date or timestamp when the `Note` was written or modified.\n',
    )
    title: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A brief description of the `Note`.',
        example='Client signature required',
    )
    content: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The text that makes up the body of the `Note`.',
        example='This application was received via paper and was missing signatures.  It has been returned for completion.',
    )
    isPrivate: bool | None = Field(
        None, description='True indicates that this note is only visible to the author.'
    )
    isEditable: bool | None = Field(
        None,
        description='True indicates that this note was created in a client built against the CoreCONNECT platform, such as a web application (e.g. LifetimeSERVICE or LifetimeAGENT), mobile application, etc.',
    )


class CreditCard(BaseModel):
    processingNetwork: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The name of the company responsible for processing any transactions that are made with this credit or debit card (e.g. Visa, Mastercard, American Express, etc.)',
        example='Visa',
    )
    cardNumber: constr(min_length=1, max_length=19) | None = Field(
        None,
        description='A masked version of the credit or debit card number. Used to identify the card.',
        example='****-****-****-1234',
    )
    expirationDate: DateTime | None = Field(
        None,
        description='The day on which this credit/debit card can no longer be used.',
    )
    accountHolderName: Name | None = Field(
        None,
        description='The name of the person or organization who owns this credit/debit card. If this credit/debit card belongs to an organization, use the `fullName` option.',
    )
    address: Address | None = Field(
        None,
        description='The address that is used for billing with this credit/debit card.',
    )


class BankAccountNumber(BaseModel):
    __root__: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The account number for a bank account.',
        example='6541-5421-1564-8157',
    )


class Type8(Enum):
    checking = 'checking'
    savings = 'savings'


class BankAccount(BaseModel):
    class Config:
        extra = Extra.forbid

    accountHolderName: Name | None = Field(
        None,
        description='The name of the person or organization to whom this bank account or check belongs. If this bank account belongs to an organization, use the `fullName` option.',
    )
    bankName: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The name of the bank where the bank account is held.'
    )
    type: Type8 | None = Field(
        None, description='The kind of bank account this is (i.e. checking or savings).'
    )
    accountNumber: BankAccountNumber | None = Field(
        None, description='A masked bank account number.', example='***9054'
    )
    routingNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The routing number for this bank account.',
        example='082000073',
    )


class AmountOption(Enum):
    Custom = 'Custom'
    Minimum = 'Minimum'
    Balance = 'Balance'


class AutopaySetup(BaseModel):
    class Config:
        extra = Extra.forbid

    dayOfMonth: conint(ge=1, le=31) | None = Field(
        None,
        description='The day of the month on which each automatically recurring payment is processed.',
    )
    amountOption: AmountOption | None = Field(
        None,
        description='The automatic payment option chosen by the payer. Dictates how much money is sent in each automatically recurring payment.\n | Enum | Amount of money sent in each payment |\n |--------------------------|----------------------------|\n | `custom` | An arbitrary amount (set by the payer) |\n | `minimum` | The lowest possible amount required to keep the account in good standing |\n | `balance`  | The amount owed at the time of payment |\n',
    )
    amount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money sent in each automatically recurring payment. This field is only used when the payer has `amountOption` set to  `custom`.',
    )


class PaymentMethod1(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID = Field(..., description='A unique identifier for this payment method.')
    paymentForm: str | None = Field(
        None,
        description="different types of payment forms.\n'creditcard' - a credit card payment form.\n",
    )
    isDefault: bool | None = Field(
        None,
        description='True indicates that this payment method is automatically used for a given policy, unless issues arise, or unless the payor specifies an alternative payment method to be used for a particular transaction.\n',
    )
    policyID: ID | None = Field(
        None,
        description='A pointer to the case and/or policy that this payment method is associated with.',
    )
    effectiveDate: DateTime | None = Field(
        None,
        description='The first day that this payment method is (allowed to be) used.\n',
    )
    endDate: DateTime | None = Field(
        None,
        description='The last day that this payment method is (allowed to be) used. \nDo not provide a value for this field if this payment method is expected to be used indefinitely.',
    )
    formOfPayment: CreditCard | BankAccount | None = Field(
        None,
        description='The credit/debit or bank account information needed to process a payment with this payment method.\n',
    )
    autopaySetup: AutopaySetup | None = Field(
        None,
        description='The information needed to set up automatically recurring payments. \nMissing values indicate that automatically recurring payments are not enabled for this payment method.',
    )


class License(BaseModel):
    class Config:
        extra = Extra.forbid

    agentID: ID | None = Field(
        None,
        description='A pointer to the full contact record of the agent to whom this license belongs.',
    )
    status: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The current status this license, in relation to its legal validity (e.g. current, pending, or expired).',
        example='pending',
    )
    isResidentialLicense: bool | None = Field(
        None,
        description="True indicates that this is an agent's residential license (i.e. the one that allows the agent to sell insurance in the state where they live).",
    )
    licenseNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The state-assigned license number (i.e. a combination of letters and numbers that the state government uses to uniquely identify the license).',
    )
    effectiveDate: DateTime | None = Field(
        None, description='The date on which the license was issued.'
    )
    expirationDate: DateTime | None = Field(
        None, description='The date on which the license expires.'
    )
    state: State | None = Field(
        None, description='The state for which the license was issued.'
    )


class Status(Enum):
    Open = 'Open'
    Application_Received = 'Application Received'
    Closed = 'Closed'


class ProposedClient(Person):
    class Config:
        extra = Extra.allow

    age: Duration | None = Field(
        None,
        description='The age of the `proposedClient` at the time that the quote/illustration was run. \n\nThis value is less precise than `DOB` (date of birth). Generally, a quote has either the `currentClientAge` or `DOB` but not both.\n',
    )
    heightInInches: confloat(ge=0.0) | None = Field(
        None, description="The `proposedClient`'s height in inches.", example=70.5
    )
    weightInPounds: confloat(ge=0.0) | None = Field(
        None, description="The `proposedClient`'s weight in pounds.", example=195.5
    )


class QuoteIllustrationBase(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID | None = Field(
        None, description='A unique identifier for this quote or illustration.'
    )
    runDate: DateTime | None = Field(
        None,
        description='The date on which this quote or illustration was run (i.e. calculated by the quote/illustration preparation system).',
    )
    documentID: ID | None = Field(
        None,
        description='A pointer to the document version of this quote or illustration.',
    )
    status: Status | None = Field(
        None,
        description='The current status of this quote or illustration. \n    \nIndicates how far along this quote/illustration is in the process of becoming a case.\n',
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The insurance company that ran this quote or illustration.\n',
        example='SureLife',
    )
    agentID: ID | None = Field(
        None,
        description='A pointer to the unique identifier for the agent who is selling the product featured in this quote or illustration.',
    )
    productID: ID | None = Field(
        None,
        description='A pointer to the unique identifier for the product requested in this quote or illustration.',
    )
    caseID: ID | None = Field(
        None,
        description='A pointer to the case that this quote or illustration is a precursor to, should the quote/illustration be successfully converted into a case.',
    )
    proposedClient: ProposedClient | None = Field(
        None,
        description='The person for whom this quote/illustration was prepared (i.e. the person requesting insurance coverage).',
    )
    rateClass: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A category indicating the overall health of the `proposedClient` (e.g. Preferred Non Smoker, Preferred Plus, Standard, etc).  Rate class has a direct impact on the price of the life insurance policy.',
        example='Preferred Non Smoker',
    )
    modalPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money the `proposedClient` will pay in premium when they receive their bill, should they select this quote. \n\nThe frequency at which the `proposedClient` will pay the `modalPremium` is called the `paymentMode`.\n',
    )
    paymentMode: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The frequency at which the `proposedClient` will be expected to pay the premium on their policy (e.g. Monthly, Quarterly, Semi-annually, or Annually), should they select this quote. \n\nNote: The amount of money payable each time the `proposedClient` receives their bill is the called the `modalPremium`.\n',
        example='Monthly',
    )
    faceAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The quoted amount of money paid out to the beneficiary when the insured dies. Typically used on Term policies (as opposed to Universal Life, Whole Life, or Annuity policies). Sometimes referred to as death benefit.',
    )
    deathBenefit: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The quoted amount of money paid out to the beneficiary when the insured or annuitant dies. Typically used in Whole Life, Universal Life, or Annuities (as opposed to Term Life).\n\n`deathBenefit` may differ from `faceAmount` in that `deathBenefit` may change over time, while `faceAmount` stays the same over the lifetime of a policy. The value of `deathBenefit` often changes because adjustments (e.g. the accrual of interest) are made to it over the lifetime of the policy.\n',
    )


class Requirement(BaseModel):
    class Config:
        extra = Extra.forbid

    ID: ID | None = Field(None, description='A unique identifier for this requirement.')
    caseID: ID | None = Field(
        None,
        description='A pointer to the case that this requirement is associated with.',
    )
    name: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The name of the requirement (i.e. the task that must be completed).\n',
    )
    comment: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The additional information needed to understand or appropriately complete the requirement.\n\nFor example, if the requirement is a Blood Test, the `comment` may say,  Must fast for 12 hours before this blood test.\n',
    )
    responsibleParty: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The individual or entity responsible for the completion of the task specified in this requirement. \nFor example, if the requirement is related to and issue with missing or inaccurate licensing information, the `responsibleParty` is the agent that has must provide accurate license information to the carrier.',
        example='agent',
    )
    requestedDate: DateTime | None = Field(
        None,
        description='The date on which the carrier sent out a notification requesting that this requirement be completed.',
    )
    scheduledDate: DateTime | None = Field(
        None,
        description='The date on which the task requested by the carrier is scheduled to be completed. \nFor example, if the requirement is a medical examination request,\nthe `scheduledDate` is the date of the insureds doctors appointment.\n',
    )
    receivedDate: DateTime | None = Field(
        None,
        description='The date on which the carrier receives evidence that the requirement has been completed.',
    )
    status: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The current status of the requirement (i.e. where the task is  on its journey towards completion). \n\nExamples include, but are not limited to: pending, scheduled, received, outstanding\n',
        example='pending',
    )
    statusDate: DateTime | None = Field(
        None,
        description='The date on which the `status` of this requirement was last updated by the carrier.',
    )
    blankFormID: ID | None = Field(
        None,
        description='A pointer to the blank copy of the form or questionnaire that must be filled out in order to fulfill this requirement.',
    )
    documentIDs: list[ID] | None = Field(
        None,
        description='A collection pointers to completed documents that are related to this requirement (e.g. filled-out questionnaires, medical records, etc.).',
        max_items=32768,
        min_items=0,
    )
    category: constr(min_length=1, max_length=32768) | None = Field(
        None,
        description='A category that is used to group requirements by how or when they are needed during the application process (e.g. Obtain At Delivery, Needed for Underwriting).',
    )


class Rider(BaseModel):
    name: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The name of the rider (e.g. Child Term Rider, Waiver of Premium, etc.).',
        example='Term Conversion Rider',
    )
    riderValue: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money that the rider is worth (as additional benefit). \n \n The `riderValue` can be different than the `faceAmount` of the base policy the rider is tied to.',
    )
    modalPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The amount of money the policyowner pays for the rider each time premium is due (at a frequency set by the `premiumMode`). `modalPremium` is only applicable for premium that is paid separately from the base policy premium. \n \n Note: this value is NOT applicable to inherent riders (i.e. riders that are include as part of the base policy).\n',
    )
    premiumMode: constr(min_length=1, max_length=255) | None = Field(
        None,
        description='The frequency at which the rider `modalPremium` is paid (e.g. Monthly, Quarterly, Annually, etc.). \n\nNote: this value is NOT applicable to inherent riders (i.e. riders that are included as part of the base policy).\n',
        example='Monthly',
    )
    annualPremium: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount of money that the policyowner pays in premium for the rider over the course of a year.',
    )
    status: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The current status of the rider. Examples include, but are not limited to: Cancelled, Active, Exercised, Inactive.\n\nThe status of a rider can be different from the status of the policy that it is attached to.\n',
        example='Active',
    )
    statusDate: DateTime | None = Field(
        None,
        description="The date on which the carrier most recently updated the rider's `status`.",
    )
    termConversionDate: DateTime | None = Field(
        None,
        description='The last day to convert a term rider into a permanent rider. Often referred to as the term conversion expiration date.',
    )
    eligibilityDate: DateTime | None = Field(
        None,
        description='The date on which when the rider is eligible to be exercised by the insured (i.e. when the insured can begin taking advantage of the additional coverage or benefits that the rider provides).',
    )
    policyID: ID = Field(
        ...,
        description='A pointer to the case and/or policy that this rider is tied to.\n',
    )
    contactIDs: list[ID] | None = Field(
        None,
        description='A collection of IDs for the full contact records for the people related to the rider.',
        max_items=32768,
        min_items=0,
    )


class PartyType(Enum):
    Agency = 'Agency'
    Carrier = 'Carrier'
    Producer = 'Producer'
    ConsumerPerson = 'ConsumerPerson'


class BoundParty(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(
        None, description='A pointer to the full contact record of this bound party.'
    )
    partyNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify this bound party.',
    )
    name: Name | None = Field(
        None,
        description='The name of the individual or organization this bound party belongs to. For organizations, use the `fullName` option.',
    )
    partyType: PartyType | None = Field(
        None,
        description='The type of individual or organization this bound party represents.',
        example='Agency',
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The carrier that this bound party is affiliated with.',
        example='SureCo',
    )


class User(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(None, description='A unique identifier for this user.')
    profilePartyID: ID | None = Field(
        None,
        description="A pointer to the full contact record containing information for this user's profile.",
    )
    name: Name | None = Field(
        None,
        description='The name of this user. For organizations, use the `fullName` option.',
    )


class LinkedParty(BaseModel):
    class Config:
        extra = Extra.allow

    ID: ID | None = Field(
        None, description='A pointer to the full contact record of this linked party.'
    )
    partyNumber: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='A combination of letters and numbers that the carrier uses to uniquely identify this linked party.',
    )
    name: Name | None = Field(
        None,
        description='The name of the individual or organization this linked party represents.',
    )
    partyType: PartyType | None = Field(
        None,
        description='The type of individual or organization this linked party represents.',
        example='Agency',
    )
    carrier: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The carrier that this linked party is affiliated with.',
        example='SureCo',
    )


class CaseSearchFields(Enum):
    ID = 'ID'
    caseNumber = 'caseNumber'
    accountNumber = 'accountNumber'
    status = 'status'
    productType = 'productType'
    productSubtype = 'productSubtype'
    product = 'product'
    paymentMode = 'paymentMode'
    carrierLastUpdated = 'carrierLastUpdated'
    effectiveDate = 'effectiveDate'
    faceAmount = 'faceAmount'
    modalPremium = 'modalPremium'
    annualizedPremium = 'annualizedPremium'
    costOfInsurance = 'costOfInsurance'
    commissionableAnnualizedPremium = 'commissionableAnnualizedPremium'
    deathBenefit = 'deathBenefit'
    client = 'client'
    agent = 'agent'
    agency = 'agency'
    riskClass = 'riskClass'
    carrier = 'carrier'
    statusCategory = 'statusCategory'
    dateCashReceived = 'dateCashReceived'
    cashReceived = 'cashReceived'
    isNIGO = 'isNIGO'


class PolicySearchFields(Enum):
    ID = 'ID'
    policyNumber = 'policyNumber'
    accountNumber = 'accountNumber'
    status = 'status'
    productType = 'productType'
    productSubtype = 'productSubtype'
    product = 'product'
    paymentMode = 'paymentMode'
    carrierLastUpdated = 'carrierLastUpdated'
    effectiveDate = 'effectiveDate'
    faceAmount = 'faceAmount'
    modalPremium = 'modalPremium'
    annualizedPremium = 'annualizedPremium'
    costOfInsurance = 'costOfInsurance'
    commissionableAnnualizedPremium = 'commissionableAnnualizedPremium'
    deathBenefit = 'deathBenefit'
    client = 'client'
    agent = 'agent'
    agency = 'agency'
    riskClass = 'riskClass'
    carrier = 'carrier'
    annuityValue = 'annuityValue'
    qualificationType = 'qualificationType'


class GlobalSearchFields(BaseModel):
    __root__: CaseSearchFields | PolicySearchFields


class Operator(Enum):
    empty = 'empty'
    notEmpty = 'notEmpty'


class ValueExistenceFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ...,
        description='The name of the field that the user chooses to filter against.\n',
    )
    operator: Operator = Field(
        ...,
        description='A logical operator to return records based on whether _any value exists_ in a user-specified field.\n\nFor example, the `empty` operator can be used to search for all records that do not have _any value_ in the `policyNumber` field .\n',
    )


class Operator1(Enum):
    startsWith = 'startsWith'
    endsWith = 'endsWith'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class StringComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ...,
        description='The name of the string field the user chooses to filter against.',
    )
    operator: Operator1 = Field(
        ...,
        description='A logical operator used to perform string comparison.\n\nFor example, the `contains` operator can be used to search for all records where the string "Abc123" appears somewhere within the `policyNumber` field.\n',
    )
    value: constr(min_length=1, max_length=32767) = Field(
        ..., description='The user-specified string to used to create the filter.'
    )


class Operator2(Enum):
    gt = 'gt'
    gte = 'gte'
    lt = 'lt'
    lte = 'lte'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class NumericComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ...,
        description='The name of the numeric field the user chooses to filter against.\n',
    )
    operator: Operator2 = Field(
        ...,
        description='A logical operator used to perform numeric comparison.\n\n  For example, the `lte` operator can be used to search for all records that have a value less than or equal to 10,000 the `policyNumber` field.\n',
    )
    value: float = Field(
        ..., description='The user-specified number used to create the filter.'
    )


class Operator3(Enum):
    after = 'after'
    before = 'before'
    onOrAfter = 'onOrAfter'
    onOrBefore = 'onOrBefore'


class DateComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ...,
        description='The name of the date field the user chooses to filter against.',
    )
    operator: Operator3 = Field(
        ...,
        description='A logical operator used for date comparison.\n\nFor example, the `before` operator can be used to search for all records that have date prior to Dec 31, 2000 in the `effectiveDate` field.\n',
    )
    value: constr(min_length=4, max_length=30) = Field(
        ...,
        description='The user-specified Date or DateTime value to create the filter in ISO 8601 format __without timezone__.\n\n**For Date-only filtering** (Properties that represent only a date, without a time component):\n- Format: \'YYYY-MM-DD\' (e.g., `2024-01-15`)\n- Compares only the date portion (year, month, day)\n- Ignores time component.\n\n**For DateTime filtering** (Properties that represent both a date and time):\n- Format: ISO 8601 string (e.g., `"2024-01-15T10:30:00.000"`)\n- Provides millisecond-precision filtering\n- Enables precise timestamp without timezone comparison.\n\nThe system automatically detects the format and applies the appropriate comparison logic.\n',
        example='2024-01-15',
    )


class Operator4(Enum):
    in_ = 'in'
    notIn = 'notIn'


class ListMembershipFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ..., description='The name of the field the user chooses to filter against.'
    )
    operator: Operator4 = Field(
        ...,
        description='A logical operator to check for membership within a collection of values.\n\nFor example, the `in` operator can be used to search for all records that have data in the `policyNumber` field that matches at least one of the `values` specified by the user.\n',
    )
    values: list[str | float] = Field(
        ...,
        description='The collection of user-specified values used to create the filter.\n\nFor example, if the user specifies 30 different policy numbers as different `values`, the filter will return only records with data in the`policyNumber` field that matches at least one of those 30 policy numbers.\n',
        max_items=32767,
        min_items=1,
    )


class Operator5(Enum):
    between = 'between'
    notBetween = 'notBetween'


class RangeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ..., description='The name of the field to compare the filter range against.'
    )
    operator: Operator5 = Field(
        ...,
        description='A logical operator user to check for whether records include a value within the user-specified range.\n\nFor example, the `between` operator can be used to search for all records that have a value in the `effectiveDate` field between `2024-01-31` and `2025-01-31`.\n',
    )
    range: list[str | float] = Field(
        ...,
        description='A collection of exactly two user-specified values: one for the upper bound of the range, the other for the lower bound.\n',
        max_items=2,
        min_items=2,
    )


class Operator6(Enum):
    search = 'search'


class SearchType(Enum):
    keyword = 'keyword'
    phrase = 'phrase'


class SearchFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: GlobalSearchFields = Field(
        ...,
        description='The name of the field the user chooses to filter against. Users may assign each field an optional `boost` value to rank the importance of that field in the search results.',
    )
    operator: Operator6 = Field(..., description='TODO...')
    term: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The text that is matched against field values during the search. The search term may consist of a single word or multiple words',
        example='John Doe',
    )
    searchType: SearchType | None = Field(
        'keyword',
        deprecated=True,
        description='The method for matching the search term against field values:\n - `keyword` searches for individual search term words independently from each other.\n - `phrase`  searches for the entire text of the search term together as a contiguous string.\nDeprecated: We automatically detect whether to search by keyword or phrase based on the presence of spaces in the search term.\n',
    )
    boost: float | None = Field(
        1,
        description='A value from 1 to 10 used to rank the importance of a given field relative to other fields during a given search.',
    )


class ResourceTypeEnum(Enum):
    policy = 'policy'
    case = 'case'


class ResourceTypeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    resourceType: list[ResourceTypeEnum] = Field(
        ...,
        description='The kind of record or business object that the user chooses to search for (e.g. the user only wants the search to return records that are Policies).\n',
        max_items=32767,
        min_items=1,
    )


class Operator7(Enum):
    AND = 'AND'
    OR = 'OR'


class CompositeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    operator: Operator7 = Field(
        ..., description='A logical operator used to combine filters.'
    )
    filters: list[
        ValueExistenceFilter
        | StringComparisonFilter
        | NumericComparisonFilter
        | DateComparisonFilter
        | ListMembershipFilter
        | RangeFilter
        | SearchFilter
        | ResourceTypeFilter
    ] = Field(..., max_items=32767, min_items=1)


class BaseAggregation(BaseModel):
    name: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A user-specified name for the aggregation, used to reference it in the response.',
    )
    field: GlobalSearchFields = Field(
        ...,
        description='The name of the field this aggregation is being performed against.',
    )


class NestedAggregation(BaseModel):
    aggregations: list[dict[str, Any]] | None = Field(
        None,
        description='An optional array of nested aggregations to perform within each group of the parent aggregation.\n\nEach nested aggregation follows the same structure as top-level aggregations and must include:\n- `name`: A unique identifier for the aggregation\n- `type`: The aggregation type (terms, dateHistogram, or stats)\n- `field`: The field to aggregate on\n- `aggregations`: (optional) Further nested aggregations for Terms and Date Histogram types\n\nNested aggregations enable multi-dimensional data analysis, allowing you to drill down into your data hierarchically.\n',
    )


class Type9(Enum):
    terms = 'terms'


class TermAggregation(BaseAggregation, NestedAggregation):
    type: Type9 | None = Field(
        None,
        description='The **Terms** aggregation returns the number of records that have a particular value in a given string-field.\n\nFor example, a terms aggregation against the `product` field may show that there are 20 records for Product A and 50 records of Product B.\n\nOnly available for string-based fields.\n',
    )


class Type10(Enum):
    dateHistogram = 'dateHistogram'


class DateInterval(Enum):
    year = 'year'
    month = 'month'
    week = 'week'
    day = 'day'


class DateHistogramAggregation(BaseAggregation, NestedAggregation):
    type: Type10 | None = Field(
        None,
        description='The **Date Histogram** aggregation returns the number of records with a date value falling within a given time period (`dateInterval`). Users can choose whether to group records by year, month, week, or day. \n\nFor example. a Date Histogram against the `effectiveDate` field (with a `dateInterval` of `year`) may show that there are 1000 records with an `effectiveDate` between Jan 28, 1999 and Jan 28, 2000, and 2000 records between Jan 28, 2000 and Jan 28, 2001.\n\nOnly available for date-based fields.\n',
    )
    dateInterval: DateInterval | None = Field(
        None,
        description='A user-chosen duration used to create groups of equal duration in date histogram aggregations.',
    )


class Type11(Enum):
    stats = 'stats'


class StatsAggregation(BaseAggregation):
    type: Type11 | None = Field(
        None,
        description='The **Stats** aggregation returns the maximum value, minimum value, sum of values, and arithmetic mean of values present in a given numeric field, as well as the number of records with values in that field.\n\nFor example. a Stats aggregation against the `modalPremium` field may show that there are 20,000 records with any value in the `modalPremium` field, that the average value is $300, the maximum value is $12,000, the minimum value is $75, and the sum of all values is $6,000,000.\n\nOnly available for number-based fields.\n',
    )


class ResourceType(Enum):
    policy = 'policy'


class PolicySearchResult(BaseModel):
    class Config:
        extra = Extra.allow

    resourceType: ResourceType | None = Field(
        None,
        description='The kind of record or business object the user chose to search for.',
    )
    policy: Annuity | Life | None = Field(
        None, description='A policy that matches the search criteria.'
    )
    roles: list[Insured | Annuitant | Beneficiary | Owner | Agent | Other] | None = (
        Field(None, description='A collection of roles associated with this policy.')
    )
    contacts: list[Person | Company | Trust | Estate | Charity] | None = Field(
        None,
        description='A collection of contact records for people, companies, estates, charities and/or trusts associated with this policy.',
    )


class ResourceType1(Enum):
    case = 'case'


class CaseSearchResult(BaseModel):
    class Config:
        extra = Extra.allow

    resourceType: ResourceType1 | None = Field(
        None,
        description='The kind of record or business object the user chose to search for.',
    )
    case: Case | None = Field(
        None, description='A case that matches the search criteria.'
    )
    roles: list[Insured | Annuitant | Beneficiary | Owner | Agent | Other] | None = (
        Field(None, description='A collection of roles associated with this case.')
    )
    contacts: list[Person | Company | Trust | Estate | Charity] | None = Field(
        None,
        description='A collection of contact records for people, companies, estates, charities and/or trusts associated with this case.',
    )


class SearchResult(BaseModel):
    class Config:
        extra = Extra.allow

    __root__: PolicySearchResult | CaseSearchResult = Field(
        ..., description='A record that matches the search criteria.'
    )


class Operator8(Enum):
    empty = 'empty'
    notEmpty = 'notEmpty'


class SchemasValueExistenceFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ...,
        description='The name of the field that the user chooses to filter against.\n',
    )
    operator: Operator8 = Field(
        ...,
        description='A logical operator to return records based on whether _any value exists_ in a user-specified field.\n\nFor example, the `empty` operator can be used to search for all records that do not have _any value_ in the `policyNumber` field .\n',
    )


class Operator9(Enum):
    startsWith = 'startsWith'
    endsWith = 'endsWith'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class SchemasStringComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ...,
        description='The name of the string field the user chooses to filter against.',
    )
    operator: Operator9 = Field(
        ...,
        description='A logical operator used to perform string comparison.\n\nFor example, the `contains` operator can be used to search for all records where the string "Abc123" appears somewhere within the `policyNumber` field.\n',
    )
    value: constr(min_length=1, max_length=32767) = Field(
        ..., description='The user-specified string to used to create the filter.'
    )


class Operator10(Enum):
    gt = 'gt'
    gte = 'gte'
    lt = 'lt'
    lte = 'lte'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class SchemasNumericComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ...,
        description='The name of the numeric field the user chooses to filter against.\n',
    )
    operator: Operator10 = Field(
        ...,
        description='A logical operator used to perform numeric comparison.\n\n  For example, the `lte` operator can be used to search for all records that have a value less than or equal to 10,000 the `policyNumber` field.\n',
    )
    value: float = Field(
        ..., description='The user-specified number used to create the filter.'
    )


class Operator11(Enum):
    after = 'after'
    before = 'before'
    onOrAfter = 'onOrAfter'
    onOrBefore = 'onOrBefore'


class SchemasDateComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ...,
        description='The name of the date field the user chooses to filter against.',
    )
    operator: Operator11 = Field(
        ...,
        description='A logical operator used for date comparison.\n\nFor example, the `before` operator can be used to search for all records that have date prior to Dec 31, 2000 in the `effectiveDate` field.\n',
    )
    value: constr(min_length=4, max_length=30) = Field(
        ...,
        description='The user-specified Date or DateTime value to create the filter in ISO 8601 format __without timezone__.\n\n**For Date-only filtering** (Properties that represent only a date, without a time component):\n- Format: \'YYYY-MM-DD\' (e.g., `2024-01-15`)\n- Compares only the date portion (year, month, day)\n- Ignores time component.\n\n**For DateTime filtering** (Properties that represent both a date and time):\n- Format: ISO 8601 string (e.g., `"2024-01-15T10:30:00.000"`)\n- Provides millisecond-precision filtering\n- Enables precise timestamp without timezone comparison.\n\nThe system automatically detects the format and applies the appropriate comparison logic.\n',
        example='2024-01-15',
    )


class Operator12(Enum):
    in_ = 'in'
    notIn = 'notIn'


class SchemasListMembershipFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ..., description='The name of the field the user chooses to filter against.'
    )
    operator: Operator12 = Field(
        ...,
        description='A logical operator to check for membership within a collection of values.\n\nFor example, the `in` operator can be used to search for all records that have data in the `policyNumber` field that matches at least one of the `values` specified by the user.\n',
    )
    values: list[str | float] = Field(
        ...,
        description='The collection of user-specified values used to create the filter.\n\nFor example, if the user specifies 30 different policy numbers as different `values`, the filter will return only records with data in the`policyNumber` field that matches at least one of those 30 policy numbers.\n',
        max_items=32767,
        min_items=1,
    )


class Operator13(Enum):
    between = 'between'
    notBetween = 'notBetween'


class SchemasRangeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ..., description='The name of the field to compare the filter range against.'
    )
    operator: Operator13 = Field(
        ...,
        description='A logical operator user to check for whether records include a value within the user-specified range.\n\nFor example, the `between` operator can be used to search for all records that have a value in the `effectiveDate` field between `2024-01-31` and `2025-01-31`.\n',
    )
    range: list[str | float] = Field(
        ...,
        description='A collection of exactly two user-specified values: one for the upper bound of the range, the other for the lower bound.\n',
        max_items=2,
        min_items=2,
    )


class Operator14(Enum):
    search = 'search'


class SchemasSearchFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: PolicySearchFields = Field(
        ...,
        description='The name of the field the user chooses to filter against. Users may assign each field an optional `boost` value to rank the importance of that field in the search results.',
    )
    operator: Operator14 = Field(..., description='TODO...')
    term: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The text that is matched against field values during the search. The search term may consist of a single word or multiple words',
        example='John Doe',
    )
    searchType: SearchType | None = Field(
        'keyword',
        deprecated=True,
        description='The method for matching the search term against field values:\n - `keyword` searches for individual search term words independently from each other.\n - `phrase`  searches for the entire text of the search term together as a contiguous string.\nDeprecated: We automatically detect whether to search by keyword or phrase based on the presence of spaces in the search term.\n',
    )
    boost: float | None = Field(
        1,
        description='A value from 1 to 10 used to rank the importance of a given field relative to other fields during a given search.',
    )


class Operator15(Enum):
    AND = 'AND'
    OR = 'OR'


class SchemasCompositeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    operator: Operator15 = Field(
        ..., description='A logical operator used to combine filters.'
    )
    filters: list[
        SchemasValueExistenceFilter
        | SchemasStringComparisonFilter
        | SchemasNumericComparisonFilter
        | SchemasDateComparisonFilter
        | SchemasListMembershipFilter
        | SchemasRangeFilter
        | SchemasSearchFilter
    ] = Field(..., max_items=32767, min_items=1)


class SchemasBaseAggregation(BaseModel):
    name: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A user-specified name for the aggregation, used to reference it in the response.',
    )
    field: PolicySearchFields = Field(
        ...,
        description='The name of the field this aggregation is being performed against.',
    )


class Type12(Enum):
    terms = 'terms'


class SchemasTermAggregation(SchemasBaseAggregation, NestedAggregation):
    type: Type12 | None = Field(
        None,
        description='The **Terms** aggregation returns the number of records that have a particular value in a given string-field. \n\nFor example, a terms aggregation against the `product` field may show that there are 20 records for Product A and 50 records of Product B.\n\nOnly available for string-based fields.\n',
    )


class Type13(Enum):
    dateHistogram = 'dateHistogram'


class SchemasDateHistogramAggregation(SchemasBaseAggregation, NestedAggregation):
    type: Type13 | None = Field(
        None,
        description='The **Date Histogram** aggregation returns the number of records with a date value falling within a given time period (`dateInterval`). Users can choose whether to group records by year, month, week, or day. \n\nFor example. a Date Histogram against the `effectiveDate` field (with a `dateInterval` of `year`) may show that there are 1000 records with an `effectiveDate` between Jan 28, 1999 and Jan 28, 2000, and 2000 records between Jan 28, 2000 and Jan 28, 2001.\n\nOnly available for date-based fields.\n',
    )
    dateInterval: DateInterval | None = Field(
        None,
        description='A user-chosen duration used to create groups of equal duration in date histogram aggregations.',
    )


class Type14(Enum):
    stats = 'stats'


class SchemasStatsAggregation(SchemasBaseAggregation):
    type: Type14 | None = Field(
        None,
        description='The **Stats** aggregation returns the maximum value, minimum value, sum of values, and arithmetic mean of values present in a given numeric field, as well as the number of records with values in that field.\n\nFor example. a Stats aggregation against the `modalPremium` field may show that there are 20,000 records with any value in the `modalPremium` field, that the average value is $300, the maximum value is $12,000, the minimum value is $75, and the sum of all values is $6,000,000.\n\nOnly available for number-based fields.\n',
    )


class Operator16(Enum):
    empty = 'empty'
    notEmpty = 'notEmpty'


class ComponentsSchemasValueExistenceFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ...,
        description='The name of the field that the user chooses to filter against.\n',
    )
    operator: Operator16 = Field(
        ...,
        description='A logical operator to return records based on whether _any value exists_ in a user-specified field.\n\nFor example, the `empty` operator can be used to search for all records that do not have _any value_ in the `policyNumber` field .\n',
    )


class Operator17(Enum):
    startsWith = 'startsWith'
    endsWith = 'endsWith'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class ComponentsSchemasStringComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ...,
        description='The name of the string field the user chooses to filter against.',
    )
    operator: Operator17 = Field(
        ...,
        description='A logical operator used to perform string comparison.\n\nFor example, the `contains` operator can be used to search for all records where the string "Abc123" appears somewhere within the `policyNumber` field.\n',
    )
    value: constr(min_length=1, max_length=32767) = Field(
        ..., description='The user-specified string to used to create the filter.'
    )


class Operator18(Enum):
    gt = 'gt'
    gte = 'gte'
    lt = 'lt'
    lte = 'lte'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class ComponentsSchemasNumericComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ...,
        description='The name of the numeric field the user chooses to filter against.\n',
    )
    operator: Operator18 = Field(
        ...,
        description='A logical operator used to perform numeric comparison.\n\n  For example, the `lte` operator can be used to search for all records that have a value less than or equal to 10,000 the `policyNumber` field.\n',
    )
    value: float = Field(
        ..., description='The user-specified number used to create the filter.'
    )


class Operator19(Enum):
    after = 'after'
    before = 'before'
    onOrAfter = 'onOrAfter'
    onOrBefore = 'onOrBefore'


class ComponentsSchemasDateComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ...,
        description='The name of the date field the user chooses to filter against.',
    )
    operator: Operator19 = Field(
        ...,
        description='A logical operator used for date comparison.\n\nFor example, the `before` operator can be used to search for all records that have date prior to Dec 31, 2000 in the `effectiveDate` field.\n',
    )
    value: constr(min_length=4, max_length=30) = Field(
        ...,
        description='The user-specified Date or DateTime value to create the filter in ISO 8601 format __without timezone__.\n\n**For Date-only filtering** (Properties that represent only a date, without a time component):\n- Format: \'YYYY-MM-DD\' (e.g., `2024-01-15`)\n- Compares only the date portion (year, month, day)\n- Ignores time component.\n\n**For DateTime filtering** (Properties that represent both a date and time):\n- Format: ISO 8601 string (e.g., `"2024-01-15T10:30:00.000"`)\n- Provides millisecond-precision filtering\n- Enables precise timestamp without timezone comparison.\n\nThe system automatically detects the format and applies the appropriate comparison logic.\n',
        example='2024-01-15',
    )


class Operator20(Enum):
    in_ = 'in'
    notIn = 'notIn'


class ComponentsSchemasListMembershipFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ..., description='The name of the field the user chooses to filter against.'
    )
    operator: Operator20 = Field(
        ...,
        description='A logical operator to check for membership within a collection of values.\n\nFor example, the `in` operator can be used to search for all records that have data in the `policyNumber` field that matches at least one of the `values` specified by the user.\n',
    )
    values: list[str | float] = Field(
        ...,
        description='The collection of user-specified values used to create the filter.\n\nFor example, if the user specifies 30 different policy numbers as different `values`, the filter will return only records with data in the`policyNumber` field that matches at least one of those 30 policy numbers.\n',
        max_items=32767,
        min_items=1,
    )


class Operator21(Enum):
    between = 'between'
    notBetween = 'notBetween'


class ComponentsSchemasRangeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ..., description='The name of the field to compare the filter range against.'
    )
    operator: Operator21 = Field(
        ...,
        description='A logical operator user to check for whether records include a value within the user-specified range.\n\nFor example, the `between` operator can be used to search for all records that have a value in the `effectiveDate` field between `2024-01-31` and `2025-01-31`.\n',
    )
    range: list[str | float] = Field(
        ...,
        description='A collection of exactly two user-specified values: one for the upper bound of the range, the other for the lower bound.\n',
        max_items=2,
        min_items=2,
    )


class Operator22(Enum):
    search = 'search'


class ComponentsSchemasSearchFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: CaseSearchFields = Field(
        ...,
        description='The name of the field the user chooses to filter against. Users may assign each field an optional `boost` value to rank the importance of that field in the search results.',
    )
    operator: Operator22 = Field(..., description='TODO...')
    term: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The text that is matched against field values during the search. The search term may consist of a single word or multiple words',
        example='John Doe',
    )
    searchType: SearchType | None = Field(
        'keyword',
        deprecated=True,
        description='The method for matching the search term against field values:\n - `keyword` searches for individual search term words independently from each other.\n - `phrase`  searches for the entire text of the search term together as a contiguous string.\nDeprecated: We automatically detect whether to search by keyword or phrase based on the presence of spaces in the search term.\n',
    )
    boost: float | None = Field(
        1,
        description='A value from 1 to 10 used to rank the importance of a given field relative to other fields during a given search.',
    )


class Operator23(Enum):
    AND = 'AND'
    OR = 'OR'


class ComponentsSchemasCompositeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    operator: Operator23 = Field(
        ..., description='A logical operator used to combine filters.'
    )
    filters: list[
        ComponentsSchemasValueExistenceFilter
        | ComponentsSchemasStringComparisonFilter
        | ComponentsSchemasNumericComparisonFilter
        | ComponentsSchemasDateComparisonFilter
        | ComponentsSchemasListMembershipFilter
        | ComponentsSchemasRangeFilter
        | ComponentsSchemasSearchFilter
    ] = Field(..., max_items=32767, min_items=1)


class ComponentsSchemasBaseAggregation(BaseModel):
    name: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A user-specified name for the aggregation, used to reference it in the response.',
    )
    field: CaseSearchFields = Field(
        ...,
        description='The name of the field this aggregation is being performed against.',
    )


class Type15(Enum):
    terms = 'terms'


class ComponentsSchemasTermAggregation(
    ComponentsSchemasBaseAggregation, NestedAggregation
):
    type: Type15 | None = Field(
        None,
        description='The **Terms** aggregation returns the number of records that have a particular value in a given string-field. \n\nFor example, a terms aggregation against the `product` field may show that there are 20 records for Product A and 50 records of Product B.\n\nOnly available for string-based fields.\n',
    )


class Type16(Enum):
    dateHistogram = 'dateHistogram'


class ComponentsSchemasDateHistogramAggregation(
    ComponentsSchemasBaseAggregation, NestedAggregation
):
    type: Type16 | None = Field(
        None,
        description='The **Date Histogram** aggregation returns the number of records with a date value falling within a given time period (`dateInterval`). Users can choose whether to group records by year, month, week, or day. \n\nFor example. a Date Histogram against the `effectiveDate` field (with a `dateInterval` of `year`) may show that there are 1000 records with an `effectiveDate` between Jan 28, 1999 and Jan 28, 2000, and 2000 records between Jan 28, 2000 and Jan 28, 2001.\n\nOnly available for date-based fields.\n',
    )
    dateInterval: DateInterval | None = Field(
        None,
        description='A user-chosen duration used to create groups of equal duration in date histogram aggregations.',
    )


class Type17(Enum):
    stats = 'stats'


class ComponentsSchemasStatsAggregation(ComponentsSchemasBaseAggregation):
    type: Type17 | None = Field(
        None,
        description='The **Stats** aggregation returns the maximum value, minimum value, sum of values, and arithmetic mean of values present in a given numeric field, as well as the number of records with values in that field.\n\nFor example. a Stats aggregation against the `modalPremium` field may show that there are 20,000 records with any value in the `modalPremium` field, that the average value is $300, the maximum value is $12,000, the minimum value is $75, and the sum of all values is $6,000,000.\n\nOnly available for number-based fields.\n',
    )


class LinkedPartySearchFields(Enum):
    ID = 'ID'
    name = 'name'
    partyNumber = 'partyNumber'
    partyType = 'partyType'
    boundUsersNames = 'boundUsersNames'
    boundUsersNumbers = 'boundUsersNumbers'
    boundUsersIDs = 'boundUsersIDs'


class UserSearchFields(Enum):
    ID = 'ID'
    name = 'name'
    userNumber = 'userNumber'
    linkedPartiesTypes = 'linkedPartiesTypes'


class UserLinkedPartySearchFields(BaseModel):
    __root__: LinkedPartySearchFields | UserSearchFields


class Operator24(Enum):
    empty = 'empty'
    notEmpty = 'notEmpty'


class SearchRequestUserPartyComponentsSchemasValueExistenceFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the field that the user chooses to filter against.\n',
    )
    operator: Operator24 = Field(
        ...,
        description='A logical operator to return records based on whether _any value exists_ in a user-specified field.\n\nFor example, the `empty` operator can be used to search for all records that do not have _any value_ in the `policyNumber` field .\n',
    )


class Operator25(Enum):
    startsWith = 'startsWith'
    endsWith = 'endsWith'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class SearchRequestUserPartyComponentsSchemasStringComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the string field the user chooses to filter against.',
    )
    operator: Operator25 = Field(
        ...,
        description='A logical operator used to perform string comparison.\n\nFor example, the `contains` operator can be used to search for all records where the string "Abc123" appears somewhere within the `policyNumber` field.\n',
    )
    value: constr(min_length=1, max_length=32767) = Field(
        ..., description='The user-specified string to used to create the filter.'
    )


class Operator26(Enum):
    gt = 'gt'
    gte = 'gte'
    lt = 'lt'
    lte = 'lte'
    eq = 'eq'
    neq = 'neq'
    contains = 'contains'
    notContains = 'notContains'


class SearchRequestUserPartyComponentsSchemasNumericComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the numeric field the user chooses to filter against.\n',
    )
    operator: Operator26 = Field(
        ...,
        description='A logical operator used to perform numeric comparison.\n\n  For example, the `lte` operator can be used to search for all records that have a value less than or equal to 10,000 the `policyNumber` field.\n',
    )
    value: float = Field(
        ..., description='The user-specified number used to create the filter.'
    )


class Operator27(Enum):
    after = 'after'
    before = 'before'
    onOrAfter = 'onOrAfter'
    onOrBefore = 'onOrBefore'


class SearchRequestUserPartyComponentsSchemasDateComparisonFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the date field the user chooses to filter against.',
    )
    operator: Operator27 = Field(
        ...,
        description='A logical operator used for date comparison.\n\nFor example, the `before` operator can be used to search for all records that have date prior to Dec 31, 2000 in the `effectiveDate` field.\n',
    )
    value: constr(min_length=4, max_length=30) = Field(
        ...,
        description='The user-specified Date or DateTime value to create the filter in ISO 8601 format __without timezone__.\n\n**For Date-only filtering** (Properties that represent only a date, without a time component):\n- Format: \'YYYY-MM-DD\' (e.g., `2024-01-15`)\n- Compares only the date portion (year, month, day)\n- Ignores time component.\n\n**For DateTime filtering** (Properties that represent both a date and time):\n- Format: ISO 8601 string (e.g., `"2024-01-15T10:30:00.000"`)\n- Provides millisecond-precision filtering\n- Enables precise timestamp without timezone comparison.\n\nThe system automatically detects the format and applies the appropriate comparison logic.\n',
        example='2024-01-15',
    )


class Operator28(Enum):
    in_ = 'in'
    notIn = 'notIn'


class SearchRequestUserPartyComponentsSchemasListMembershipFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ..., description='The name of the field the user chooses to filter against.'
    )
    operator: Operator28 = Field(
        ...,
        description='A logical operator to check for membership within a collection of values.\n\nFor example, the `in` operator can be used to search for all records that have data in the `policyNumber` field that matches at least one of the `values` specified by the user.\n',
    )
    values: list[str | float] = Field(
        ...,
        description='The collection of user-specified values used to create the filter.\n\nFor example, if the user specifies 30 different policy numbers as different `values`, the filter will return only records with data in the`policyNumber` field that matches at least one of those 30 policy numbers.\n',
        max_items=32767,
        min_items=1,
    )


class Operator29(Enum):
    between = 'between'
    notBetween = 'notBetween'


class SearchRequestUserPartyComponentsSchemasRangeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ..., description='The name of the field to compare the filter range against.'
    )
    operator: Operator29 = Field(
        ...,
        description='A logical operator user to check for whether records include a value within the user-specified range.\n\nFor example, the `between` operator can be used to search for all records that have a value in the `effectiveDate` field between `2024-01-31` and `2025-01-31`.\n',
    )
    range: list[str | float] = Field(
        ...,
        description='A collection of exactly two user-specified values: one for the upper bound of the range, the other for the lower bound.\n',
        max_items=2,
        min_items=2,
    )


class Operator30(Enum):
    search = 'search'


class SearchRequestUserPartyComponentsSchemasSearchFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the field the user chooses to filter against. Users may assign each field an optional `boost` value to rank the importance of that field in the search results.',
    )
    operator: Operator30 = Field(..., description='TODO...')
    term: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The text that is matched against field values during the search. The search term may consist of a single word or multiple words',
        example='John Doe',
    )
    searchType: SearchType | None = Field(
        'keyword',
        deprecated=True,
        description='The method for matching the search term against field values:\n - `keyword` searches for individual search term words independently from each other.\n - `phrase`  searches for the entire text of the search term together as a contiguous string.\nDeprecated: We automatically detect whether to search by keyword or phrase based on the presence of spaces in the search term.\n',
    )
    boost: float | None = Field(
        1,
        description='A value from 1 to 10 used to rank the importance of a given field relative to other fields during a given search.',
    )


class ResourceTypeEnum1(Enum):
    user = 'user'
    linkedParty = 'linkedParty'


class SchemasResourceTypeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    resourceType: list[ResourceTypeEnum1] = Field(
        ...,
        description='The kind of record or business object that the user chooses to search for (e.g. the user only wants the search to return records that are Policies).\n',
        max_items=32767,
        min_items=1,
    )


class Operator31(Enum):
    AND = 'AND'
    OR = 'OR'


class SearchRequestUserPartyComponentsSchemasCompositeFilter(BaseModel):
    class Config:
        extra = Extra.forbid

    operator: Operator31 = Field(
        ..., description='A logical operator used to combine filters.'
    )
    filters: list[
        SearchRequestUserPartyComponentsSchemasValueExistenceFilter
        | SearchRequestUserPartyComponentsSchemasStringComparisonFilter
        | SearchRequestUserPartyComponentsSchemasNumericComparisonFilter
        | SearchRequestUserPartyComponentsSchemasDateComparisonFilter
        | SearchRequestUserPartyComponentsSchemasListMembershipFilter
        | SearchRequestUserPartyComponentsSchemasRangeFilter
        | SearchRequestUserPartyComponentsSchemasSearchFilter
        | SchemasResourceTypeFilter
    ] = Field(..., max_items=32767, min_items=1)


class SearchRequestUserPartyComponentsSchemasBaseAggregation(BaseModel):
    name: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A user-specified name for the aggregation, used to reference it in the response.',
    )
    field: UserLinkedPartySearchFields = Field(
        ...,
        description='The name of the field this aggregation is being performed against.',
    )


class Type18(Enum):
    terms = 'terms'


class SearchRequestUserPartyComponentsSchemasTermAggregation(
    SearchRequestUserPartyComponentsSchemasBaseAggregation, NestedAggregation
):
    type: Type18 | None = Field(
        None,
        description='The **Terms** aggregation returns the number of records that have a particular value in a given string-field. \n\nFor example, a terms aggregation against the `product` field may show that there are 20 records for Product A and 50 records of Product B.\n\nOnly available for string-based fields.\n',
    )


class Type19(Enum):
    dateHistogram = 'dateHistogram'


class SearchRequestUserPartyComponentsSchemasDateHistogramAggregation(
    SearchRequestUserPartyComponentsSchemasBaseAggregation, NestedAggregation
):
    type: Type19 | None = Field(
        None,
        description='The **Date Histogram** aggregation returns the number of records with a date value falling within a given time period (`dateInterval`). Users can choose whether to group records by year, month, week, or day. \n\nFor example. a Date Histogram against the `effectiveDate` field (with a `dateInterval` of `year`) may show that there are 1000 records with an `effectiveDate` between Jan 28, 1999 and Jan 28, 2000, and 2000 records between Jan 28, 2000 and Jan 28, 2001.\n\nOnly available for date-based fields.\n',
    )
    dateInterval: DateInterval | None = Field(
        None,
        description='A user-chosen duration used to create groups of equal duration in date histogram aggregations.',
    )


class Type20(Enum):
    stats = 'stats'


class SearchRequestUserPartyComponentsSchemasStatsAggregation(
    SearchRequestUserPartyComponentsSchemasBaseAggregation
):
    type: Type20 | None = Field(
        None,
        description='The **Stats** aggregation returns the maximum value, minimum value, sum of values, and arithmetic mean of values present in a given numeric field, as well as the number of records with values in that field.\n\nFor example. a Stats aggregation against the `modalPremium` field may show that there are 20,000 records with any value in the `modalPremium` field, that the average value is $300, the maximum value is $12,000, the minimum value is $75, and the sum of all values is $6,000,000.\n\nOnly available for number-based fields.\n',
    )
<<<<<<< HEAD
=======


class SchemasID(BaseModel):
    __root__: constr(min_length=1, max_length=256) = Field(
        ...,
        description='Correlation ID - A unique identifier for each entity (whether that entity is a person, a company, a policy, etc). \nWe expose this ID for the purpose of matching entities in our internal system to their corresponding records in external systems, such as carrier SORs.\n*While this value MAY appear to be a UUID, you MUST accept values that are not UUIDs.*\nAlso used for Workflow and Journey Instance IDs.',
        example='4b33ae9e-827a-479d-b60c-8daa2873c08c',
    )


class TemplateName(BaseModel):
    __root__: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The name of a journey template.',
        example='policyContactInformation',
    )


class IsJourneyComplete(BaseModel):
    __root__: bool = Field(
        ...,
        deprecated=True,
        description='True indicates that the entire journey has completely finished.',
        example=True,
    )


class JourneyInstanceStatus(Enum):
    InProgress = 'InProgress'
    CancelRequested = 'CancelRequested'
    Cancelled = 'Cancelled'
    Completed = 'Completed'
    Failed = 'Failed'


class CancelledReason(BaseModel):
    __root__: constr(min_length=1, max_length=32767) = Field(
        ...,
        deprecated=True,
        description='The reason why this journey instance was cancelled.',
    )


class CancellationDataBag(BaseModel):
    class Config:
        extra = Extra.allow

    reason: constr(min_length=1, max_length=32767) | None = Field(
        None, description='The reason why this journey instance was cancelled.'
    )


class Cancellation(BaseModel):
    class Config:
        extra = Extra.forbid

    dataBag: CancellationDataBag | None = None


class FailedReason(BaseModel):
    __root__: constr(min_length=1, max_length=32767) = Field(
        ..., description='The reason why this journey instance failed.'
    )


class IsWaitingForActor(BaseModel):
    __root__: bool = Field(
        ...,
        description='True indicates that the journey instance is waiting for an actor to take a step.',
    )


class CurrentStepID(BaseModel):
    pass


class TargetObjectID(BaseModel):
    pass


class TargetType(BaseModel):
    __root__: constr(max_length=255) = Field(
        ...,
        description='The kind of resource that this journey instance aims to change (e.g. if the journey instance aims to change a particular policy, the target object `type` is *Policy*).\n',
        example='Case',
    )


class StartTime(BaseModel):
    pass


class CompletedTime(BaseModel):
    pass


class IsFFAAllowed(BaseModel):
    __root__: bool = Field(
        ...,
        description='True indicates that friction-free access is enabled for this journey instance.',
    )


class AssignedToActor(BaseModel):
    personID: ID | None = Field(
        None,
        deprecated=True,
        description='A unique identifier for the user responsible for completing this step.',
    )
    userID: ID | None = Field(
        None,
        description='A unique identifier for the user responsible for completing this step.',
    )


class FFALink(BaseModel):
    __root__: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The friction free access link for an actor.',
        example='https://ffaexample.com',
    )


class FFAActor(BaseModel):
    actor: AssignedToActor | None = None
    ffaLink: FFALink | None = None


class FFAActors(BaseModel):
    __root__: list[FFAActor] = Field(
        ...,
        description='A collection of friction-free access actors and the links that these actors use to access the journey instance.',
    )


class Identity(BaseModel):
    personID: ID | None = Field(
        None,
        deprecated=True,
        description='A unique identifier for a user who instantiates a new journey instance.',
        example='default',
    )
    userID: ID | None = Field(
        None,
        description='A unique identifier for a user who instantiates a new journey instance.',
        example='default',
    )


class Originator(Identity):
    pass


class AssignedToAutomated(Enum):
    automated = 'automated'


class AssignedToUnassigned(Enum):
    unassigned = 'unassigned'


class StepCompletedTime(BaseModel):
    pass


class Step(BaseModel):
    ID: SchemasID = Field(..., description='A unique identifier for this step.')
    action: constr(min_length=1, max_length=32767) = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    assignedTo: AssignedToAutomated | AssignedToActor | AssignedToUnassigned
    completedTime: StepCompletedTime | None = None


class JourneyInstance(BaseModel):
    ID: SchemasID = Field(
        ..., description='A unique identifier for this journey instance.'
    )
    templateName: TemplateName = Field(
        ...,
        description='The name of the journey template used to create this journey instance.',
    )
    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed | None = None
    ffaActors: FFAActors | None = None
    originator: Originator | None = None
    steps: list[Step] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey instance.',
    )


class JourneyTemplate(BaseModel):
    name: TemplateName


class WorkflowID(BaseModel):
    pass


class ErrorWithCode(BaseModel):
    class Config:
        extra = Extra.forbid

    code: str = Field(
        ...,
        description='An alphanumeric code indicating the type of error that occurred. Systems SHOULD take dependencies on this value.',
    )
    message: str = Field(
        ...,
        description='A human-readable explanation of the type of error that occurred. Systems MUST NOT take dependencies on this value.',
    )


class Errors(BaseModel):
    __root__: list[ErrorWithCode] = Field(..., min_items=1)


class StepID(BaseModel):
    pass


class DataBag(BaseModel):
    class Config:
        extra = Extra.allow

    files: list[Any] | None = Field(None, max_items=256, min_items=0)


class Step1(BaseModel):
    ID: StepID
    action: constr(min_length=1, max_length=32767) = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    assignedTo: AssignedToAutomated | AssignedToActor | AssignedToUnassigned
    completedTime: StepCompletedTime | None = Field(
        None, description='The date and time at which this step was completed.'
    )
    dataBag: DataBag | None = Field(
        None,
        description='A storage area for any data this journey instance has gathered over its lifecycle thus far.\nExamples of data items include user-inputted data, automated step calculation results, etc.',
    )


class JourneyResponse(BaseModel):
    isComplete: IsJourneyComplete | None = None
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[Step1] = Field(..., description='Summary of the steps of the journey.')


class Status1(Enum):
    InProgress = 'InProgress'
    CancelRequested = 'CancelRequested'
    Cancelled = 'Cancelled'
    Completed = 'Completed'
    Failed = 'Failed'
    CancelRequested_1 = 'CancelRequested'
    Cancelled_1 = 'Cancelled'


class CancelledJourneyResponse(JourneyResponse):
    status: Status1 | None = Field(
        None,
        description='An indicator of where the journey instance is in its lifecycle. Below we provide definitions for the possible statuses:\n- InProgress: the journey instance is currently running, and has not yet completed.\n- CancelRequested: an actor has asked for the journey instance to be cancelled, but the journey has not yet been terminated.\n- Cancelled: the journey instance has been terminated to satisfy a cancellation request, and cannot accept further actor interaction.  \n- Completed: the journey instance has successfully executed, and cannot accept further actor interactions.\n- Failed: the journey instance has been terminated due to an unexpected error, and cannot accept further actor interactions.\n',
        example='InProgress',
    )


class AssignerPersona(Enum):
    agent = 'agent'


class Initialization(BaseModel):
    targetObjectID: TargetObjectID


class ProvideDelegateContactInformationDataBag(BasePhoneNumber, BaseEmail):
    address: BaseAddress = Field(
        ..., description='The postal address associated with the delegate contact.'
    )
    name: Name = Field(..., description='The full name of the delegate contact.')
    phoneNumber: constr(min_length=1, max_length=50) = Field(
        ..., description='A phone number', example='8558675309'
    )
    emailAddress: constr(min_length=1, max_length=32767) = Field(
        ..., description='The text of the email address.', example='info@sureify.com'
    )


class NoFiles(BaseModel):
    __root__: list[Any] = Field(
        ...,
        description='This data bag does not collect any files. Therefore, this files array MUST have a value of 0.',
        max_length=0,
    )


class Action(Enum):
    provideDelegateContactInformation = 'provideDelegateContactInformation'


class DataBag1(ProvideDelegateContactInformationDataBag):
    files: NoFiles


class ProvideDelegateContactInformationResponse(BaseModel):
    ID: StepID
    action: Action = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag1 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action1(Enum):
    setOriginatorCapabilities = 'setOriginatorCapabilities'


class DataBag2(BaseModel):
    capabilities: list[Capability] = Field(
        ..., description='A collection of permissions granted to the originator.'
    )
    files: NoFiles


class SetOriginatorCapabilitiesResponse(BaseModel):
    ID: StepID
    action: Action1 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag2 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class EmptyDataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class Action2(Enum):
    detectIfOriginatorCanAssignCapabilities = 'detectIfOriginatorCanAssignCapabilities'


class DetectIfOriginatorCanAssignCapabilitiesResponse(BaseModel):
    ID: StepID
    action: Action2 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class ProvideDelegateCapabilitiesDataBag(BaseModel):
    capabilities: list[Capability] = Field(
        ...,
        description='A collection of permissions that the delegate is being granted.',
    )


class Action3(Enum):
    provideDelegateCapabilities = 'provideDelegateCapabilities'


class DataBag3(ProvideDelegateCapabilitiesDataBag):
    files: NoFiles


class ProvideDelegateCapabilitiesResponse(BaseModel):
    ID: StepID
    action: Action3 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag3 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ReviewSubmissionDataBag(BaseModel):
    isConfirmed: bool = Field(
        ...,
        description='True indicates that the user has confirmed that the information presented before them is correct and accurate.',
        example=True,
    )


class Action4(Enum):
    reviewSubmission = 'reviewSubmission'


class DataBag4(ReviewSubmissionDataBag):
    files: NoFiles


class ReviewSubmissionResponse(BaseModel):
    ID: StepID
    action: Action4 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any]
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag4 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action5(Enum):
    wrapUpAddDelegate = 'wrapUpAddDelegate'


class WrapUpAddDelegateResponse(BaseModel):
    ID: StepID
    action: Action5 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class SchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        ProvideDelegateContactInformationResponse
        | SetOriginatorCapabilitiesResponse
        | DetectIfOriginatorCanAssignCapabilitiesResponse
        | ProvideDelegateCapabilitiesResponse
        | ReviewSubmissionResponse
        | WrapUpAddDelegateResponse
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class SchemasPersona(Enum):
    policyowner = 'policyowner'
    agent = 'agent'


class Operation(Enum):
    takeStep = 'takeStep'


class ProvideDelegateContactInformationOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation | None = None
    params: ProvideDelegateContactInformationDataBag


class Operation1(Enum):
    goBack = 'goBack'


class GoBack(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation1
    stepID: ID = Field(
        ...,
        description='A unique identifier for the step that the journey instance is being returned to. Please note that step ID values are generated on a per-journey-instance basis.',
    )


class Operation2(Enum):
    takeStep = 'takeStep'


class ProvideDelegateCapabilitiesOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: ProvideDelegateCapabilitiesDataBag


class ReviewSubmissionOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: ReviewSubmissionDataBag


class NoteAction(Enum):
    upsert = 'upsert'


class Author1(BaseModel):
    class Config:
        extra = Extra.forbid

    name: Name = Field(..., description='The name of the author.')
    contactID: ID = Field(
        ..., description='A pointer to the full contact record for the author.'
    )


class Note1(BaseModel):
    ID: ID | None = Field(None, description='A unique identifier for the note.')
    author: Author1 = Field(
        ...,
        description='The person who wrote the note `content` and attached the `note` to the case or policy.',
    )
    title: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A brief description of the `note`.',
        example='Client signature required',
    )
    content: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The text that makes up the body of the `note`.',
        example='This application was received via paper and was missing signatures.  It has been returned for completion.',
    )


class UpsertOrDeleteCaseNoteV3DataBag1(BaseModel):
    noteAction: NoteAction = Field(
        ...,
        description='The option the user chooses: either to create/edit(upsert) or delete a note.\n',
    )
    note: Note1


class NoteAction1(Enum):
    delete = 'delete'


class Note2(BaseModel):
    ID: ID = Field(..., description='A unique identifier for the note.')


class UpsertOrDeleteCaseNoteV3DataBag2(BaseModel):
    noteAction: NoteAction1 = Field(
        ...,
        description='The option the user chooses: either to create/edit(upsert) or delete a note.\n',
    )
    note: Note2


class UpsertOrDeleteCaseNoteV3DataBag(BaseModel):
    __root__: UpsertOrDeleteCaseNoteV3DataBag1 | UpsertOrDeleteCaseNoteV3DataBag2


class Action6(Enum):
    upsertOrDeleteCaseNote = 'upsertOrDeleteCaseNote'


class NoteAction2(Enum):
    upsert = 'upsert'


class Note3(BaseModel):
    ID: ID | None = Field(None, description='A unique identifier for the note.')
    author: Author1 = Field(
        ...,
        description='The person who wrote the note `content` and attached the `note` to the case or policy.',
    )
    title: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='A brief description of the `note`.',
        example='Client signature required',
    )
    content: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The text that makes up the body of the `note`.',
        example='This application was received via paper and was missing signatures.  It has been returned for completion.',
    )


class DataBag51(BaseModel):
    noteAction: NoteAction2 = Field(
        ...,
        description='The option the user chooses: either to create/edit(upsert) or delete a note.\n',
    )
    note: Note3


class NoteAction3(Enum):
    delete = 'delete'


class Note4(BaseModel):
    ID: ID = Field(..., description='A unique identifier for the note.')


class DataBag52(BaseModel):
    noteAction: NoteAction3 = Field(
        ...,
        description='The option the user chooses: either to create/edit(upsert) or delete a note.\n',
    )
    note: Note4


class DataBag53(BaseModel):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class DataBag54(DataBag51, DataBag53):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class DataBag55(DataBag52, DataBag53):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class DataBag5(BaseModel):
    __root__: DataBag54 | DataBag55 = Field(
        ...,
        description='A data bag that collects structured data but does not collect files.',
    )


class UpsertOrDeleteCaseNoteV3Response(BaseModel):
    ID: StepID
    action: Action6 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag5 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action7(Enum):
    wrapUpChangeCaseNote = 'wrapUpChangeCaseNote'


class WrapUpChangeCaseNoteV3Response(BaseModel):
    ID: StepID
    action: Action7 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class ComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[UpsertOrDeleteCaseNoteV3Response | WrapUpChangeCaseNoteV3Response] = (
        Field(
            ...,
            description='A collection of actor steps and automated steps that make up this journey.',
        )
    )


class UpsertOrDeleteCaseNoteV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: UpsertOrDeleteCaseNoteV3DataBag


class Action8(Enum):
    setDividendOptions = 'setDividendOptions'


class DividendOption1(Enum):
    CashPayment = 'CashPayment'
    PremiumReduction = 'PremiumReduction'
    PaidUpAdditions = 'PaidUpAdditions'
    AccumulationAtInterest = 'AccumulationAtInterest'
    LoanRepayment = 'LoanRepayment'


class DividendOption(BaseModel):
    dividendOption: DividendOption1 | None = Field(
        None,
        description='A way in which a policyowner receives and/or uses dividends earned on their policy.',
    )


class DataBag6(BaseModel):
    dividendOptions: list[DividendOption] = Field(
        ...,
        description='A collection of choices for how the policyowner can receive and/or use dividends earned on their policy.',
    )
    files: NoFiles | None = None


class SetDividendOptionsV3Response(BaseModel):
    ID: StepID
    action: Action8 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag6 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class DividendOption2(Enum):
    CashPayment = 'CashPayment'
    PremiumReduction = 'PremiumReduction'
    PaidUpAdditions = 'PaidUpAdditions'
    AccumulationAtInterest = 'AccumulationAtInterest'
    LoanRepayment = 'LoanRepayment'


class ChooseDividendOptionV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    dividendOption: DividendOption2 = Field(
        ...,
        description='A way in which a policyowner receives and/or uses dividends earned on their policy.',
    )


class Action9(Enum):
    chooseDividendOption = 'chooseDividendOption'


class DataBag7(ChooseDividendOptionV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ChooseDividendOptionV3Response(BaseModel):
    ID: StepID
    action: Action9 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag7 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Type21(Enum):
    SSN = 'SSN'


class GovernmentIDNumber(BaseModel):
    class Config:
        extra = Extra.forbid

    type: Type21
    value: constr(
        regex=r'^(?!9\d{2}|666|000)\d{3}[- ]?(?!00)\d{2}[- ]?(?!0000)\d{4}$'
    ) = Field(..., example='123-45-6789')


class Type22(Enum):
    EIN = 'EIN'


class GovernmentIDNumber1(BaseModel):
    class Config:
        extra = Extra.forbid

    type: Type22
    value: constr(
        regex=r'^(?!00|11|14|15|18|19|28|29|36|43|47|48|49|59|69|78|79|89)(?!00-0000000)\d{2}-\d{7}$'
    ) = Field(..., example='12-3456789')


class ProvideGovernmentIDNumberV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    isAcknowledged: bool = Field(
        ...,
        description='True indicates that the user has legally taken responsibility for the accuracy and contextual applicability of the government identification information they provided.',
    )
    governmentIDNumber: GovernmentIDNumber | GovernmentIDNumber1


class Action10(Enum):
    provideGovernmentIDNumber = 'provideGovernmentIDNumber'


class DataBag8(ProvideGovernmentIDNumberV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ProvideGovernmentIDNumberV3Response(BaseModel):
    ID: StepID
    action: Action10 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag8 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action11(Enum):
    initializeSignature = 'initializeSignature'


class InitializeSignatureResponse(BaseModel):
    ID: StepID
    action: Action11 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class SigningStatus(Enum):
    Complete = 'Complete'


class ProvideSignatureDataBag(BaseModel):
    signingStatus: SigningStatus = Field(
        ..., description='The status of the signing process (e.g. Complete).'
    )


class Action12(Enum):
    provideSignature = 'provideSignature'


class DataBag9(ProvideSignatureDataBag):
    files: NoFiles


class ProvideSignatureResponse(BaseModel):
    ID: StepID
    action: Action12 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any]
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag9 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action13(Enum):
    wrapUpDividendChangeOption = 'wrapUpDividendChangeOption'


class WrapUpChangeDividendOptionV3Response(BaseModel):
    ID: StepID
    action: Action13 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class ChangeDividendOptionV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        SetDividendOptionsV3Response
        | ChooseDividendOptionV3Response
        | ProvideGovernmentIDNumberV3Response
        | InitializeSignatureResponse
        | ProvideSignatureResponse
        | WrapUpChangeDividendOptionV3Response
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ChooseDividendOptionV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: ChooseDividendOptionV3DataBag


class ProvideGovernmentIDNumberV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: ProvideGovernmentIDNumberV3DataBag


class ProvideSignatureOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: ProvideSignatureDataBag


class Action14(Enum):
    retrievePolicyContacts = 'retrievePolicyContacts'


class DataBag10(BaseModel):
    contacts: list[ID] = Field(
        ...,
        description='A collection pointers to the contacts (people or organizations) that are already associated with this policy.',
    )
    files: NoFiles


class RetrievePolicyContactsResponse(BaseModel):
    ID: StepID
    action: Action14 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag10 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Role(Enum):
    Insured = 'Insured'
    Annuitant = 'Annuitant'
    Beneficiary = 'Beneficiary'
    Owner = 'Owner'
    Agent = 'Agent'
    Other = 'Other'


class ChoosePersonDataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    personID: ID = Field(
        ...,
        description='A unique identifier for the contact (person or organization) whose contact information the user would like to modify.',
    )
    role: Role | None = Field(
        None,
        description='The role that this contact plays on the policy (e.g. Insured, Annuitant, Owner, Beneficiary etc).',
    )


class Action15(Enum):
    choosePerson = 'choosePerson'


class DataBag11(ChoosePersonDataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ChoosePersonResponse(BaseModel):
    ID: StepID
    action: Action15 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag11 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvideNewLegalNameV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    nameChangeReason: str = Field(
        ...,
        description='A explanation for why the user is changing the legal name on the policy (e.g. marriage).',
    )
    newLegalName: Name = Field(
        ...,
        description='The new legal name that will replace the old name on the policy.',
    )


class Action16(Enum):
    provideNewLegalName = 'provideNewLegalName'


class DataBag12(ProvideNewLegalNameV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ProvideNewLegalNameV3Response(BaseModel):
    ID: StepID
    action: Action16 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag12 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Binaries(BaseModel):
    __root__: list[bytes] = Field(
        ...,
        description='A collection of files (unstructured data) uploaded by the actor.',
    )


class Action17(Enum):
    uploadDocuments = 'uploadDocuments'


class DataBag13(BaseModel):
    class Config:
        extra = Extra.forbid

    files: list[Binaries] = Field(..., min_items=1)


class UploadDocumentsResponse(BaseModel):
    ID: StepID
    action: Action17 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag13 | None = Field(
        None,
        description='A data bag that collects files, but does not collect structured data.',
    )


class Action18(Enum):
    wrapUpChangeLegalName = 'wrapUpChangeLegalName'


class WrapUpChangeLegalNameV3Response(BaseModel):
    ID: StepID
    action: Action18 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class ChangeLegalNameV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        RetrievePolicyContactsResponse
        | ChoosePersonResponse
        | ProvideNewLegalNameV3Response
        | UploadDocumentsResponse
        | ReviewSubmissionResponse
        | WrapUpChangeLegalNameV3Response
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ChoosePersonOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: ChoosePersonDataBag


class ProvideNewLegalNameV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: ProvideNewLegalNameV3DataBag


class UploadDocumentsDataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    files: Binaries


class UploadDocumentsOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: UploadDocumentsDataBag


class Action19(Enum):
    retrieveOldContactInformation = 'retrieveOldContactInformation'


class DataBag14(BaseModel):
    addresses: list[BaseAddress] = Field(
        ...,
        description='A collection of addresses that are already listed on the policy for this contact. \n\nExactly one address must be marked as `isPrimary`.\n',
        max_items=32768,
        min_items=1,
    )
    phoneNumbers: list[PhoneNumber] | None = Field(
        None,
        description='A collection of phone numbers that are already listed on the policy for this contact. \n\nExactly one phone number must be marked as `isPrimary`.\n',
        max_items=32768,
        min_items=0,
    )
    emailAddresses: list[Email] | None = Field(
        None,
        description='A collection of email addresses that are already listed on the policy for this contact. \n\nExactly one email address must be marked as `isPrimary`.\n',
        max_items=32768,
        min_items=0,
    )
    files: NoFiles


class RetrieveOldContactInformationResponse(BaseModel):
    ID: StepID
    action: Action19 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag14 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvideNewContactInformationDataBag(BaseModel):
    class Config:
        extra = Extra.allow

    addresses: list[BaseAddress] = Field(
        ...,
        description='A collection of new addresses for this contact, provided by the user during this journey.\n',
        max_items=32768,
        min_items=1,
    )
    phoneNumbers: list[PhoneNumber] = Field(
        ...,
        description='A collection of new phone numbers for this contact, provided by the user during this journey.\n',
        max_items=32768,
        min_items=1,
    )
    emailAddresses: list[Email] = Field(
        ...,
        description='A collection of new email addresses for this contact, provided by the user during this journey.\n',
        max_items=32768,
        min_items=1,
    )
    effectiveDate: DateTime = Field(
        ...,
        description='The date when the policy officially switches to using the newly provided contact information.',
    )
    specialInstructions: str | None = Field(
        None,
        description='A user-inputted note providing supplementary information about the new contact information.',
    )


class Action20(Enum):
    provideNewContactInformation = 'provideNewContactInformation'


class DataBag15(ProvideNewContactInformationDataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ProvideNewContactInformationResponse(BaseModel):
    ID: StepID
    action: Action20 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag15 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action21(Enum):
    detectIfAddressChanged = 'detectIfAddressChanged'


class EmailAddresses(Email):
    pass


class DataBag16(BaseModel):
    addresses: list[BaseAddress] | None = Field(
        None,
        description='A collection of new addresses for this contact, provided by the user during this journey.\n',
    )
    phoneNumbers: list[PhoneNumber] | None = Field(
        None,
        description='A collection of new phone numbers for this contact, provided by the user during this journey.\n',
        max_items=32768,
        min_items=1,
    )
    emailAddresses: list[list[Email] | EmailAddresses] | None = Field(
        None,
        description='A collection of new email addresses for this contact, provided by the user during this journey.\n',
        max_items=32768,
        min_items=1,
    )
    files: NoFiles


class DetectIfAddressChangedResponse(BaseModel):
    ID: StepID
    action: Action21 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag16 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action22(Enum):
    retrieveAlternativeAddresses = 'retrieveAlternativeAddresses'


class Address1(BaseModel):
    ID: ID = Field(..., description='A unique identifier for this address.')
    address: BaseAddress = Field(
        ...,
        description='An alternative address returned by a 3rd party address verification service.',
    )


class DataBag17(BaseModel):
    files: NoFiles
    addresses: list[Address1] = Field(
        ...,
        description='A collection of potential alternative addresses returned by a 3rd party address verification service. If only one address is returned, it will match the user-inputted address exactly.',
        max_items=32768,
        min_items=1,
    )


class RetrieveAlternativeAddressesResponse(BaseModel):
    ID: StepID
    action: Action22 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag17 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ConfirmAddressV4DataBag(BaseModel):
    class Config:
        extra = Extra.allow

    selectedAddressID: ID = Field(
        ...,
        description='A unique identifier for the new address the user chooses (from a list of options returned by an address verification service). This address will replace the old address for the contact once the carrier accepts the change request.',
    )


class Action23(Enum):
    confirmAddress = 'confirmAddress'


class DataBag18(ConfirmAddressV4DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ConfirmAddressV4Response(BaseModel):
    ID: StepID
    action: Action23 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag18 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class File(BaseModel):
    ID: ID = Field(..., description='A unique identifier for this file')
    filename: constr(min_length=1, max_length=32767) = Field(
        ..., description='The name of this file.'
    )
    contentType: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The Multipurpose Internet Mail Extension (MIME) type of this file.',
        example='text/csv',
    )
    sizeInBytes: float = Field(..., description='The size of this file in bytes.')


class Action24(Enum):
    prefillForm = 'prefillForm'


class DataBag19(BaseModel):
    files: list[File] = Field(..., max_items=1, min_items=1)


class PrefillFormV4Response(BaseModel):
    ID: StepID
    action: Action24 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag19 | None = Field(
        None,
        description='A data bag that collects files, but does not collect structured data .',
    )


class Action25(Enum):
    wrapUpChangePolicyContactInformation = 'wrapUpChangePolicyContactInformation'


class WrapUpChangePolicyContactInformationV4Response(BaseModel):
    ID: StepID
    action: Action25 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class Action26(Enum):
    notifyTransmitComplete = 'notifyTransmitComplete'


class NotifyTransmitCompleteResponse(BaseModel):
    ID: StepID
    action: Action26 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class ChangePolicyContactInformationStateV4ComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        RetrievePolicyContactsResponse
        | ChoosePersonResponse
        | RetrieveOldContactInformationResponse
        | ProvideNewContactInformationResponse
        | DetectIfAddressChangedResponse
        | RetrieveAlternativeAddressesResponse
        | ConfirmAddressV4Response
        | PrefillFormV4Response
        | InitializeSignatureResponse
        | ProvideSignatureResponse
        | WrapUpChangePolicyContactInformationV4Response
        | NotifyTransmitCompleteResponse
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ProvideNewContactInformationOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: ProvideNewContactInformationDataBag


class ConfirmAddressV4Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: ConfirmAddressV4DataBag


class FileID(BaseModel):
    pass


class Action27(Enum):
    initializeOneTimePayment = 'initializeOneTimePayment'


class DataBag20(BaseModel):
    paymentAmount: NonNegativeMonetaryAmount = Field(
        ..., description='The amount of money that is being paid in this transaction.'
    )
    formOfPayment: BankAccount | CreditCard = Field(
        ...,
        description='The credit/debit or bank account information needed to process a payment.',
    )
    files: NoFiles


class InitializeOneTimePaymentResponse(BaseModel):
    ID: StepID
    action: Action27 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag20 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action28(Enum):
    initiateOneTimePaymentSession = 'initiateOneTimePaymentSession'


class DataBag21(BaseModel):
    paymentSessionID: SchemasID = Field(
        ...,
        description='A unique payment session ID, issued by a 3rd party payment service.',
    )
    files: NoFiles


class InitiateOneTimePaymentSessionResponse(BaseModel):
    ID: StepID
    action: Action28 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag21 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvidePaymentDataBag(BaseModel):
    paymentToken: str = Field(
        ...,
        description='A unique token, issued by a third party payment service, that retrieves payment information.',
    )


class Action29(Enum):
    providePayment = 'providePayment'


class DataBag22(ProvidePaymentDataBag):
    files: NoFiles


class ProvidePaymentResponse(BaseModel):
    ID: StepID
    action: Action29 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag22 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action30(Enum):
    setOneTimePaymentInformation = 'setOneTimePaymentInformation'


class DataBag23(BaseModel):
    formOfPayment: BankAccount | CreditCard | None = Field(
        None, description='The payment method that the user has chosen to pay with.'
    )
    paymentStatus: constr(min_length=1, max_length=32000) = Field(
        ..., description='The status of the payment.'
    )
    files: NoFiles


class SetOneTimePaymentInformationResponse(BaseModel):
    ID: StepID
    action: Action30 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag23 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action31(Enum):
    wrapUpPayPolicyPremium = 'wrapUpPayPolicyPremium'


class WrapUpPayPolicyPremiumV3Response(BaseModel):
    ID: StepID
    action: Action31 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class PayPolicyPremiumV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        InitializeOneTimePaymentResponse
        | InitiateOneTimePaymentSessionResponse
        | ProvidePaymentResponse
        | SetOneTimePaymentInformationResponse
        | WrapUpPayPolicyPremiumV3Response
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ProvidePaymentOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: ProvidePaymentDataBag


class Action32(Enum):
    wrapUpDisablePremiumAutopay = 'wrapUpDisablePremiumAutopay'


class WrapUpDisablePremiumAutopayV3Response(BaseModel):
    ID: StepID
    action: Action32 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class DisablePremiumAutopayV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[ReviewSubmissionResponse | WrapUpDisablePremiumAutopayV3Response] = (
        Field(
            ...,
            description='A collection of actor steps and automated steps that make up this journey.',
        )
    )


class Action33(Enum):
    setCoverageAndPremiumOptions = 'setCoverageAndPremiumOptions'


class NewPremiumAndCoverageInterval(BaseModel):
    coverage: NonNegativeMonetaryAmount = Field(
        ...,
        description='A new coverage (as a monetary amount) that could be added to an existing policy.',
    )
    premium: NonNegativeMonetaryAmount = Field(
        ...,
        description='An additional premium (as a monetary amount) that must be paid in order to add a new coverage.',
    )


class DataBag24(BaseModel):
    newPremiumAndCoverageIntervals: list[NewPremiumAndCoverageInterval] = Field(
        ...,
        description='A collection of additional coverage amounts, and the corresponding additional premium amounts that must be paid to add each new coverage to an existing policy.',
    )
    files: NoFiles | None = None


class SetCoverageAndPremiumOptionsV3Response(BaseModel):
    ID: StepID
    action: Action33 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag24 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class IncreaseCoverageDataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    newCoverage: NonNegativeMonetaryAmount = Field(
        ...,
        description='The new coverage (as a monetary amount) that a policyowner has chosen to add to an existing policy.',
    )


class Action34(Enum):
    increaseCoverage = 'increaseCoverage'


class DataBag25(IncreaseCoverageDataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class IncreaseCoverageResponse(BaseModel):
    ID: StepID
    action: Action34 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag25 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action35(Enum):
    wrapUpExerciseGuaranteedPurchaseOption = 'wrapUpExerciseGuaranteedPurchaseOption'


class WrapUpExerciseGuaranteedPurchaseOptionV3Response(BaseModel):
    ID: StepID
    action: Action35 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class ExerciseGuaranteedPurchaseOptionV3StateComponentsSchemasJourneyResponse(
    BaseModel
):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        SetCoverageAndPremiumOptionsV3Response
        | IncreaseCoverageResponse
        | InitializeSignatureResponse
        | ProvideSignatureResponse
        | WrapUpExerciseGuaranteedPurchaseOptionV3Response
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class IncreaseCoverageOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation2 | None = None
    params: IncreaseCoverageDataBag


class Action36(Enum):
    setBeneficiaryDesignation = 'setBeneficiaryDesignation'


class DataBag26(BaseModel):
    class Config:
        extra = Extra.forbid

    designation: BeneficiaryDesignation
    files: NoFiles


class SetBeneficiaryDesignationResponse(BaseModel):
    ID: StepID
    action: Action36 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag26 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action37(Enum):
    validateExistingBeneficiaries = 'validateExistingBeneficiaries'


class ValidateExistingBeneficiariesResponse(BaseModel):
    ID: StepID
    action: Action37 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class Operation15(Enum):
    Add = 'Add'


class OperationAdd(BaseModel):
    operation: Operation15


class BaseBeneficiary(BaseModel):
    ID: ID = Field(..., description='A unique identifier for this contact.')
    type: str = Field(..., description='The type of the beneficiary.')
    designation: BeneficiaryDesignation


class RelationshipToBeneficiary(Enum):
    Parent = 'Parent'
    Guardian = 'Guardian'
    Relative = 'Relative'
    Other = 'Other'


class ProvideCustodianDataBag(BasePerson):
    relationshipToBeneficiary: RelationshipToBeneficiary = Field(
        ...,
        description='The way in which this custodian is related to the beneficiary.',
    )
    name: Name
    DOB: DateTime = Field(
        ...,
        description="This person's date of birth (DOB). The field may contain only a birth year if data for the person is incomplete.",
    )
    addresses: list[Address] = Field(
        ...,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )


class Type23(Enum):
    Person = 'Person'


class IndividualBeneficiaryWithCustodian(BaseBeneficiary):
    type: Type23 | None = Field(None, description='The type of the beneficiary.')
    isPerStirpes: bool | None = Field(
        None,
        description='True indicates that the beneficiary designation is perStirpes.',
    )
    relationshipToInsured: RelationshipToInsured
    custodian: ProvideCustodianDataBag | None = Field(
        None,
        description='The adult designated to manage and hold property for a minor under Uniform Transfers to Minors Act (UTMA).',
        title='Custodian',
    )
    contact: BasePerson = Field(
        ..., description='A contact record for individual beneficiary.', title='Person'
    )


class ProvideCompanyDataBag(BaseCompany):
    isFuneralHome: bool = Field(
        ..., description='True indicates that the company operates as a funeral home.'
    )
    name: constr(min_length=1, max_length=32767) = Field(
        ..., description='The name of the corporate entity.', example='SureCo'
    )
    addresses: list[Address] = Field(
        ...,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )


class Type24(Enum):
    Company = 'Company'


class CompanyBeneficiary(BaseBeneficiary):
    type: Type24 | None = Field(None, description='The type of the beneficiary.')
    contact: ProvideCompanyDataBag = Field(
        ..., description='A contact record for company beneficiary.', title='Company'
    )


class ProvideTrustDataBag(BaseTrust):
    grantor: BasePerson
    name: constr(min_length=1, max_length=32767) = Field(
        ..., description='The legal name of the trust.', example='SureCo'
    )
    establishedDate: DateTime = Field(
        ...,
        description='The date that the trust came into existence as a legally recognized entity.',
    )


class ProvideTrusteesDataBag(BaseModel):
    trustees: list[BasePerson] | None = Field(
        None,
        description='A collection of individuals who are legally responsible for managing the trust and its assets.',
    )


class ProvideTrustFinalBeneficiaryDataBag(BasePerson):
    name: Name


class Type25(Enum):
    Trust = 'Trust'


class Contact(ProvideTrustDataBag, ProvideTrusteesDataBag, BaseTrust):
    finalBeneficiary: ProvideTrustFinalBeneficiaryDataBag | None = Field(
        None,
        description='The individual who ultimately receives the remaining trust assets once all trust obligations and conditions have been fulfilled.',
        title='Final Beneficiary',
    )
    name: constr(min_length=1, max_length=32767) = Field(
        ..., description='The legal name of the trust.', example='SureCo'
    )
    establishedDate: DateTime = Field(
        ...,
        description='The date that the trust came into existence as a legally recognized entity.',
    )
    grantor: BasePerson


class TrustBeneficiary(BaseBeneficiary):
    type: Type25 | None = Field(None, description='The type of the beneficiary.')
    contact: Contact = Field(
        ..., description='A contact record for trust beneficiary.', title='Trust'
    )


class ProvideCharityDataBag(BaseCharity):
    name: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The legal name of the charity.',
        example='Helping Hands Foundation',
    )
    addresses: list[Address] = Field(
        ...,
        description='A collection of addresses for this charity.',
        max_items=32768,
        min_items=0,
    )
    isGovernedByBoardOfDirectors: bool = Field(
        ...,
        description="True indicates that this charity is being governed by a board of directors (a group of individuals) who are responsible for overseeing the charity's operations, ensuring compliance with legal requirements, and making strategic decisions.",
    )


class Type26(Enum):
    Charity = 'Charity'


class CharityBeneficiary(BaseBeneficiary):
    type: Type26 | None = Field(None, description='The type of the beneficiary.')
    contact: ProvideCharityDataBag = Field(
        ..., description='A contact record for charity beneficiary.', title='Charity'
    )


class ProvideEstateDataBag(BaseEstate):
    executor: BasePerson | None = None


class Type27(Enum):
    Estate = 'Estate'


class EstateBeneficiary(BaseBeneficiary):
    type: Type27 | None = Field(None, description='The type of the beneficiary.')
    contact: ProvideEstateDataBag = Field(
        ..., description='A contact record for estate beneficiary.', title='Estate'
    )


class Operation16(Enum):
    Update = 'Update'


class OperationUpdate(BaseModel):
    operation: Operation16
    beneficiary: (
        IndividualBeneficiaryWithCustodian
        | CompanyBeneficiary
        | TrustBeneficiary
        | CharityBeneficiary
        | EstateBeneficiary
    )


class Operation17(Enum):
    Delete = 'Delete'


class OperationDelete(BaseModel):
    operation: Operation17
    beneficiaryID: ID = Field(
        ..., description='The unique identifier of the beneficiary.'
    )


class Operation18(Enum):
    Submit = 'Submit'


class OperationSubmit(BaseModel):
    operation: Operation18


class ChooseManageBeneficiaryOperationDataBag(BaseModel):
    __root__: OperationAdd | OperationUpdate | OperationDelete | OperationSubmit


class Action38(Enum):
    chooseManageBeneficiaryOperation = 'chooseManageBeneficiaryOperation'


class SectionKey(Enum):
    ManageBeneficiaries = 'ManageBeneficiaries'


class Attributes(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section to which this step belongs to.'
    )


class DataBag271(BaseModel):
    files: NoFiles


class DataBag272(OperationAdd, DataBag271):
    pass


class DataBag273(OperationUpdate, DataBag271):
    pass


class DataBag274(OperationDelete, DataBag271):
    pass


class DataBag275(OperationSubmit, DataBag271):
    pass


class DataBag27(BaseModel):
    __root__: DataBag272 | DataBag273 | DataBag274 | DataBag275 = Field(
        ...,
        description='A data bag that does not collect any files, but does collect structured data.',
    )


class ChooseManageBeneficiaryOperationResponse(BaseModel):
    ID: StepID
    action: Action38 = Field(
        ...,
        description='The name of the step which briefly summarizes what this step does.',
    )
    attributes: Attributes = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag27 | None = Field(
        None,
        description='A data bag that does not collect any files, but does collect structured data.',
    )


class Action39(Enum):
    executeManageBeneficiaryOperation = 'executeManageBeneficiaryOperation'


class ExecuteManageBeneficiaryOperationResponse(BaseModel):
    ID: StepID
    action: Action39 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class Action40(Enum):
    createBeneficiaryID = 'createBeneficiaryID'


class DataBag28(BaseModel):
    ID: ID = Field(..., description='A unique identifier for a beneficiary.')
    files: NoFiles


class CreateBeneficiaryIDResponse(BaseModel):
    ID: StepID
    action: Action40 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag28 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class BeneficiaryType(Enum):
    Individual = 'Individual'
    Estate = 'Estate'
    Charity = 'Charity'
    Company = 'Company'
    Trust = 'Trust'


class ChooseBeneficiaryTypeDataBag(BaseModel):
    beneficiaryType: BeneficiaryType = Field(
        ...,
        description='A category that identifies the type of beneficiary being added to the policy.',
    )


class Action41(Enum):
    chooseBeneficiaryType = 'chooseBeneficiaryType'


class Attributes1(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag29(ChooseBeneficiaryTypeDataBag):
    files: NoFiles


class ChooseBeneficiaryTypeResponse(BaseModel):
    ID: StepID
    action: Action41 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes1 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag29 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action42(Enum):
    telescopeAddBeneficiary = 'telescopeAddBeneficiary'


class TelescopeAddBeneficiaryResponse(BaseModel):
    ID: StepID
    action: Action42 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class RelationshipToInsured1(Enum):
    Spouse = 'Spouse'
    Child = 'Child'
    Parent = 'Parent'
    Sibling = 'Sibling'
    Grandchild = 'Grandchild'
    Other_Relative = 'Other Relative'
    Friend = 'Friend'
    Business_Partner = 'Business Partner'
    Other = 'Other'


class ProvideIndividualBeneficiaryDataBag(BasePerson):
    relationshipToInsured: RelationshipToInsured1 = Field(
        ...,
        description='The beneficiarys relationship to the insured individual on the policy.',
    )
    name: Name
    DOB: DateTime = Field(
        ...,
        description="This person's date of birth (DOB). The field may contain only a birth year if data for the person is incomplete.",
    )
    sex: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The legally recognized gender of the person, usually as assigned at birth.',
        example='female',
    )
    addresses: list[Address] = Field(
        ...,
        description='A collection of addresses for this person.',
        max_items=32768,
        min_items=0,
    )


class Action43(Enum):
    provideIndividualBeneficiary = 'provideIndividualBeneficiary'


class Attributes2(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag30(ProvideIndividualBeneficiaryDataBag):
    files: NoFiles


class ProvideIndividualBeneficiaryResponse(BaseModel):
    ID: StepID
    action: Action43 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes2 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag30 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ChooseIndividualBeneficiaryDesignationsDataBag(BaseModel):
    isIrrevocable: bool = Field(
        ...,
        description='True indicates that, regardless of whether the insured/annuitant has died or not, this beneficiary must approve any changes to the policy, including beneficiary changes (i.e. the insured/annuitant is unable to remove this beneficiary from the policy, unless the beneficiary explicitly approves the change).',
        example=True,
    )
    isPerStirpes: bool = Field(
        ...,
        description="True indicates that if a named beneficiary dies before the insured/annuitant, the descendents of that named beneficiary receive the policy's proceeds (e.g. death benefit) rather than the descendents of the insured/annuitant.",
        example=True,
    )


class Action44(Enum):
    chooseIndividualBeneficiaryDesignations = 'chooseIndividualBeneficiaryDesignations'


class Attributes3(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag31(ChooseIndividualBeneficiaryDesignationsDataBag):
    files: NoFiles


class ChooseIndividualBeneficiaryDesignationsResponse(BaseModel):
    ID: StepID
    action: Action44 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes3 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag31 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action45(Enum):
    detectIfCustodianIsRequired = 'detectIfCustodianIsRequired'


class DetectIfCustodianIsRequiredResponse(BaseModel):
    ID: StepID
    action: Action45 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class Action46(Enum):
    provideCustodian = 'provideCustodian'


class Attributes4(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag32(ProvideCustodianDataBag):
    files: NoFiles


class ProvideCustodianResponse(BaseModel):
    ID: StepID
    action: Action46 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes4 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag32 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action47(Enum):
    provideEstate = 'provideEstate'


class Attributes5(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag33(ProvideEstateDataBag):
    files: NoFiles


class ProvideEstateResponse(BaseModel):
    ID: StepID
    action: Action47 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes5 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag33 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action48(Enum):
    provideCharity = 'provideCharity'


class Attributes6(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag34(ProvideCharityDataBag):
    files: NoFiles


class ProvideCharityResponse(BaseModel):
    ID: StepID
    action: Action48 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes6 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag34 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action49(Enum):
    provideCompany = 'provideCompany'


class Attributes7(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag35(ProvideCompanyDataBag):
    files: NoFiles


class ProvideCompanyResponse(BaseModel):
    ID: StepID
    action: Action49 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes7 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag35 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action50(Enum):
    provideTrust = 'provideTrust'


class Attributes8(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag36(ProvideTrustDataBag):
    files: NoFiles


class ProvideTrustResponse(BaseModel):
    ID: StepID
    action: Action50 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes8 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag36 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action51(Enum):
    provideTrustees = 'provideTrustees'


class Attributes9(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag37(ProvideTrusteesDataBag):
    files: NoFiles


class ProvideTrusteesResponse(BaseModel):
    ID: StepID
    action: Action51 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes9 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag37 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action52(Enum):
    provideTrustFinalBeneficiary = 'provideTrustFinalBeneficiary'


class Attributes10(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag38(ProvideTrustFinalBeneficiaryDataBag):
    files: NoFiles


class ProvideTrustFinalBeneficiaryResponse(BaseModel):
    ID: StepID
    action: Action52 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes10 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag38 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class AllocationDivision(Enum):
    Equal = 'Equal'


class ProvideBeneficiaryAllocationsDataBag1(BaseModel):
    allocationDivision: AllocationDivision = Field(
        ..., description='The allocations are split evenly between all beneficiaries.'
    )


class AllocationDivision1(Enum):
    Custom = 'Custom'


class Allocation(BaseModel):
    class Config:
        extra = Extra.forbid

    beneficiaryID: ID = Field(..., description='A unique identifier for a beneficiary.')
    percentage: NonNegativePercent = Field(
        ...,
        description="The percentage of the policy's proceeds (e.g. death benefit) that this beneficiary receives after the insured/annuitant passes.",
    )


class ProvideBeneficiaryAllocationsDataBag2(BaseModel):
    allocationDivision: AllocationDivision1 = Field(
        ...,
        description='The allocations are split unequally between beneficiaries: each beneficiary receives a custom percentage of the total benefit.\n',
    )
    allocations: list[Allocation] = Field(
        ...,
        description="A collection of allocations. Each allocation is a percentage indicating a particular beneficiary's share of the total policy benefit. \nThe total of all percentage values across the collection must equal 100.\n",
    )


class ProvideBeneficiaryAllocationsDataBag(BaseModel):
    __root__: (
        ProvideBeneficiaryAllocationsDataBag1 | ProvideBeneficiaryAllocationsDataBag2
    )


class Action53(Enum):
    provideBeneficiaryAllocations = 'provideBeneficiaryAllocations'


class SectionKey11(Enum):
    Allocations = 'Allocations'


class Attributes11(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey11 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class AllocationDivision2(Enum):
    Equal = 'Equal'


class DataBag391(BaseModel):
    allocationDivision: AllocationDivision2 = Field(
        ..., description='The allocations are split evenly between all beneficiaries.'
    )


class AllocationDivision3(Enum):
    Custom = 'Custom'


class DataBag392(BaseModel):
    allocationDivision: AllocationDivision3 = Field(
        ...,
        description='The allocations are split unequally between beneficiaries: each beneficiary receives a custom percentage of the total benefit.\n',
    )
    allocations: list[Allocation] = Field(
        ...,
        description="A collection of allocations. Each allocation is a percentage indicating a particular beneficiary's share of the total policy benefit. \nThe total of all percentage values across the collection must equal 100.\n",
    )


class DataBag393(BaseModel):
    files: NoFiles


class DataBag394(DataBag391, DataBag393):
    pass


class DataBag395(DataBag392, DataBag393):
    pass


class DataBag39(BaseModel):
    __root__: DataBag394 | DataBag395 = Field(
        ...,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvideBeneficiaryAllocationsResponse(BaseModel):
    ID: StepID
    action: Action53 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes11 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag39 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class SectionKey12(Enum):
    ReviewAndSign = 'ReviewAndSign'


class Attributes12(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey12 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class SchemasProvideSignatureResponse(ProvideSignatureResponse):
    attributes: Attributes12 | None = Field(
        None,
        description='A collection of metadata items that the journey author has attached to this step.',
    )


class Action54(Enum):
    wrapUpManageBeneficiaries = 'wrapUpManageBeneficiaries'


class WrapUpManageBeneficiariesResponse(BaseModel):
    ID: StepID
    action: Action54 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class ManageBeneficiariesV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        SetBeneficiaryDesignationResponse
        | ValidateExistingBeneficiariesResponse
        | ChooseManageBeneficiaryOperationResponse
        | ExecuteManageBeneficiaryOperationResponse
        | CreateBeneficiaryIDResponse
        | ChooseBeneficiaryTypeResponse
        | TelescopeAddBeneficiaryResponse
        | ProvideIndividualBeneficiaryResponse
        | ChooseIndividualBeneficiaryDesignationsResponse
        | DetectIfCustodianIsRequiredResponse
        | ProvideCustodianResponse
        | ProvideEstateResponse
        | ProvideCharityResponse
        | ProvideCompanyResponse
        | ProvideTrustResponse
        | ProvideTrusteesResponse
        | ProvideTrustFinalBeneficiaryResponse
        | ProvideBeneficiaryAllocationsResponse
        | SchemasProvideSignatureResponse
        | WrapUpManageBeneficiariesResponse
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class Operation19(Enum):
    takeStep = 'takeStep'


class ChooseManageBeneficiaryOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ChooseManageBeneficiaryOperationDataBag


class ChooseBeneficiaryTypeOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ChooseBeneficiaryTypeDataBag


class ProvideIndividualBeneficiaryOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideIndividualBeneficiaryDataBag


class ChooseIndividualBeneficiaryDesignationsOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ChooseIndividualBeneficiaryDesignationsDataBag


class ProvideCustodianOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideCustodianDataBag


class ProvideCompanyOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideCompanyDataBag


class ProvideCharityOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideCharityDataBag


class ProvideTrustOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideTrustDataBag


class ProvideTrusteesOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideTrusteesDataBag


class ProvideTrustFinalBeneficiaryOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideTrustFinalBeneficiaryDataBag


class ProvideEstateOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideEstateDataBag


class ProvideBeneficiaryAllocationsOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideBeneficiaryAllocationsDataBag


class Action55(Enum):
    setLifeEventOptions = 'setLifeEventOptions'


class LifeEventOption(BaseModel):
    lifeEvent: str = Field(
        ...,
        description='A qualifying life event (e.g. marriage, birth of a child, etc.) that makes someone eligible to add coverage to their policy.',
    )
    eligibilityWindow: Duration | None = Field(
        None,
        description='The maximum amount of time before/after the life event in which a policyowner may add coverage (e.g up to 30 days after marriage).',
    )
    duration: Any


class DataBag40(BaseModel):
    lifeEventOptions: list[LifeEventOption] = Field(
        ...,
        description='A collection of qualifying life events, paired with their corresponding duration windows for adding coverage.',
    )
    files: NoFiles | None = None


class SetLifeEventOptionsV3Response(BaseModel):
    ID: StepID
    action: Action55 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag40 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ChooseLifeEventV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    lifeEvent: str = Field(
        ...,
        description='A qualifying life event (e.g. marriage, birth of a child, etc.) that makes someone eligible to add coverage to their policy.',
    )
    lifeEventDate: DateTime = Field(
        ..., description='The date on which the qualifying life event occurred.'
    )


class Action56(Enum):
    chooseLifeEvent = 'chooseLifeEvent'


class DataBag41(ChooseLifeEventV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ChooseLifeEventV3Response(BaseModel):
    ID: StepID
    action: Action56 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Any = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag41 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action57(Enum):
    setCoverageAndPremiumOptions = 'setCoverageAndPremiumOptions'


class DataBag42(BaseModel):
    newPremiumAndCoverageIntervals: list[NewPremiumAndCoverageInterval] = Field(
        ...,
        description='A collection of additional coverage amounts and the corresponding additional premium amounts that must be paid to add each new coverage to an existing policy.',
    )
    files: NoFiles | None = None


class SchemasSetCoverageAndPremiumOptionsV3Response(BaseModel):
    ID: StepID
    action: Action57 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag42 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action58(Enum):
    wrapUpPurchaseAdditionalCoverageV3 = 'wrapUpPurchaseAdditionalCoverageV3'


class WrapUpPurchaseAdditionalCoverageV3Response(BaseModel):
    ID: StepID
    action: Action58 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class PurchaseAdditionalCoverageV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        SetLifeEventOptionsV3Response
        | ChooseLifeEventV3Response
        | UploadDocumentsResponse
        | SchemasSetCoverageAndPremiumOptionsV3Response
        | IncreaseCoverageResponse
        | InitializeSignatureResponse
        | ProvideSignatureResponse
        | WrapUpPurchaseAdditionalCoverageV3Response
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ChooseLifeEventV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ChooseLifeEventV3DataBag


class ProvideAddressDataBag(BaseModel):
    address: BaseAddress = Field(
        ..., description='The address to which the duplicate policy should be sent.'
    )


class Action59(Enum):
    provideAddress = 'provideAddress'


class DataBag43(ProvideAddressDataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ProvideAddressResponse(BaseModel):
    ID: StepID
    action: Action59 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag43 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class IsAssigned(Enum):
    boolean_False = False


class ProvideAssignmentStatusV3DataBag1(BaseModel):
    class Config:
        extra = Extra.forbid

    isAssigned: IsAssigned = Field(
        ...,
        description='True indicates that this policy has been assigned, transferred, or pledged to a person or organization.',
    )


class IsAssigned1(Enum):
    boolean_True = True


class ProvideAssignmentStatusV3DataBag2(BaseModel):
    class Config:
        extra = Extra.forbid

    isAssigned: IsAssigned1 = Field(
        ...,
        description='True indicates that this policy has been assigned, transferred, or pledged to a person or organization.',
    )
    assigneeName: Name = Field(
        ...,
        description='The name of the person or organization to whom this policy has been assigned, transferred, or pledged.',
    )
    assignedDate: DateTime = Field(
        ...,
        description='The date on which the policy was assigned, transferred, or pledged to the `assignee`.',
    )


class ProvideAssignmentStatusV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    __root__: ProvideAssignmentStatusV3DataBag1 | ProvideAssignmentStatusV3DataBag2


class Action60(Enum):
    provideAssignmentStatus = 'provideAssignmentStatus'


class IsAssigned2(Enum):
    boolean_False = False


class DataBag441(BaseModel):
    class Config:
        extra = Extra.forbid

    isAssigned: IsAssigned2 = Field(
        ...,
        description='True indicates that this policy has been assigned, transferred, or pledged to a person or organization.',
    )


class IsAssigned3(Enum):
    boolean_True = True


class DataBag442(BaseModel):
    class Config:
        extra = Extra.forbid

    isAssigned: IsAssigned3 = Field(
        ...,
        description='True indicates that this policy has been assigned, transferred, or pledged to a person or organization.',
    )
    assigneeName: Name = Field(
        ...,
        description='The name of the person or organization to whom this policy has been assigned, transferred, or pledged.',
    )
    assignedDate: DateTime = Field(
        ...,
        description='The date on which the policy was assigned, transferred, or pledged to the `assignee`.',
    )


class DataBag443(BaseModel):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class DataBag444(DataBag441, DataBag443):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class DataBag445(DataBag442, DataBag443):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class DataBag44(BaseModel):
    __root__: DataBag444 | DataBag445 = Field(
        ...,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvideAssignmentStatusV3Response(BaseModel):
    ID: StepID
    action: Action60 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag44 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class LineItem(BaseModel):
    lineItem: str = Field(
        ...,
        description='The name or title of this line item (briefly describes the nature of the expense or credit).',
    )
    amount: MonetaryAmount = Field(
        ..., description='The monetary amount owed or credited for this line item.'
    )


class LineItems(BaseModel):
    __root__: list[LineItem] = Field(
        ...,
        description='A collection of individually tracked expenses or credits (line items) which combine to create a larger monetary amount (e.g. an overall fee, budget, or invoice).',
    )


class Action61(Enum):
    setDuplicatePolicyFee = 'setDuplicatePolicyFee'


class DataBag45(BaseModel):
    lineItems: LineItems = Field(
        ...,
        description='A collection of individually tracked expenses and credits that combine to create the overall duplicate policy fee.',
    )
    files: NoFiles | None = None


class SetDuplicatePolicyFeeV3Response(BaseModel):
    ID: StepID
    action: Action61 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag45 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action62(Enum):
    wrapUpRequestDuplicatePolicyV3 = 'wrapUpRequestDuplicatePolicyV3'


class WrapUpRequestDuplicatePolicyV3Response(BaseModel):
    ID: StepID
    action: Action62 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class RequestDuplicatePolicyV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        ProvideAddressResponse
        | ProvideAssignmentStatusV3Response
        | SetDuplicatePolicyFeeV3Response
        | InitializeSignatureResponse
        | ProvideSignatureResponse
        | ReviewSubmissionResponse
        | InitializeOneTimePaymentResponse
        | InitiateOneTimePaymentSessionResponse
        | ProvidePaymentResponse
        | SetOneTimePaymentInformationResponse
        | WrapUpRequestDuplicatePolicyV3Response
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ProvideAddressOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideAddressDataBag


class ProvideAssignmentStatusV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideAssignmentStatusV3DataBag


class Requestor(BaseModel):
    name: Name = Field(
        ..., description='The name of the person creating the help request.'
    )
    email: BaseEmail = Field(
        ..., description='The email address of the person creating the help request.'
    )
    phone: BasePhoneNumber = Field(
        ..., description='The phone number of the person creating the help request'
    )


class ComposeHelpRequestV2DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    requestor: Requestor = Field(
        ...,
        description='The person who is contacting the carrier or agency to request help.',
    )
    helpWith: str = Field(
        ...,
        description='The topic or category that best matches the content of the help request. May be used to route the request to appropriate personnel.',
        example='Questions concerning our products and services',
    )
    message: str = Field(
        ...,
        description='The text that the user writes asking for help. The carrier eventually reads and responds to this message.',
    )


class Action63(Enum):
    composeHelpRequest = 'composeHelpRequest'


class DataBag46(ComposeHelpRequestV2DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ComposeHelpRequestV2Response(BaseModel):
    ID: StepID
    action: Action63 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag46 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action64(Enum):
    wrapUpRequestHelp = 'wrapUpRequestHelp'


class WrapUpRequestHelpV2Response(BaseModel):
    ID: StepID
    action: Action64 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class RequestHelpV2StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[ComposeHelpRequestV2Response | WrapUpRequestHelpV2Response] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ComposeHelpRequestV2Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ComposeHelpRequestV2DataBag


class Action65(Enum):
    setLoanOptions = 'setLoanOptions'


class InterestType(Enum):
    Fixed = 'Fixed'


class InterestRateOptions(BaseModel):
    interestType: InterestType = Field(
        ..., description='An interest rate that stays the same over time.'
    )
    rate: NonNegativePercent = Field(
        ...,
        description='The fixed annual percentage interest rate applied to the loan amount.',
    )
    unit: str = Field(
        ...,
        description='The unit of the fixed interest rate, which defines how the interest rate is measured or applied.',
        example='APR',
    )


class InterestType1(Enum):
    Variable = 'Variable'


class InterestRateOptions1(BaseModel):
    interestType: InterestType1 = Field(
        ..., description='An interest rate that may change over time.'
    )


class LoanAmountRange(BaseModel):
    minimumLoanAmount: MonetaryAmount = Field(
        ...,
        description='The minimum amount of money that can be withdrawn as a loan against a policy.',
    )
    maximumLoanAmount: MonetaryAmount = Field(
        ...,
        description='The maximum amount of money that can be withdrawn as a loan against a policy.',
    )


class DataBag47(BaseModel):
    class Config:
        extra = Extra.forbid

    interestRateOptions: list[InterestRateOptions | InterestRateOptions1] = Field(
        ...,
        description='A collection of interest rates choices that the carrier allows for loans taken out against a policy.',
        max_items=2,
        min_items=1,
    )
    loanAmountRange: LoanAmountRange = Field(
        ...,
        description='A range of how much money the carrier allows to be withdrawn as a loan against a policy.',
    )
    files: NoFiles


class SetLoanOptionsV3Response(BaseModel):
    ID: StepID
    action: Action65 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag47 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class InterestType2(Enum):
    Fixed = 'Fixed'
    Variable = 'Variable'


class ProvideLoanAmountV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    loanAmount: MonetaryAmount = Field(
        ...,
        description='The total amount of money the user chooses to withdraw as a loan against the policy.',
    )
    interestType: InterestType2 = Field(
        ...,
        description='The kind of interest rate the user chooses for the loan (either Fixed or Variable).',
    )


class Action66(Enum):
    provideLoanAmount = 'provideLoanAmount'


class DataBag48(ProvideLoanAmountV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ProvideLoanAmountV3Response(BaseModel):
    ID: StepID
    action: Action66 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag48 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class AnswerIsWithholdingTaxesV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    isWithholdingTaxes: bool = Field(
        ...,
        description='True indicates that the user has opted to have federal and/or state income taxes withheld from the disbursed loan amount.',
    )


class Action67(Enum):
    answerIsWithholdingTaxes = 'answerIsWithholdingTaxes'


class DataBag49(AnswerIsWithholdingTaxesV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class AnswerIsWithholdingTaxesV3Response(BaseModel):
    ID: StepID
    action: Action67 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag49 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action68(Enum):
    setRepaymentOptions = 'setRepaymentOptions'


class RepaymentTermOptionsInYear(BaseModel):
    repaymentTermOptionInYears: Duration = Field(
        ...,
        description='An individual option for how many years the borrower (i.e. the user) has to repay the loan. Only whole years are allowed (i.e. ISO 8601 PnY, where n is a positive integer).',
    )


class RepaymentTermRangeToFundResidenceItem(BaseModel):
    class Config:
        extra = Extra.forbid

    minimumTermToFundResidence: Duration = Field(
        ...,
        description='The minimum number of years that the borrower (i.e. the user) may take to repay a loan funding the purchase of a primary residence.  Only whole years are allowed (i.e. ISO 8601 PnY, where n is a positive integer).',
    )
    maximumTermToFundResidence: Duration = Field(
        ...,
        description='The maximum number of years that the borrower (i.e. the user) may take to repay a loan funding the purchase of a primary residence.  Only whole years are allowed (i.e. ISO 8601 PnY, where n is a positive integer).',
    )


class RepaymentFrequencyOption(Enum):
    Monthly = 'Monthly'
    Quarterly = 'Quarterly'
    SemiAnnually = 'SemiAnnually'
    Annually = 'Annually'
    BiWeekly = 'BiWeekly'


class DataBag50(BaseModel):
    class Config:
        extra = Extra.forbid

    repaymentTermOptionsInYears: list[RepaymentTermOptionsInYear] = Field(
        ...,
        description='A collection of options for how many years that the carrier allows the borrower (i.e. the user) to take to repay the loan.',
        max_items=32768,
        min_items=1,
    )
    repaymentTermRangeToFundResidence: list[RepaymentTermRangeToFundResidenceItem] = (
        Field(
            ...,
            description='The maximum and minimum term duration options that the carrier allows when the loan against the policy is being used to fund the purchase of a primary residence.',
            max_items=2,
            min_items=2,
        )
    )
    repaymentFrequencyOptions: list[RepaymentFrequencyOption] = Field(
        ...,
        description='A collection of options that the carrier allows for how often loan repayments can be made (e.g. monthly repayments, quarterly repayments, etc).',
        max_items=32768,
        min_items=1,
    )
    files: NoFiles


class SetRepaymentOptionsV3Response(BaseModel):
    ID: StepID
    action: Action68 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag50 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ChooseRepaymentTermV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    repaymentTermInYears: Duration = Field(
        ...,
        description='The number of years in which the user (i.e. the borrower) has committed to repaying the loan.  Only whole years are allowed (i.e. ISO 8601 PnY, where n is a positive integer).',
    )


class Action69(Enum):
    chooseRepaymentTerm = 'chooseRepaymentTerm'


class DataBag56(ChooseRepaymentTermV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ChooseRepaymentTermV3Response(BaseModel):
    ID: StepID
    action: Action69 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag56 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action70(Enum):
    detectIfLoanFundsResidence = 'detectIfLoanFundsResidence'


class DetectIfLoanFundsResidenceV3Response(BaseModel):
    ID: StepID
    action: Action70 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class ProvideResidenceAddressV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    residenceAddress: BaseAddress = Field(
        ...,
        description='The address of the residence which the borrower will purchase using the funds from the loan against the policy.',
    )


class Action71(Enum):
    provideResidenceAddress = 'provideResidenceAddress'


class DataBag57(ProvideResidenceAddressV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ProvideResidenceAddressV3Response(BaseModel):
    ID: StepID
    action: Action71 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag57 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class RepaymentFrequency(Enum):
    Monthly = 'Monthly'
    Quarterly = 'Quarterly'
    SemiAnnually = 'SemiAnnually'
    Annually = 'Annually'
    BiWeekly = 'BiWeekly'


class ChooseRepaymentFrequencyV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    repaymentFrequency: RepaymentFrequency = Field(
        ...,
        description='The frequency at which the user chooses to schedule their loan repayments.',
    )


class Action72(Enum):
    chooseRepaymentFrequency = 'chooseRepaymentFrequency'


class DataBag58(ChooseRepaymentFrequencyV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ChooseRepaymentFrequencyV3Response(BaseModel):
    ID: StepID
    action: Action72 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag58 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Check(BaseModel):
    hasAgreedToMailCheck: bool = Field(
        ...,
        description='True indicates that the user has agreed to mail in a physical check to the carrier.',
    )
    files: NoFiles


class EFT(BaseModel):
    files: Binaries = Field(
        ...,
        description='A photo of a voided check, which will be used to set up electronic funds transfer (EFT) for loan repayment.',
    )


class Action73(Enum):
    chooseRepaymentMethod = 'chooseRepaymentMethod'


class Files(BaseModel):
    pass


class DataBag59(EFT):
    class Config:
        extra = Extra.forbid

    files: list[File] | Files = Field(
        ...,
        description='A photo of a voided check, which will be used to set up electronic funds transfer (EFT) for loan repayment.',
        max_items=1,
        min_items=1,
    )


class ChooseRepaymentMethodV3Response(BaseModel):
    ID: StepID
    action: Action73 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: Check | DataBag59 | None = Field(
        None,
        description='A data bag that collects files, but does not collect structured data.',
    )


class AccountNumber(BaseModel):
    __root__: str = Field(
        ...,
        description='The account number for a payment method.',
        example='6541-5421-1564-8157',
    )


class PayoutType(Enum):
    check = 'check'


class Payout1(BaseModel):
    payoutType: PayoutType = Field(
        ...,
        description='A transaction type indicating that payments are processed using a check, which may be issued as a physical or electronic check.',
    )


class PayoutType1(Enum):
    bank = 'bank'


class Payout2(BaseModel):
    payoutType: PayoutType1 = Field(
        ...,
        description="A transaction type indicating that payments are processed through a direct bank transfer using the recipient's bank account details.",
    )
    accountHolderFullName: constr(min_length=1, max_length=255) = Field(
        ...,
        description='The full name of the person that the account belongs to.',
        example='Bob Smith',
    )
    accountNumber: AccountNumber
    routingNumber: str = Field(
        ...,
        description='The routing number associated with the account.',
        example='912546365',
    )
    bankName: str = Field(
        ..., description='The name of the bank providing this account.'
    )


class Payout(BaseModel):
    __root__: Payout1 | Payout2


class Action74(Enum):
    chooseDisbursementMethod = 'chooseDisbursementMethod'


class PayoutType2(Enum):
    check = 'check'


class DataBag601(BaseModel):
    payoutType: PayoutType2 = Field(
        ...,
        description='A transaction type indicating that payments are processed using a check, which may be issued as a physical or electronic check.',
    )


class PayoutType3(Enum):
    bank = 'bank'


class DataBag602(BaseModel):
    payoutType: PayoutType3 = Field(
        ...,
        description="A transaction type indicating that payments are processed through a direct bank transfer using the recipient's bank account details.",
    )
    accountHolderFullName: constr(min_length=1, max_length=255) = Field(
        ...,
        description='The full name of the person that the account belongs to.',
        example='Bob Smith',
    )
    accountNumber: AccountNumber
    routingNumber: str = Field(
        ...,
        description='The routing number associated with the account.',
        example='912546365',
    )
    bankName: str = Field(
        ..., description='The name of the bank providing this account.'
    )


class DataBag603(BaseModel):
    files: NoFiles


class DataBag604(DataBag601, DataBag603):
    pass


class DataBag605(DataBag602, DataBag603):
    pass


class DataBag60(BaseModel):
    __root__: DataBag604 | DataBag605 = Field(
        ...,
        description='A data bag that collects structured data but does not collect files.',
    )


class ChooseDisbursementMethodResponse(BaseModel):
    ID: StepID
    action: Action74 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any]
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag60 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ReviewTermsAndConditionsDataBag(BaseModel):
    isAcknowledged: bool = Field(
        ...,
        description='True indicates that the user has acknowledged the terms and conditions.',
        example=True,
    )


class Action75(Enum):
    reviewTermsAndConditions = 'reviewTermsAndConditions'


class DataBag61(ReviewTermsAndConditionsDataBag):
    files: NoFiles


class ReviewTermsAndConditionsResponse(BaseModel):
    ID: StepID
    action: Action75 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any]
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag61 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action76(Enum):
    wrapUpRequestPolicyLoan = 'wrapUpRequestPolicyLoan'


class WrapUpRequestPolicyLoanV3(BaseModel):
    ID: StepID
    action: Action76 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class RequestPolicyLoanV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        SetLoanOptionsV3Response
        | ProvideLoanAmountV3Response
        | AnswerIsWithholdingTaxesV3Response
        | SetRepaymentOptionsV3Response
        | ChooseRepaymentTermV3Response
        | DetectIfLoanFundsResidenceV3Response
        | ProvideResidenceAddressV3Response
        | ChooseRepaymentFrequencyV3Response
        | ChooseRepaymentMethodV3Response
        | ChooseDisbursementMethodResponse
        | ReviewTermsAndConditionsResponse
        | WrapUpRequestPolicyLoanV3
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ProvideLoanAmountV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideLoanAmountV3DataBag


class AnswerIsWithholdingTaxesV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: AnswerIsWithholdingTaxesV3DataBag


class ChooseRepaymentTermV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ChooseRepaymentTermV3DataBag


class ProvideResidenceAddressV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideResidenceAddressV3DataBag


class ChooseRepaymentFrequencyV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ChooseRepaymentFrequencyV3DataBag


class ChooseRepaymentMethodV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    __root__: Check | EFT


class ChooseRepaymentMethodV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ChooseRepaymentMethodV3DataBag


class ChooseDisbursementMethodOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: Payout


class ReviewTermsAndConditionsOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ReviewTermsAndConditionsDataBag


class Action77(Enum):
    telescopeAnswerIsFirstRMD = 'telescopeAnswerIsFirstRMD'


class TelescopeAnswerIsFirstRMDResponse(BaseModel):
    ID: StepID
    action: Action77 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class AnswerIsFirstRMDDataBag(BaseModel):
    class Config:
        extra = Extra.allow

    isFirstRMD: bool = Field(
        ...,
        description='True indicates that this is the first Required Minimum Distribution request.',
        example=True,
    )


class Action78(Enum):
    answerIsFirstRMD = 'answerIsFirstRMD'


class SectionKey13(Enum):
    RequiredMinimumDistribution = 'RequiredMinimumDistribution'


class Attributes13(BaseModel):
    class Config:
        extra = Extra.forbid

    sectionKey: SectionKey13 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag62(AnswerIsFirstRMDDataBag):
    files: NoFiles


class AnswerIsFirstRMDResponse(BaseModel):
    ID: StepID
    action: Action78 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes13 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag62 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action79(Enum):
    telescopeRMDCalculationMethod = 'telescopeRMDCalculationMethod'


class TelescopeRMDCalculationMethodResponse(BaseModel):
    ID: StepID
    action: Action79 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class AnswerIsRMDUserCalculatedDataBag(BaseModel):
    isRMDUserCalculated: bool = Field(
        ...,
        description='True indicates that the user will calculate their own Required Minimum Distribution amount.',
        example=True,
    )


class Action80(Enum):
    answerIsRMDUserCalculated = 'answerIsRMDUserCalculated'


class Attributes14(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey13 = Field(
        ..., description='The name of the section to which this step belongs to.'
    )


class DataBag63(AnswerIsRMDUserCalculatedDataBag):
    files: NoFiles


class AnswerIsRMDUserCalculatedResponse(BaseModel):
    ID: StepID
    action: Action80 = Field(
        ...,
        description='The name of the step which briefly summarizes what this step does.',
    )
    attributes: Attributes14 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag63 | None = Field(
        None,
        description='A data bag that does not collect any files, but does collect structured data.',
    )


class Action81(Enum):
    telescopeRMDCalculation = 'telescopeRMDCalculation'


class TelescopeRMDCalculationResponse(BaseModel):
    ID: StepID
    action: Action81 = Field(
        ...,
        description='The name of the step which briefly summarizes what this step does.',
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class ProvideUserCalculatedDistributionAmountDataBag(BaseModel):
    userCalculatedDistributionAmount: NonNegativeMonetaryAmount = Field(
        ..., description='The distribution amount manually calculated by the user.'
    )


class Action82(Enum):
    provideUserCalculatedDistributionAmount = 'provideUserCalculatedDistributionAmount'


class Attributes15(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey13 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag64(ProvideUserCalculatedDistributionAmountDataBag):
    files: NoFiles


class ProvideUserCalculatedDistributionAmountResponse(BaseModel):
    ID: StepID
    action: Action82 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes15 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag64 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class CalculationTable(Enum):
    UniformLifetimeTable = 'UniformLifetimeTable'


class ChooseCalculationTableDataBag1(BaseModel):
    calculationTable: CalculationTable = Field(
        ...,
        description="The default table that is used to calculate the Required Minimum Distribution UNLESS both of the following are true:\n  1. The policyowner has designated their spouse as the sole beneficiary of the policy\n  2. The policyowner's spouse is more than 10 years younger than the policyowner.\n",
    )


class CalculationTable1(Enum):
    JointAndLastSurvivorTable = 'JointAndLastSurvivorTable'


class ChooseCalculationTableDataBag2(BaseModel):
    calculationTable: CalculationTable1 = Field(
        ...,
        description="A table that is used to calculate the Required Minimum Distribution ONLY when both of the following are true:\n 1. The policyowner has designated their spouse as the sole beneficiary of the policy\n 2. The policyowner's spouse is more than 10 years younger than the policyowner.\n",
    )
    spouse: BasePerson = Field(
        ..., description='The husband or wife of the policyowner.'
    )


class ChooseCalculationTableDataBag(BaseModel):
    __root__: ChooseCalculationTableDataBag1 | ChooseCalculationTableDataBag2


class Action83(Enum):
    chooseCalculationTable = 'chooseCalculationTable'


class Attributes16(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey13 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class CalculationTable2(Enum):
    UniformLifetimeTable = 'UniformLifetimeTable'


class DataBag651(BaseModel):
    calculationTable: CalculationTable2 = Field(
        ...,
        description="The default table that is used to calculate the Required Minimum Distribution UNLESS both of the following are true:\n  1. The policyowner has designated their spouse as the sole beneficiary of the policy\n  2. The policyowner's spouse is more than 10 years younger than the policyowner.\n",
    )


class CalculationTable3(Enum):
    JointAndLastSurvivorTable = 'JointAndLastSurvivorTable'


class DataBag652(BaseModel):
    calculationTable: CalculationTable3 = Field(
        ...,
        description="A table that is used to calculate the Required Minimum Distribution ONLY when both of the following are true:\n 1. The policyowner has designated their spouse as the sole beneficiary of the policy\n 2. The policyowner's spouse is more than 10 years younger than the policyowner.\n",
    )
    spouse: BasePerson = Field(
        ..., description='The husband or wife of the policyowner.'
    )


class DataBag653(BaseModel):
    files: NoFiles


class DataBag654(DataBag651, DataBag653):
    pass


class DataBag655(DataBag652, DataBag653):
    pass


class DataBag65(BaseModel):
    __root__: DataBag654 | DataBag655 = Field(
        ...,
        description='A data bag that collects structured data but does not collect files.',
    )


class ChooseCalculationTableResponse(BaseModel):
    ID: StepID
    action: Action83 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes16 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag65 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action84(Enum):
    setDistributionScheduleConstraints = 'setDistributionScheduleConstraints'


class ExcludedSystematicDistributionDay(BaseModel):
    __root__: conint(ge=1, le=31)


class DataBag66(BaseModel):
    excludedSystematicDistributionDays: list[ExcludedSystematicDistributionDay] = Field(
        ...,
        description='A collection of calendar days on which automated payouts are not allowed.',
        example=[29, 30, 31],
        max_items=31,
        min_items=0,
        unique_items=True,
    )
    RMDFrequencyOptions: list[str] = Field(
        ...,
        description='A collection of options for how often a user can receive Required Minimum Distribution payouts.',
        example=['Monthly', 'Quarterly', 'Annually'],
        min_items=1,
    )
    files: NoFiles


class SetDistributionScheduleConstraintsResponse(BaseModel):
    ID: StepID
    action: Action84 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag66 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class OnReceipt1(BaseModel):
    distributionAmount: MonetaryAmount = Field(
        ...,
        description='The user-specified amount to be disbursed immediately upon receipt of the request.',
    )
    distributionDate: DateTime | None = Field(
        None,
        description='The user-specified date on which the distribution should be processed.',
    )


class OnReceipt(BaseModel):
    onReceipt: OnReceipt1


class Systematic1(BaseModel):
    distributionAmount: MonetaryAmount = Field(
        ..., description='The amount to be distributed in each systematic payment.'
    )
    distributionStartDate: DateTime = Field(
        ...,
        description='The date on which the first systematic distribution is processed.',
    )
    distributionFrequency: str = Field(
        ...,
        description='The frequency at which systematic distributions are made (e.g. Monthly).',
    )


class Systematic(BaseModel):
    systematic: Systematic1


class ProvideUserCalculatedDistributionScheduleDataBag(BaseModel):
    __root__: OnReceipt | Systematic


class Action85(Enum):
    provideUserCalculatedDistributionSchedule = (
        'provideUserCalculatedDistributionSchedule'
    )


class Attributes17(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey13 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag671(BaseModel):
    files: NoFiles


class DataBag672(OnReceipt, DataBag671):
    pass


class DataBag673(Systematic, DataBag671):
    pass


class DataBag67(BaseModel):
    __root__: DataBag672 | DataBag673 = Field(
        ...,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvideUserCalculatedDistributionScheduleResponse(BaseModel):
    ID: StepID
    action: Action85 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes17 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag67 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action86(Enum):
    setRMDDeferralDuration = 'setRMDDeferralDuration'


class DataBag68(BaseModel):
    class Config:
        extra = Extra.forbid

    files: NoFiles
    RMDDeferralDuration: Duration = Field(
        ...,
        description='The length of time the user chooses to defer the start of their Required Minimum Distribution after making the initial request.',
    )


class SetRMDDeferralDurationResponse(BaseModel):
    ID: StepID
    action: Action86 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag68 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class DistributionType(Enum):
    OnReceipt = 'OnReceipt'


class ProvideCarrierCalculatedDistributionScheduleDataBag1(BaseModel):
    distributionType: DistributionType = Field(
        ...,
        description='The full Required Minimum Distribution is to be disbursed in a single payout shortly after the user initiates the request.',
    )
    distributionDate: DateTime | None = Field(
        None,
        description='The user-specified date on which the distribution should be processed.',
        example='2025-09-29',
    )


class DistributionType1(Enum):
    Systematic = 'Systematic'


class ProvideCarrierCalculatedDistributionScheduleDataBag2(BaseModel):
    distributionType: DistributionType1 = Field(
        ...,
        description='The Required Minimum Distribution is to be paid out in recurring installments based on a selected frequency and start date.',
    )
    distributionStartDate: DateTime = Field(
        ...,
        description='The date on which the first systematic distribution is processed.',
        example='2025-10-29',
    )
    distributionFrequency: str = Field(
        ...,
        description='The frequency at which Required Minimum Distribution payments are made (e.g. Monthly, Quarterly, Semi-annually, or Annually).',
        example='Monthly',
    )


class DistributionType2(Enum):
    Deferral = 'Deferral'


class ProvideCarrierCalculatedDistributionScheduleDataBag3(BaseModel):
    distributionType: DistributionType2 = Field(
        ...,
        description='The user chooses to delay the start of their Required Minimum Distribution to a specific future date instead of receiving it immediately.',
    )
    deferralDate: DateTime = Field(
        ...,
        description='The date when the deferred distribution is scheduled to occur.',
        example='2029-10-29',
    )


class ProvideCarrierCalculatedDistributionScheduleDataBag(BaseModel):
    __root__: (
        ProvideCarrierCalculatedDistributionScheduleDataBag1
        | ProvideCarrierCalculatedDistributionScheduleDataBag2
        | ProvideCarrierCalculatedDistributionScheduleDataBag3
    )


class Action87(Enum):
    provideCarrierCalculatedDistributionSchedule = (
        'provideCarrierCalculatedDistributionSchedule'
    )


class Attributes18(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey13 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DistributionType3(Enum):
    OnReceipt = 'OnReceipt'


class DataBag691(BaseModel):
    distributionType: DistributionType3 = Field(
        ...,
        description='The full Required Minimum Distribution is to be disbursed in a single payout shortly after the user initiates the request.',
    )
    distributionDate: DateTime | None = Field(
        None,
        description='The user-specified date on which the distribution should be processed.',
        example='2025-09-29',
    )


class DistributionType4(Enum):
    Systematic = 'Systematic'


class DataBag692(BaseModel):
    distributionType: DistributionType4 = Field(
        ...,
        description='The Required Minimum Distribution is to be paid out in recurring installments based on a selected frequency and start date.',
    )
    distributionStartDate: DateTime = Field(
        ...,
        description='The date on which the first systematic distribution is processed.',
        example='2025-10-29',
    )
    distributionFrequency: str = Field(
        ...,
        description='The frequency at which Required Minimum Distribution payments are made (e.g. Monthly, Quarterly, Semi-annually, or Annually).',
        example='Monthly',
    )


class DistributionType5(Enum):
    Deferral = 'Deferral'


class DataBag693(BaseModel):
    distributionType: DistributionType5 = Field(
        ...,
        description='The user chooses to delay the start of their Required Minimum Distribution to a specific future date instead of receiving it immediately.',
    )
    deferralDate: DateTime = Field(
        ...,
        description='The date when the deferred distribution is scheduled to occur.',
        example='2029-10-29',
    )


class DataBag694(BaseModel):
    files: NoFiles


class DataBag695(DataBag691, DataBag694):
    pass


class DataBag696(DataBag692, DataBag694):
    pass


class DataBag697(DataBag693, DataBag694):
    pass


class DataBag69(BaseModel):
    __root__: DataBag695 | DataBag696 | DataBag697 = Field(
        ...,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvideCarrierCalculatedDistributionScheduleResponse(BaseModel):
    ID: StepID
    action: Action87 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes18 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag69 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class TaxWithholdingPreference(Enum):
    State = 'State'
    Federal = 'Federal'
    StateAndFederal = 'StateAndFederal'
    None_ = 'None'


class ChooseTaxWithholdingPreferenceDataBag(BaseModel):
    taxWithholdingPreference: TaxWithholdingPreference = Field(
        ...,
        description="The policyowner's preference regarding how taxes will be withheld from the Required Minimum Distribution amount.  Policyowners can choose to withhold state taxes, federal taxes, both, or none.",
    )


class Action88(Enum):
    chooseTaxWithholdingPreference = 'chooseTaxWithholdingPreference'


class SectionKey19(Enum):
    DisbursementDetails = 'DisbursementDetails'


class Attributes19(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey19 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class DataBag70(ChooseTaxWithholdingPreferenceDataBag):
    files: NoFiles


class ChooseTaxWithholdingPreferenceResponse(BaseModel):
    ID: StepID
    action: Action88 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes19 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag70 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Attributes20(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey19 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class SchemasChooseDisbursementMethodResponse(ChooseDisbursementMethodResponse):
    attributes: Attributes20 | None = Field(
        None,
        description='A collection of metadata items that the journey author has attached to this step.',
    )


class HasRolloverAssets(Enum):
    boolean_True = True


class ProvideRolloverAssetsDataBag1(BaseModel):
    hasRolloverAssets: HasRolloverAssets
    totalRolloverAmount: NonNegativeMonetaryAmount = Field(
        ...,
        description='The total amount of assets that were transferred or rolled over into this contract.',
    )
    totalReductionsAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount from this contract that has already been applied towards Required Minimum Distributions during this calendar year.',
    )


class HasRolloverAssets1(Enum):
    boolean_False = False


class ProvideRolloverAssetsDataBag2(BaseModel):
    hasRolloverAssets: HasRolloverAssets1


class ProvideRolloverAssetsDataBag(BaseModel):
    __root__: ProvideRolloverAssetsDataBag1 | ProvideRolloverAssetsDataBag2


class Action89(Enum):
    provideRolloverAssets = 'provideRolloverAssets'


class Attributes21(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey19 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class HasRolloverAssets2(Enum):
    boolean_True = True


class DataBag711(BaseModel):
    hasRolloverAssets: HasRolloverAssets2
    totalRolloverAmount: NonNegativeMonetaryAmount = Field(
        ...,
        description='The total amount of assets that were transferred or rolled over into this contract.',
    )
    totalReductionsAmount: NonNegativeMonetaryAmount | None = Field(
        None,
        description='The total amount from this contract that has already been applied towards Required Minimum Distributions during this calendar year.',
    )


class HasRolloverAssets3(Enum):
    boolean_False = False


class DataBag712(BaseModel):
    hasRolloverAssets: HasRolloverAssets3


class DataBag713(BaseModel):
    files: NoFiles


class DataBag714(DataBag711, DataBag713):
    pass


class DataBag715(DataBag712, DataBag713):
    pass


class DataBag71(BaseModel):
    __root__: DataBag714 | DataBag715 = Field(
        ...,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvideRolloverAssetsResponse(BaseModel):
    ID: StepID
    action: Action89 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: Attributes21 = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag71 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Attributes22(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey19 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class SchemasReviewTermsAndConditionsResponse(ReviewTermsAndConditionsResponse):
    attributes: Attributes22 | None = Field(
        None,
        description='A collection of metadata items that the journey author has attached to this step.',
    )


class Attributes23(BaseModel):
    class Config:
        extra = Extra.allow

    sectionKey: SectionKey19 = Field(
        ..., description='The name of the section this step belongs to.'
    )


class ComponentsSchemasProvideSignatureResponse(ProvideSignatureResponse):
    attributes: Attributes23 | None = Field(
        None,
        description='A collection of metadata items that the journey author has attached to this step.',
    )


class Action90(Enum):
    wrapUpRequestRMD = 'wrapUpRequestRMD'


class WrapUpRequestRMDResponse(BaseModel):
    ID: StepID
    action: Action90 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class RequestRequiredMinimumDistributionStateComponentsSchemasJourneyResponse(
    BaseModel
):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        TelescopeAnswerIsFirstRMDResponse
        | AnswerIsFirstRMDResponse
        | TelescopeRMDCalculationMethodResponse
        | AnswerIsRMDUserCalculatedResponse
        | TelescopeRMDCalculationResponse
        | ProvideUserCalculatedDistributionAmountResponse
        | ChooseCalculationTableResponse
        | SetDistributionScheduleConstraintsResponse
        | ProvideUserCalculatedDistributionScheduleResponse
        | SetRMDDeferralDurationResponse
        | ProvideCarrierCalculatedDistributionScheduleResponse
        | ChooseTaxWithholdingPreferenceResponse
        | SchemasChooseDisbursementMethodResponse
        | ProvideRolloverAssetsResponse
        | SchemasReviewTermsAndConditionsResponse
        | ComponentsSchemasProvideSignatureResponse
        | WrapUpRequestRMDResponse
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class AnswerIsFirstRMDOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: AnswerIsFirstRMDDataBag


class AnswerIsRMDUserCalculatedOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: AnswerIsRMDUserCalculatedDataBag


class ChooseCalculationTableOperation(BaseModel):
    operation: Operation19 | None = None
    params: ChooseCalculationTableDataBag


class ProvideCarrierCalculatedDistributionScheduleOperation(BaseModel):
    operation: Operation19 | None = None
    params: ProvideCarrierCalculatedDistributionScheduleDataBag


class ProvideUserCalculatedDistributionAmountOperation(BaseModel):
    operation: Operation19 | None = None
    params: ProvideUserCalculatedDistributionAmountDataBag


class ProvideUserCalculatedDistributionScheduleOperation(BaseModel):
    operation: Operation19 | None = None
    params: ProvideUserCalculatedDistributionScheduleDataBag


class ChooseTaxWithholdingPreferenceOperation(BaseModel):
    operation: Operation19 | None = None
    params: ChooseTaxWithholdingPreferenceDataBag


class ProvideRolloverAssetsOperation(BaseModel):
    operation: Operation19 | None = None
    params: ProvideRolloverAssetsDataBag


class Action91(Enum):
    setAdditionalPaymentReasons = 'setAdditionalPaymentReasons'


class DataBag72(BaseModel):
    additionalPaymentReasons: list[str] = Field(
        ...,
        description='A collection of possible reasons for making an additional payment.',
        example=['Pay future premiums in advance', 'Fund rider or policy feature'],
        min_items=1,
    )
    files: NoFiles


class SetAdditionalPaymentReasonsResponse(BaseModel):
    ID: StepID
    action: Action91 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag72 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class NonEmptyString(BaseModel):
    __root__: constr(regex=r'^(?! *$).*', min_length=1, max_length=32767) = Field(
        ...,
        description='A string that is non-empty and not composed entirely of whitespace-only characters.',
        example='John Doe',
    )


class ChooseAdditionalPaymentReasonDataBag(BaseModel):
    additionalPaymentReason: NonEmptyString = Field(
        ..., description='The reason for making an additional payment.'
    )


class Action92(Enum):
    chooseAdditionalPaymentReason = 'chooseAdditionalPaymentReason'


class DataBag73(ChooseAdditionalPaymentReasonDataBag):
    files: NoFiles
    additionalPaymentReason: NonEmptyString = Field(
        ..., description='The reason for making an additional payment.'
    )


class ChooseAdditionalPaymentReasonResponse(BaseModel):
    ID: StepID
    action: Action92 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag73 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action93(Enum):
    setAdditionalPaymentAmountRange = 'setAdditionalPaymentAmountRange'


class AdditionalPaymentAmountRange(BaseModel):
    minimumAmount: NonNegativeMonetaryAmount = Field(
        ...,
        description='The minimum allowable additional payment, determined by the policy type.',
    )
    maximumAmount: NonNegativeMonetaryAmount = Field(
        ...,
        description='The maximum allowable additional payment, determined by the policy type.',
    )


class DataBag74(BaseModel):
    additionalPaymentAmountRange: AdditionalPaymentAmountRange
    files: NoFiles


class SetAdditionalPaymentAmountRangeResponse(BaseModel):
    ID: StepID
    action: Action93 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag74 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvideAdditionalPaymentAmountDataBag(BaseModel):
    additionalPaymentAmount: NonNegativeMonetaryAmount = Field(
        ...,
        description='The additional amount the policyowner chooses to pay toward a life or annuity policy.',
    )


class Action94(Enum):
    provideAdditionalPaymentAmount = 'provideAdditionalPaymentAmount'


class DataBag75(ProvideAdditionalPaymentAmountDataBag):
    files: NoFiles
    additionalPaymentAmount: NonNegativeMonetaryAmount = Field(
        ...,
        description='The additional amount the policyowner chooses to pay toward a life or annuity policy.',
    )


class ProvideAdditionalPaymentAmountResponse(BaseModel):
    ID: StepID
    action: Action94 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag75 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvideAcknowledgementDataBag(BaseModel):
    isAcknowledged: bool = Field(
        ...,
        description='True indicates that the user has acknowledged and agreed to the disclosed information.',
        example=True,
    )


class Action95(Enum):
    provideAcknowledgement = 'provideAcknowledgement'


class DataBag76(ProvideAcknowledgementDataBag):
    files: NoFiles
    isAcknowledged: bool = Field(
        ...,
        description='True indicates that the user has acknowledged and agreed to the disclosed information.',
        example=True,
    )


class ProvideAcknowledgementResponse(BaseModel):
    ID: StepID
    action: Action95 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag76 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action96(Enum):
    initializePayment = 'initializePayment'


class DataBag77(BaseModel):
    paymentAmount: NonNegativeMonetaryAmount = Field(
        ...,
        description='The additional payment amount the policyowner chooses to pay towards a life or annuity policy.',
    )
    paymentDescription: constr(min_length=1, max_length=32767) | None = Field(
        None,
        description='The description that is used for creating a payment session identifier.',
    )
    payor: BasePerson | None = Field(
        None,
        description='The payor information that is used for creating a payment session identifier.',
    )
    files: NoFiles


class InitializePaymentResponse(BaseModel):
    ID: StepID
    action: Action96 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag77 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action97(Enum):
    setCarrierPostalAddress = 'setCarrierPostalAddress'


class DataBag78(BaseModel):
    files: NoFiles
    name: str | None = Field(
        None,
        description='The name of the person to whom the carrier postal address belongs.',
    )
    address: BaseAddress = Field(..., description='The carrier postal address.')


class SetCarrierPostalAddressResponse(BaseModel):
    ID: StepID
    action: Action97 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag78 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class FormOfPayment(Enum):
    Check = 'Check'
    Card = 'Card'
    Bank = 'Bank'


class ChooseFormOfPaymentDataBag(BaseModel):
    formOfPayment: FormOfPayment = Field(
        ...,
        description='Specifies the payment method for a transaction. The available payment methods are:\n - **Check:** A physical check payment mailed to the registered address.\n - **Card:** A credit or debit card that is used to make payments.\n - **Bank:** A bank account used to make payments via direct transfer using the recipients bank account details.\n',
    )


class Action98(Enum):
    chooseFormOfPayment = 'chooseFormOfPayment'


class DataBag79(ChooseFormOfPaymentDataBag):
    files: NoFiles
    formOfPayment: FormOfPayment = Field(
        ...,
        description='Specifies the payment method for a transaction. The available payment methods are:\n - **Check:** A physical check payment mailed to the registered address.\n - **Card:** A credit or debit card that is used to make payments.\n - **Bank:** A bank account used to make payments via direct transfer using the recipients bank account details.\n',
    )


class ChooseFormOfPaymentResponse(BaseModel):
    ID: StepID
    action: Action98 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag79 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ReviewPaymentDetailsDataBag(BaseModel):
    isAcknowledged: bool = Field(
        ...,
        description='True indicates that the user has confirmed that the payment information is correct.',
        example=True,
    )


class Action99(Enum):
    reviewPaymentDetails = 'reviewPaymentDetails'


class DataBag80(ReviewPaymentDetailsDataBag):
    files: NoFiles
    isAcknowledged: bool = Field(
        ...,
        description='True indicates that the user has confirmed that the payment information is correct.',
        example=True,
    )


class ReviewPaymentDetailsResponse(BaseModel):
    ID: StepID
    action: Action99 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag80 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action100(Enum):
    detectFormOfPayment = 'detectFormOfPayment'


class DetectFormOfPaymentResponse(BaseModel):
    ID: StepID
    action: Action100 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class Action101(Enum):
    initiatePaymentSession = 'initiatePaymentSession'


class DataBag81(BaseModel):
    paymentSessionID: SchemasID = Field(
        ...,
        description='A unique payment session ID, issued by a 3rd party payment service.',
    )
    files: NoFiles


class InitiatePaymentSessionResponse(BaseModel):
    ID: StepID
    action: Action101 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag81 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action102(Enum):
    validatePaymentToken = 'validatePaymentToken'


class ValidatePaymentTokenResponse(BaseModel):
    ID: StepID
    action: Action102 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class Action103(Enum):
    setPaymentInformation = 'setPaymentInformation'


class Type28(Enum):
    Credit = 'Credit'
    Debit = 'Debit'


class FormOfPayment1(CreditCard):
    type: Type28 | None = Field(None, description='The type of card.')


class FormOfPayment2(Enum):
    Check = 'Check'


class DataBag82(BaseModel):
    formOfPayment: BankAccount | FormOfPayment1 | FormOfPayment2 | None = Field(
        None,
        description='The payment method selected by the policyowner to make the additional payment.',
    )
    paymentStatus: constr(min_length=1, max_length=32000) = Field(
        ..., description='The status of the payment.'
    )
    files: NoFiles


class SetPaymentInformationResponse(BaseModel):
    ID: StepID
    action: Action103 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag82 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action104(Enum):
    wrapUpMakeAdditionalPayment = 'wrapUpMakeAdditionalPayment'


class WrapUpMakeAdditionalPaymentResponse(BaseModel):
    ID: StepID
    action: Action104 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class MakeAdditionalPaymentStateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        SetAdditionalPaymentReasonsResponse
        | ChooseAdditionalPaymentReasonResponse
        | SetAdditionalPaymentAmountRangeResponse
        | ProvideAdditionalPaymentAmountResponse
        | ProvideAcknowledgementResponse
        | InitializePaymentResponse
        | SetCarrierPostalAddressResponse
        | ChooseFormOfPaymentResponse
        | ReviewPaymentDetailsResponse
        | DetectFormOfPaymentResponse
        | InitiatePaymentSessionResponse
        | ProvidePaymentResponse
        | ValidatePaymentTokenResponse
        | SetPaymentInformationResponse
        | WrapUpMakeAdditionalPaymentResponse
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ChooseAdditionalPaymentReasonOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ChooseAdditionalPaymentReasonDataBag


class ProvideAdditionalPaymentAmountOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideAdditionalPaymentAmountDataBag


class ProvideAcknowledgementOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideAcknowledgementDataBag


class ChooseFormOfPaymentOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ChooseFormOfPaymentDataBag


class ReviewPaymentDetailsOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ReviewPaymentDetailsDataBag


class ProvideEmailAddressesDataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    primaryRecipientEmail: BaseEmail = Field(
        ...,
        description='The email address belonging to the main person who will receive the email.',
    )
    secondaryRecipientEmails: list[BaseEmail] | None = Field(
        None,
        description='A collection of email addresses for anyone who will receive the email other than the primary recipient.',
        max_items=32768,
        min_items=0,
    )


class Action105(Enum):
    provideEmailAddresses = 'provideEmailAddresses'


class DataBag83(ProvideEmailAddressesDataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ProvideEmailAddressesResponse(BaseModel):
    ID: StepID
    action: Action105 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag83 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action106(Enum):
    wrapUpSendCaseEmail = 'wrapUpSendCaseEmail'


class DataBag84(BaseModel):
    emailSubject: str | None = Field(
        None, description='The subject of the email which was sent.'
    )
    files: list[File] = Field(..., max_items=32768, min_items=0)


class WrapUpSendCaseEmailV3Response(BaseModel):
    ID: StepID
    action: Action106 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag84 | None = Field(
        None, description='A data bag that collects both files and structured data.'
    )


class Action107(Enum):
    trackEmailEvents = 'trackEmailEvents'


class Name1(Enum):
    send = 'send'
    delivery = 'delivery'
    bounce = 'bounce'


class EmailEvent(BaseModel):
    emailAddress: BaseEmail = Field(
        ..., description='The email address for the recipient of the email.'
    )
    name: Name1 = Field(..., description='The name of the email event.')
    timestamp: DateTime = Field(
        ..., description='The time at which this email event occurred.'
    )


class DataBag85(BaseModel):
    emailEvents: list[EmailEvent] = Field(
        ...,
        description="A collection of events that occur during the email's lifecycle (e.g. send, delivery, bounce) along with their corresponding timestamps.",
    )
    files: NoFiles | None = None


class TrackEmailEventsResponse(BaseModel):
    ID: StepID
    action: Action107 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag85 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class SendCaseEmailV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        ProvideEmailAddressesResponse
        | WrapUpSendCaseEmailV3Response
        | TrackEmailEventsResponse
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ProvideEmailAddressesOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvideEmailAddressesDataBag


class Action108(Enum):
    wrapUpSendQuoteEmail = 'wrapUpSendQuoteEmail'


class DataBag86(BaseModel):
    emailSubject: str | None = Field(
        None, description='The subject of the email which was sent.'
    )
    files: list[File] = Field(..., max_items=32768, min_items=0)


class WrapUpSendQuoteEmailV3Response(BaseModel):
    ID: StepID
    action: Action108 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag86 | None = Field(
        None, description='A data bag that collects both files and structured data.'
    )


class SendQuoteEmailV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        ProvideEmailAddressesResponse
        | WrapUpSendQuoteEmailV3Response
        | TrackEmailEventsResponse
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class Action109(Enum):
    setPremiumAmount = 'setPremiumAmount'


class PremiumAmount(BaseModel):
    monthlyPremium: LineItems = Field(
        ...,
        description='A collection of individually tracked expenses and credits that combine to create the monthly premium amount.',
    )
    quarterlyPremium: LineItems = Field(
        ...,
        description='A collection of individually tracked expenses and credits that combine to create the quarterly premium amount.',
    )
    semi_AnnualPremium: LineItems = Field(
        ...,
        alias='semi-AnnualPremium',
        description='A collection of individually tracked expenses and credits that combine to create the semi-annual premium amount.',
    )
    annualPremium: LineItems = Field(
        ...,
        description='A collection of individually tracked expenses and credits that combine to create the annual premium amount.',
    )


class DataBag87(BaseModel):
    premiumAmount: PremiumAmount = Field(
        ...,
        description='The total amount of money that is due on a recurring basis, calculated in four different ways (as a Monthly, Quarterly, Semi-Annual, and Annual premium).\n',
    )
    files: NoFiles | None = None


class SetPremiumAmountV3Response(BaseModel):
    ID: StepID
    action: Action109 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag87 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class PaymentMode(Enum):
    Monthly = 'Monthly'
    Quarterly = 'Quarterly'
    Semi_Annual = 'Semi-Annual'
    Annual = 'Annual'


class ProvidePremiumAutopaySettingsV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    startDate: DateTime = Field(
        ...,
        description='The date the user chooses to begin making automatically recurring premium payments.',
    )
    paymentMode: PaymentMode | None = Field(
        None,
        description='The frequency at which the user chooses to make automatically recurring premium payments.',
    )


class Action110(Enum):
    providePremiumAutopaySettings = 'providePremiumAutopaySettings'


class DataBag88(ProvidePremiumAutopaySettingsV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ProvidePremiumAutopaySettingsV3Response(BaseModel):
    ID: StepID
    action: Action110 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag88 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action111(Enum):
    initializeAddPaymentMethod = 'initializeAddPaymentMethod'


class AllowedFormsOfPaymentEnum(Enum):
    Bank = 'Bank'
    CreditCard = 'CreditCard'


class DataBag89(BaseModel):
    allowedFormsOfPayment: list[AllowedFormsOfPaymentEnum] = Field(
        ...,
        description='The forms of payment that the carrier allows to be used for this kind of transaction.',
        max_items=2,
        min_items=1,
    )
    files: NoFiles | None = None


class InitializeAddPaymentMethodResponse(BaseModel):
    ID: StepID
    action: Action111 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag89 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action112(Enum):
    initiateAddPaymentMethodSession = 'initiateAddPaymentMethodSession'


class DataBag90(BaseModel):
    addPaymentMethodSessionID: SchemasID = Field(
        ...,
        description='A unique session ID for adding a new payment method, as issued by a 3rd party payment service.',
    )
    files: NoFiles


class InitiateAddPaymentMethodSessionResponse(BaseModel):
    ID: StepID
    action: Action112 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag90 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class ProvidePaymentMethodDataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    paymentMethodID: ID = Field(
        ...,
        description='A unique identifier for the payment method, as issued by a third party payment service. Used to retrieve payment method information.',
    )


class Action113(Enum):
    providePaymentMethod = 'providePaymentMethod'


class DataBag91(ProvidePaymentMethodDataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ProvidePaymentMethodResponse(BaseModel):
    ID: StepID
    action: Action113 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag91 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action114(Enum):
    validateAddPaymentMethodToken = 'validateAddPaymentMethodToken'


class ValidateAddPaymentMethodTokenResponse(BaseModel):
    ID: StepID
    action: Action114 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class Action115(Enum):
    setPaymentMethod = 'setPaymentMethod'


class DataBag92(BaseModel):
    formOfPayment: BankAccount | CreditCard = Field(
        ..., description='The payment method that the user has chosen to pay with.'
    )
    files: NoFiles | None = None


class SetPaymentMethodResponse(BaseModel):
    ID: StepID
    action: Action115 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag92 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action116(Enum):
    wrapUpSetUpPremiumAutopay = 'wrapUpSetUpPremiumAutopay'


class WrapUpSetUpPremiumAutopayV3Response(BaseModel):
    ID: StepID
    action: Action116 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class SetUpPremiumAutopayV3StateComponentsSchemasJourneyResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        SetPremiumAmountV3Response
        | ProvidePremiumAutopaySettingsV3Response
        | InitializeAddPaymentMethodResponse
        | InitiateAddPaymentMethodSessionResponse
        | ProvidePaymentMethodResponse
        | ValidateAddPaymentMethodTokenResponse
        | SetPaymentMethodResponse
        | ReviewSubmissionResponse
        | WrapUpSetUpPremiumAutopayV3Response
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ProvidePremiumAutopaySettingsV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvidePremiumAutopaySettingsV3DataBag


class ProvidePaymentMethodOperation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ProvidePaymentMethodDataBag


class Action117(Enum):
    setSurrenderReasonsV3 = 'setSurrenderReasonsV3'


class SurrenderReason(BaseModel):
    surrenderReason: str | None = Field(
        None,
        description='An individual reason why a policyowner may want to surrender their policy during the free look period.',
    )


class DataBag93(BaseModel):
    surrenderReasons: list[SurrenderReason] | None = Field(
        None,
        description='A collection of possible reasons why a policyowner may want to surrender their policy during the free look period.',
    )
    files: NoFiles | None = None


class SetSurrenderReasonsV3Response(BaseModel):
    ID: StepID
    action: Action117 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag93 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class SurrenderReason1(BaseModel):
    surrenderReason: str | None = Field(
        None,
        description='An individual reason why the policyowner wants to surrender their policy.',
    )


class ChooseSurrenderReasonsV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    surrenderReasons: list[SurrenderReason1] | None = Field(
        None,
        description='A collection of reasons why the policyowner wants to surrender their policy.',
    )


class Action118(Enum):
    chooseSurrenderReasons = 'chooseSurrenderReasons'


class DataBag94(ChooseSurrenderReasonsV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ChooseSurrenderReasonsV3Response(BaseModel):
    ID: StepID
    action: Action118 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag94 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class UploadDocumentsV3DataBag1(BaseModel):
    class Config:
        extra = Extra.forbid

    files: Binaries


class AssignmentType(Enum):
    Absolute = 'Absolute'
    Collateral = 'Collateral'


class PolicyAssignedTo(BaseModel):
    class Config:
        extra = Extra.forbid

    fullName: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The name of the policyowner (i.e. the person to whom the policy was assigned, transferred or pledged).',
    )
    assignmentType: AssignmentType | None = Field(
        None,
        description='The kind of policy assignment (e.g. absolute or collateral) this policyowner holds.',
    )
    assignmentDate: DateTime = Field(
        ..., description='The date on which the policy was assigned to the policyowner.'
    )


class UploadDocumentsV3DataBag2(BaseModel):
    class Config:
        extra = Extra.forbid

    noDocumentsReason: constr(min_length=1, max_length=32) = Field(
        ..., description='The reason why original documents are unavailable.'
    )
    policyAssignedTo: PolicyAssignedTo
    files: NoFiles


class UploadDocumentsV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    __root__: UploadDocumentsV3DataBag1 | UploadDocumentsV3DataBag2


class Action119(Enum):
    uploadDocuments = 'uploadDocuments'


class DataBag951(BaseModel):
    class Config:
        extra = Extra.forbid

    files: Binaries


class PolicyAssignedTo1(BaseModel):
    class Config:
        extra = Extra.forbid

    fullName: constr(min_length=1, max_length=32767) = Field(
        ...,
        description='The name of the policyowner (i.e. the person to whom the policy was assigned, transferred or pledged).',
    )
    assignmentType: AssignmentType | None = Field(
        None,
        description='The kind of policy assignment (e.g. absolute or collateral) this policyowner holds.',
    )
    assignmentDate: DateTime = Field(
        ..., description='The date on which the policy was assigned to the policyowner.'
    )


class DataBag952(BaseModel):
    class Config:
        extra = Extra.forbid

    noDocumentsReason: constr(min_length=1, max_length=32) = Field(
        ..., description='The reason why original documents are unavailable.'
    )
    policyAssignedTo: PolicyAssignedTo1
    files: NoFiles


class DataBag953(BaseModel):
    class Config:
        extra = Extra.forbid


class DataBag954(DataBag951, DataBag953):
    class Config:
        extra = Extra.forbid

    files: Binaries


class DataBag955(DataBag952, DataBag953):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class DataBag95(BaseModel):
    __root__: DataBag954 | DataBag955 = Field(
        ...,
        description="A data bag that collects either files *or* structured data, depending on the user's actions.",
    )


class UploadDocumentsV3Response(BaseModel):
    ID: StepID
    action: Action119 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag95 | None = Field(
        None,
        description="A data bag that collects either files *or* structured data, depending on the user's actions.",
    )


class ReviewTermsAndConditionsV3DataBag(BaseModel):
    class Config:
        extra = Extra.forbid

    isAcknowledged: bool = Field(
        ...,
        description='True indicates that the user has acknowledged the terms and conditions.',
    )
    isAuthorized: bool = Field(
        ...,
        description='True indicates that the user has authorized the surrender of the policy.',
    )
    isDeclared: bool = Field(
        ...,
        description='True indicates that the user has declared themselves as someone with the legal authority to surrender the policy.',
    )


class Action120(Enum):
    reviewTermsAndConditions = 'reviewTermsAndConditions'


class DataBag96(ReviewTermsAndConditionsV3DataBag):
    class Config:
        extra = Extra.forbid

    files: NoFiles


class ReviewTermsAndConditionsV3Response(BaseModel):
    ID: StepID
    action: Action120 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToActor
    completedTime: StepCompletedTime | None = None
    dataBag: DataBag96 | None = Field(
        None,
        description='A data bag that collects structured data but does not collect files.',
    )


class Action121(Enum):
    wrapUpSurrenderPolicyDuringFreeLookPeriod = (
        'wrapUpSurrenderPolicyDuringFreeLookPeriod'
    )


class WrapUpSurrenderPolicyDuringFreeLookPeriodV3Response(BaseModel):
    ID: StepID
    action: Action121 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class Action122(Enum):
    cancelExistingJourneys = 'cancelExistingJourneys'


class CancelExistingJourneysV3Response(BaseModel):
    ID: StepID
    action: Action122 = Field(
        ..., description='The name of the step; briefly summarizes what this step does.'
    )
    attributes: dict[str, Any] = Field(
        ...,
        description='A collection of metadata items that the journey author has attached to this step.',
    )
    assignedTo: AssignedToAutomated
    completedTime: StepCompletedTime | None = None
    dataBag: EmptyDataBag | None = None


class SurrenderPolicyDuringFreeLookPeriodV3StateComponentsSchemasJourneyResponse(
    BaseModel
):
    class Config:
        extra = Extra.forbid

    isComplete: IsJourneyComplete
    status: JourneyInstanceStatus
    cancelledReason: CancelledReason | None = None
    cancellation: Cancellation | None = None
    failedReason: FailedReason | None = None
    waitingForActor: IsWaitingForActor
    currentStep: CurrentStepID | None = None
    targetObjectID: TargetObjectID
    targetType: TargetType
    startTime: StartTime
    completedTime: CompletedTime | None = None
    isFFAAllowed: IsFFAAllowed
    ffaActors: FFAActors
    originator: Originator
    steps: list[
        SetSurrenderReasonsV3Response
        | ChooseSurrenderReasonsV3Response
        | UploadDocumentsV3Response
        | ChooseDisbursementMethodResponse
        | ReviewTermsAndConditionsV3Response
        | WrapUpSurrenderPolicyDuringFreeLookPeriodV3Response
        | CancelExistingJourneysV3Response
    ] = Field(
        ...,
        description='A collection of actor steps and automated steps that make up this journey.',
    )


class ChooseSurrenderReasonsV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ChooseSurrenderReasonsV3DataBag


class UploadDocumentsV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: UploadDocumentsV3DataBag


class ReviewTermsAndConditionsV3Operation(BaseModel):
    class Config:
        extra = Extra.forbid

    operation: Operation19 | None = None
    params: ReviewTermsAndConditionsV3DataBag
>>>>>>> 0cdd862 (agentbuild)
