# pgschema declarative schema migration Job
#
# Each run creates a uniquely-named Job (via generateName) so past runs are
# preserved and their logs remain inspectable.
#
# Preferred usage through mise:
#   mise run schema:plan          # preview changes
#   mise run schema:apply         # execute changes
#   mise run schema:history       # list past migration jobs
#   mise run schema:clean         # delete all completed migration jobs
#
# Manual usage:
#   kubectl create -f k8s/pgschema-update.yaml        # plan (default)
#   kubectl logs job/<job-name>                        # view output
#
#   sed 's/value: plan/value: apply/' k8s/pgschema-update.yaml | kubectl create -f -
# TODO: not sure if I like the grants setup here, isn't there a better way?
apiVersion: batch/v1
kind: Job
metadata:
  generateName: pgschema-update-
  labels:
    app: pgschema-update
spec:
  backoffLimit: 0
  template:
    metadata:
      labels:
        app: pgschema-update
    spec:
      restartPolicy: Never
      # ttlSecondsAfterFinished: 3600  # Clean up after 1hr
      containers:
        - name: pgschema
          image: pgplex/pgschema:latest
          env:
            # target database
            - name: PGHOST
              valueFrom:
                secretKeyRef:
                  name: sds-dev-superuser
                  key: host
            - name: PGPORT
              valueFrom:
                secretKeyRef:
                  name: sds-dev-superuser
                  key: port
            - name: PGUSER
              valueFrom:
                secretKeyRef:
                  name: sds-dev-superuser
                  key: username
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: sds-dev-superuser
                  key: password
            - name: PGDATABASE
              value: main
            # "plan" (default, safe preview) or "apply" (executes changes)
            - name: PGSCHEMA_COMMAND
              value: plan
          command: ["sh", "-c"]
          args:
            - |
              set -e

              EXTRA_ARGS=""
              if [ "$PGSCHEMA_COMMAND" = "apply" ]; then
                EXTRA_ARGS="--auto-approve"
              fi

              cat /schemas/raw/*.sql > /tmp/raw.sql
              cat /schemas/domain/*.sql > /tmp/domain.sql

              echo "=== raw schema ==="
              pgschema $PGSCHEMA_COMMAND --file /tmp/raw.sql --schema raw $EXTRA_ARGS

              echo ""
              echo "=== domain schema ==="
              pgschema $PGSCHEMA_COMMAND --file /tmp/domain.sql --schema domain $EXTRA_ARGS

              if [ "$PGSCHEMA_COMMAND" = "apply" ]; then
                echo ""
                echo "=== grants ==="
                cat /schemas/grants/*.sql | psql
              fi
          volumeMounts:
            - name: raw-schema
              mountPath: /schemas/raw
              readOnly: true
            - name: domain-schema
              mountPath: /schemas/domain
              readOnly: true
            - name: grants
              mountPath: /schemas/grants
              readOnly: true

      volumes:
        - name: raw-schema
          configMap:
            name: pgschema-raw
        - name: domain-schema
          configMap:
            name: pgschema-domain
        - name: grants
          configMap:
            name: pgschema-grants
